{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"a4c3019f6d4e23a097f7e988ec3ed932c4c0c3af","modified":1584306307236},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1584306665915},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1584306665914},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1584306665915},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1584306665915},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1584306665915},{"_id":"themes/yilia/_config.yml","hash":"e1b3c914c804a2ed569d091e577641a3137557f1","modified":1584306860052},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1584306665915},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1584306665915},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1584306665921},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1584306665932},{"_id":"source/_drafts/flickr-api-test.md","hash":"a022d4951073a1e2c6c0bbb0b430acc769f50f42","modified":1584306307236},{"_id":"source/_drafts/timeline.md","hash":"7b641a15dd1f9d6cb714d6e55b385e2e24ffd1bd","modified":1584306307237},{"_id":"source/_posts/Dart tear-offs.md","hash":"315211b4b9498cd1e6f228e483dca0dea4759bf0","modified":1584306307237},{"_id":"source/_posts/Dart-final&const.md","hash":"4b96905268bebe4f20606d9d028851b80381d283","modified":1584306307237},{"_id":"source/_posts/Dart-foctory关键字.md","hash":"3420d96ecd09c4ba5af274a384b13a95cba74d82","modified":1584306307237},{"_id":"source/_posts/Dart-函数.md","hash":"5a7e511c811f57c7696daa2e13c1629171f69e39","modified":1584306307238},{"_id":"source/_posts/Dart-初始化延迟.md","hash":"d5cf812deeb1da4713097c7577a6fa4245c5184f","modified":1584306307238},{"_id":"source/_posts/Dart-函数参数.md","hash":"829cbeefcb3a13fb20f2d21203f005a1199b0c05","modified":1584306307238},{"_id":"source/_posts/Dart-命名构造函数.md","hash":"a90ba22589d2983134caeef588d86b30ca427a64","modified":1584306307238},{"_id":"source/_posts/Dart-库管理.md","hash":"22fb2d0f6a084ff56248fbc8ebfcccc59e39ba4e","modified":1584306307238},{"_id":"source/_posts/Dart-异步.md","hash":"a96869aa62261df82cd78fbc1d4ca2cb6bc05976","modified":1584306307239},{"_id":"source/_posts/Dart-抽象方法、抽象类和接口.md","hash":"598c0a847b8923df63037b46ef10093e82b432c6","modified":1584306307239},{"_id":"source/_posts/Dart-控制流语句.md","hash":"be0d6f8d63a45d87a896d2165187a71960c49182","modified":1584306307239},{"_id":"source/_posts/Dart-泛型.md","hash":"bfb95320e5a6fbf8479d217b3319e3ca18db6310","modified":1584306307239},{"_id":"source/_posts/Dart-相等的探索.md","hash":"ee8936cf517b1fcf6ade7c3f6bd12c1bd512dcd1","modified":1584306307240},{"_id":"source/_posts/Dart-类型.md","hash":"15b67902f72501dff12cbc78f25ac425d59d4568","modified":1584306307240},{"_id":"source/_posts/Dart-类成员的初始化.md","hash":"1bb2d9f9b40409c29eca35ecbf4110a5d78498f3","modified":1584306307240},{"_id":"source/_posts/MATLAB-入门.md","hash":"eb9e88347fb75e5366f011e72d33aad9347c89ec","modified":1584306307241},{"_id":"source/_posts/MATLAB-函数（一）.md","hash":"e453fbf7d5fa81dce4340a30926054e654925849","modified":1584306307241},{"_id":"source/_posts/MATLAB-函数（二）.md","hash":"a6c507bb0bca4724a11e0bedccff16dfa6542ed9","modified":1584306307242},{"_id":"source/_posts/HTTP-学习笔记.md","hash":"8395c3a4bbb0c278967fd7f0c7b402e9d3471a2b","modified":1584306307241},{"_id":"source/_posts/MATLAB-矩阵（一）.md","hash":"1a014fbddfabe9fabba0085255cc1a20b5b17154","modified":1584306307242},{"_id":"source/_posts/MATLAB-绘图（一）.md","hash":"3ff0080de82a4ad7e4a31670932501a1c65d7370","modified":1584306307242},{"_id":"source/_posts/MATLAB-矩阵（二）.md","hash":"17e3ba0bab8d7de3298ebe3aeebead82b2330bc1","modified":1584306307242},{"_id":"source/_posts/MATLAB-绘图（二）.md","hash":"478c9f58187ffe8ee6f00b7aae93cd9f71555c90","modified":1584306307242},{"_id":"source/_posts/MATLAB-语法.md","hash":"71920139c9affc8a7fc08ae50ee1a277004c2e54","modified":1584306307242},{"_id":"source/_posts/MATLAB-逻辑.md","hash":"15423266582f758484854d9e2688802b4c21854b","modified":1584306307243},{"_id":"source/_posts/flutter-No-NDK-toolchains-Error.md","hash":"e4155e64db8513cd45d0da3e9eb3f9f80586cae0","modified":1584306307243},{"_id":"source/_posts/git 笔记.md","hash":"16c03099fea003ef9cc4980eb3863217f60acb9a","modified":1584306307243},{"_id":"source/_posts/js 重定向问题.md","hash":"532f619931efe62e09e9b857ed9498eeea3740da","modified":1584306307243},{"_id":"source/_posts/初识 Firebase.md","hash":"23756d5a0377541a75010cfbb6ee0a865fcfc488","modified":1584306307243},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1584306665908},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1584306665910},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1584306660196},{"_id":"themes/yilia/.git/index","hash":"8926315a836057b15410fc526bf06f38339b86fe","modified":1584306665932},{"_id":"themes/yilia/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1584306665906},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1584306665915},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1584306665916},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1584306665916},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1584306665916},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1584306665916},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1584306665916},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1584306665920},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1584306665920},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1584306665920},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1584306665920},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1584306665920},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1584306665920},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1584306665920},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1584306665916},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1584306665932},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1584306665921},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1584306665928},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1584306665920},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1584306665930},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1584306665931},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1584306665931},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1584306660197},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1584306660196},{"_id":"themes/yilia/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1584306660197},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1584306660197},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1584306660198},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1584306660198},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1584306660198},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1584306660197},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1584306660198},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1584306660196},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1584306660198},{"_id":"themes/yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1584306660195},{"_id":"themes/yilia/.git/logs/HEAD","hash":"12aa9cf403913087a5b96df8e9f5ff23b77ef459","modified":1584306665909},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1584306665916},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1584306665916},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1584306665916},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1584306665917},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1584306665920},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1584306665920},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1584306665929},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1584306665929},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1584306665929},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1584306665930},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1584306665930},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1584306665930},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1584306665929},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1584306665930},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1584306665930},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1584306665921},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1584306665921},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1584306665921},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1584306665921},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1584306665921},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1584306665921},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1584306665922},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1584306665922},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1584306665922},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1584306665923},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1584306665924},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1584306665924},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1584306665924},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1584306665924},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1584306665925},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1584306665925},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1584306665925},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1584306665925},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1584306665926},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1584306665926},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1584306665926},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1584306665926},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1584306665926},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1584306665926},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1584306665926},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1584306665926},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1584306665927},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1584306665927},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1584306665927},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1584306665927},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1584306665927},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1584306665927},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1584306665928},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1584306665928},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1584306665928},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1584306665928},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1584306665928},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1584306665928},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1584306665928},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1584306665919},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1584306665909},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1584306665918},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1584306665919},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1584306665919},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1584306665919},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1584306665919},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1584306665922},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1584306665922},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1584306665922},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1584306665922},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1584306665923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1584306665923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1584306665923},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1584306665924},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1584306665925},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1584306665924},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1584306665925},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1584306665925},{"_id":"themes/yilia/.git/objects/pack/pack-0b03c5bfa5e61096ae6f19ffe58b8f518cb91d9a.idx","hash":"902a5d275eb055a062115fc65f6d944bdd1d2ac0","modified":1584306665898},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"12aa9cf403913087a5b96df8e9f5ff23b77ef459","modified":1584306665909},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1584306665907},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"12aa9cf403913087a5b96df8e9f5ff23b77ef459","modified":1584306665907},{"_id":"themes/yilia/.git/objects/pack/pack-0b03c5bfa5e61096ae6f19ffe58b8f518cb91d9a.pack","hash":"5300ff398d91164eca4ce2a57df5a92f03d301e5","modified":1584306665897},{"_id":"public/content.json","hash":"90005f99df9094f473973f9bd85363be5874cdb3","modified":1584306896803},{"_id":"public/2020/03/13/Dart tear-offs/index.html","hash":"a72ca654844ab839aad520290a87298908dfb8c6","modified":1584306896806},{"_id":"public/2019/10/18/js 重定向问题/index.html","hash":"c8e54a75f98172277c95db242cf9aa2ded780b1a","modified":1584306896806},{"_id":"public/2019/10/15/git 笔记/index.html","hash":"0c30c9d42e3b118f68c18867f7e0cc4f32ee2ecd","modified":1584306896806},{"_id":"public/2019/10/11/Dart-库管理/index.html","hash":"2cae412f2e1704062a3c45ddd3d9c830e3fe9808","modified":1584306896807},{"_id":"public/2019/07/28/flutter-No-NDK-toolchains-Error/index.html","hash":"1e79060203562e55fc55707ecfd9aeb4742ca5f0","modified":1584306896807},{"_id":"public/2019/06/24/Dart-final&const/index.html","hash":"13774097b6e89c71cf05ece096bd20eed1a3ba47","modified":1584306896807},{"_id":"public/2019/06/22/Dart-类型/index.html","hash":"6d95e3d1f3d5449b088fc28b949eb8ca0fdd29b7","modified":1584306896807},{"_id":"public/2019/06/21/Dart-泛型/index.html","hash":"5edb1939cdadc7a3f0e5e4e5a2aa1f20665891c0","modified":1584306896807},{"_id":"public/2019/06/20/Dart-控制流语句/index.html","hash":"ab09b3cb40badb1d692dda6b39bbf30c42a181e7","modified":1584306896807},{"_id":"public/2019/06/16/Dart-异步/index.html","hash":"bb9651fa8944b12f50e12ec24f6cf0f0dfc7c90d","modified":1584306896808},{"_id":"public/2019/05/17/Dart-函数/index.html","hash":"ee64611ed16e9f0ac2fd24638863cf3a23552489","modified":1584306896808},{"_id":"public/2019/05/16/Dart-函数参数/index.html","hash":"a2bc1b24c801b41b9db5fdcecd325c78552a60bf","modified":1584306896808},{"_id":"public/2019/05/14/Dart-foctory关键字/index.html","hash":"11811a3a9a436c54554d6519ec57350746811d87","modified":1584306896808},{"_id":"public/2019/05/14/Dart-命名构造函数/index.html","hash":"c8df03fe554186ac2151961ad77f2b0acb369c65","modified":1584306896808},{"_id":"public/2019/05/12/Dart-类成员的初始化/index.html","hash":"6f626c8dc394b52d19a1b3c907cc61f267559ed0","modified":1584306896808},{"_id":"public/2019/05/11/Dart-抽象方法、抽象类和接口/index.html","hash":"cb4a7bca1325e99c993de6e23a476b1c88950c19","modified":1584306896808},{"_id":"public/2019/05/10/Dart-相等的探索/index.html","hash":"d0558c48f21b586b8da3553a3b3443027393cbf9","modified":1584306896809},{"_id":"public/2019/05/10/Dart-初始化延迟/index.html","hash":"b60af47a07c5fda039339f91f59488ff5e46b83b","modified":1584306896810},{"_id":"public/2018/10/24/初识 Firebase/index.html","hash":"53ea25b89ca9f60d7ca404ede0fb96d9e805c067","modified":1584306896810},{"_id":"public/2018/05/04/HTTP-学习笔记/index.html","hash":"75a7fcafb57ce6b52d663de8eb156714106a5c79","modified":1584306896810},{"_id":"public/2018/04/13/MATLAB-绘图（二）/index.html","hash":"9f3a2081660e876b3b95be9300557eac642f1a42","modified":1584306896810},{"_id":"public/2018/04/03/MATLAB-绘图（一）/index.html","hash":"022530bec731d31770467f84eb12fae78ca983de","modified":1584306896810},{"_id":"public/2018/03/18/MATLAB-函数（二）/index.html","hash":"3a3d07670d587f716167c81da16a5b04d9551322","modified":1584306896810},{"_id":"public/2018/03/15/MATLAB-函数（一）/index.html","hash":"932fc5ff52503608e2970de9f49b9c59629f201a","modified":1584306896810},{"_id":"public/2018/03/06/MATLAB-语法/index.html","hash":"f73039e66b5465329f4cce5181a86d66a8d0ff0a","modified":1584306896811},{"_id":"public/2018/03/05/MATLAB-逻辑/index.html","hash":"ff7286b0ee118ffd9e34949794517520dd435e85","modified":1584306896811},{"_id":"public/2018/03/04/MATLAB-矩阵（二）/index.html","hash":"64166cf3b2234fe56e1e0a31018465cb25b05c00","modified":1584306896811},{"_id":"public/2018/03/03/MATLAB-矩阵（一）/index.html","hash":"dce3e239790c170dd02f714ebddf9c9efd04e5c9","modified":1584306896811},{"_id":"public/2018/03/02/MATLAB-入门/index.html","hash":"f6d9ac9d1cad648e629a22e49547d140efda1b5d","modified":1584306896811},{"_id":"public/archives/index.html","hash":"f2727ba92bf97959b9014727261a94839ca143c5","modified":1584306896811},{"_id":"public/archives/page/2/index.html","hash":"59f35a2775a906a522697a3759698a61cc25b0da","modified":1584306896811},{"_id":"public/archives/page/3/index.html","hash":"67f7faecfdab6384c2fb7fdc2bd45ab94d8fc7e8","modified":1584306896812},{"_id":"public/archives/2018/index.html","hash":"2f05cca73d5464e2032db0154fcb2335aa279a1b","modified":1584306896812},{"_id":"public/archives/2018/page/2/index.html","hash":"7d6aed1c004321606fb2d20302b025ce5797b1a5","modified":1584306896812},{"_id":"public/archives/2018/03/index.html","hash":"464b8b0f65de5fd6784c3a8c1a10f868f91ef1f9","modified":1584306896812},{"_id":"public/archives/2018/04/index.html","hash":"20870041832f5651760886134a03b69e993d0983","modified":1584306896812},{"_id":"public/archives/2018/05/index.html","hash":"d4bd22bf033fc06ea62030aa0648afdc4b7c57c5","modified":1584306896812},{"_id":"public/archives/2018/10/index.html","hash":"3af725554da4da4c23672cdae34660c8e5bcdc44","modified":1584306896812},{"_id":"public/archives/2019/index.html","hash":"7285a41e5af044f459ddb76b7f1398ae859995ac","modified":1584306896813},{"_id":"public/archives/2019/page/2/index.html","hash":"ee47c8102665fa118d2bf80d554a7bc4ce5f9a76","modified":1584306896813},{"_id":"public/archives/2019/05/index.html","hash":"9462cb12986aedf46c160c57b14a587af206587c","modified":1584306896813},{"_id":"public/archives/2019/06/index.html","hash":"2716eba45da5631385c85a45cfdfc5aaeef32f2b","modified":1584306896813},{"_id":"public/archives/2019/07/index.html","hash":"9a7062dcf99e81fc2dd873ee5611f5f42232b5b5","modified":1584306896813},{"_id":"public/archives/2019/10/index.html","hash":"69c8ba25aa713bcc7b9d88bb63505e236d9df12e","modified":1584306896813},{"_id":"public/archives/2020/index.html","hash":"7a55655fb35f0b5cccd3497b4faae852e65cb79e","modified":1584306896813},{"_id":"public/archives/2020/03/index.html","hash":"6f232a4a87f9c20faac81a5166cbfc2a3ed88252","modified":1584306896813},{"_id":"public/index.html","hash":"68b89cb977b487c4a237966fc95da5ba8ff9445c","modified":1584306896814},{"_id":"public/page/2/index.html","hash":"1435b640fdbacb510e5cb150025abf0b815810cc","modified":1584306896814},{"_id":"public/page/3/index.html","hash":"33bf032bc0218365ce9bb3618f9a92b934345516","modified":1584306896814},{"_id":"public/tags/dart/index.html","hash":"4aa2396790cb29c2248c8b4016e1f9c8858516db","modified":1584306896814},{"_id":"public/tags/Dart/index.html","hash":"b40001457f0e78e8302546abb729a70d93d61ec7","modified":1584306896814},{"_id":"public/tags/Dart/page/2/index.html","hash":"eae559721d3252c4750ae459aa769e343182e1e1","modified":1584306896814},{"_id":"public/tags/MATLAB/index.html","hash":"0dedcfdd10a305c51ed6d3df31c008af90ff094a","modified":1584306896814},{"_id":"public/tags/HTTP/index.html","hash":"8b2ddea3b05fb598a1aba5a19e9aa78586ec6836","modified":1584306896815},{"_id":"public/tags/flutter/index.html","hash":"10a28fe894d6bc3abae47ff85415db97b0d055a3","modified":1584306896815},{"_id":"public/tags/git/index.html","hash":"a4386366cd7f66b06d01dd4894a9fec01b63ba2f","modified":1584306896815},{"_id":"public/tags/JavaScript/index.html","hash":"8127c196334707210e36042eb131aa7383bdf69d","modified":1584306896815},{"_id":"public/tags/Firebase/index.html","hash":"e572e66fd4740ce8c9b9958f7d5edd772d990fc9","modified":1584306896815},{"_id":"public/CNAME","hash":"a4c3019f6d4e23a097f7e988ec3ed932c4c0c3af","modified":1584306896817},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1584306896817},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1584306896817},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1584306896817},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1584306896817},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1584306896818},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1584306896818},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1584306896818},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1584306896818},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1584306896818},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1584306896822},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1584306896822},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1584306896822},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1584306896822}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"flickr api test","date":"2019-07-01T10:34:53.000Z","_content":"\n### Flickr API\n\nFlickr API 比较方便，可以从 [官方文档页](http://flickr.com/services/api/) 查看。其中 REST 服务的端点是 [http://api.flickr.com/services/rest/](http://api.flickr.com/services/rest/) 。\n\n### API key\n\nAPI key 需要通过 Yahoo ID 登录申请。\n\n### URI 结构\n\n相应的请求可以通过拼接 API 参数。\n\n### 相关参数\n\n- method 参数：传递需要调用的方法\n\n- api_key 参数：传递申请的 API key\n\n- format 参数：告知服务器返回的参数\n\n- nojsoncallback 参数：使用 1 告知 Flickr 返回的数据不应包括封闭方法名和括号，便于解析数据。\n\n  ","source":"_drafts/flickr-api-test.md","raw":"---\ntitle: flickr api test\ndate: 2019-07-01 18:34:53\ntags: [flickr, api]\n---\n\n### Flickr API\n\nFlickr API 比较方便，可以从 [官方文档页](http://flickr.com/services/api/) 查看。其中 REST 服务的端点是 [http://api.flickr.com/services/rest/](http://api.flickr.com/services/rest/) 。\n\n### API key\n\nAPI key 需要通过 Yahoo ID 登录申请。\n\n### URI 结构\n\n相应的请求可以通过拼接 API 参数。\n\n### 相关参数\n\n- method 参数：传递需要调用的方法\n\n- api_key 参数：传递申请的 API key\n\n- format 参数：告知服务器返回的参数\n\n- nojsoncallback 参数：使用 1 告知 Flickr 返回的数据不应包括封闭方法名和括号，便于解析数据。\n\n  ","slug":"flickr-api-test","published":0,"updated":"2020-03-15T21:05:07.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3vy000029fy0k3dsl2z","content":"<h3 id=\"Flickr-API\"><a href=\"#Flickr-API\" class=\"headerlink\" title=\"Flickr API\"></a>Flickr API</h3><p>Flickr API 比较方便，可以从 <a href=\"http://flickr.com/services/api/\" target=\"_blank\" rel=\"noopener\">官方文档页</a> 查看。其中 REST 服务的端点是 <a href=\"http://api.flickr.com/services/rest/\" target=\"_blank\" rel=\"noopener\">http://api.flickr.com/services/rest/</a> 。</p>\n<h3 id=\"API-key\"><a href=\"#API-key\" class=\"headerlink\" title=\"API key\"></a>API key</h3><p>API key 需要通过 Yahoo ID 登录申请。</p>\n<h3 id=\"URI-结构\"><a href=\"#URI-结构\" class=\"headerlink\" title=\"URI 结构\"></a>URI 结构</h3><p>相应的请求可以通过拼接 API 参数。</p>\n<h3 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h3><ul>\n<li><p>method 参数：传递需要调用的方法</p>\n</li>\n<li><p>api_key 参数：传递申请的 API key</p>\n</li>\n<li><p>format 参数：告知服务器返回的参数</p>\n</li>\n<li><p>nojsoncallback 参数：使用 1 告知 Flickr 返回的数据不应包括封闭方法名和括号，便于解析数据。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Flickr-API\"><a href=\"#Flickr-API\" class=\"headerlink\" title=\"Flickr API\"></a>Flickr API</h3><p>Flickr API 比较方便，可以从 <a href=\"http://flickr.com/services/api/\" target=\"_blank\" rel=\"noopener\">官方文档页</a> 查看。其中 REST 服务的端点是 <a href=\"http://api.flickr.com/services/rest/\" target=\"_blank\" rel=\"noopener\">http://api.flickr.com/services/rest/</a> 。</p>\n<h3 id=\"API-key\"><a href=\"#API-key\" class=\"headerlink\" title=\"API key\"></a>API key</h3><p>API key 需要通过 Yahoo ID 登录申请。</p>\n<h3 id=\"URI-结构\"><a href=\"#URI-结构\" class=\"headerlink\" title=\"URI 结构\"></a>URI 结构</h3><p>相应的请求可以通过拼接 API 参数。</p>\n<h3 id=\"相关参数\"><a href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"></a>相关参数</h3><ul>\n<li><p>method 参数：传递需要调用的方法</p>\n</li>\n<li><p>api_key 参数：传递申请的 API key</p>\n</li>\n<li><p>format 参数：告知服务器返回的参数</p>\n</li>\n<li><p>nojsoncallback 参数：使用 1 告知 Flickr 返回的数据不应包括封闭方法名和括号，便于解析数据。</p>\n</li>\n</ul>\n"},{"title":"timeline","_content":"\n\n\n2019 年 6 月 9 日：明日毕业照。\n2019 年 6 月 10 日：今日毕业照，谈论到公司的技术路线问题。目前土巴兔的移动开发技术已经尝试使用 Flutter，相信近期适合跨平台开发者的发展路线。\n\n2019 年 6 月 10 日：短期内深圳才是我们应该混的地方。\n\n2019 年 6 月 11 日：今日完成图书交付，斗鱼开发者提上日程\n2019 年 6 月 12 日：斗鱼开发者 token 获取异常，似乎需要权限而申请权限选项中并不包含。\n2019 年 6 月 13 日：重新看回 Dart 编程语言一书。\n\n2019 年 6 月 15 日：看看 Dart 的异步机制。\n2019 年 6 月 16 日：Dart 异步和 Isolate 的概念基本理清楚了。\n2019 年 6 月 18 日：Dart 异步事件机制。\n2019 年 6 月 21 日：Dart 类型整理。\n\n2019年6月25日：今日根据 Flickr API 测试 Flutter。\n\n2019年6月27日：今日根据实现 Flickr API 第二个接口，并改写工具类。\n\n 2019年6月28日：今日修复工具类的 bug。\n\n2019年6月29日：今日离校。\n\n2019年7月11日：肠胃炎休息一周。 \n2019年7月14日：肠胃炎并发发烧延迟入职，接着住院。\n2019年7月15日：恢复中……\n2019年7月16日：明日回深圳\n2019年8月12日：家中丧事，断了几天。\n2019年8月13日：土巴兔视频模块进度紧张。\n2019年8月14日：昨夜加班。\n2019-8-20 00:04:39 昨天遇到了许多 flutter 的异常，尚未整理。重点关注插件引起的无差别闪退。\n2019-9-13 21:17:49 中秋休息、\n2019-11-02 23:05:11 咳嗽严重，持续一周\n2019-11-04 20:02:05 不见好转。。。\n2019-11-05 23:57:26 今日完成中文简历，收到 bytedance 邀请；project commit 进度比较多。 \n\n2020-02-22 22:25:08 2020的病毒疫情实在严重，并且暴露出很多问题。\n","source":"_drafts/timeline.md","raw":"---\ntitle: timeline\ntags: timeline\n---\n\n\n\n2019 年 6 月 9 日：明日毕业照。\n2019 年 6 月 10 日：今日毕业照，谈论到公司的技术路线问题。目前土巴兔的移动开发技术已经尝试使用 Flutter，相信近期适合跨平台开发者的发展路线。\n\n2019 年 6 月 10 日：短期内深圳才是我们应该混的地方。\n\n2019 年 6 月 11 日：今日完成图书交付，斗鱼开发者提上日程\n2019 年 6 月 12 日：斗鱼开发者 token 获取异常，似乎需要权限而申请权限选项中并不包含。\n2019 年 6 月 13 日：重新看回 Dart 编程语言一书。\n\n2019 年 6 月 15 日：看看 Dart 的异步机制。\n2019 年 6 月 16 日：Dart 异步和 Isolate 的概念基本理清楚了。\n2019 年 6 月 18 日：Dart 异步事件机制。\n2019 年 6 月 21 日：Dart 类型整理。\n\n2019年6月25日：今日根据 Flickr API 测试 Flutter。\n\n2019年6月27日：今日根据实现 Flickr API 第二个接口，并改写工具类。\n\n 2019年6月28日：今日修复工具类的 bug。\n\n2019年6月29日：今日离校。\n\n2019年7月11日：肠胃炎休息一周。 \n2019年7月14日：肠胃炎并发发烧延迟入职，接着住院。\n2019年7月15日：恢复中……\n2019年7月16日：明日回深圳\n2019年8月12日：家中丧事，断了几天。\n2019年8月13日：土巴兔视频模块进度紧张。\n2019年8月14日：昨夜加班。\n2019-8-20 00:04:39 昨天遇到了许多 flutter 的异常，尚未整理。重点关注插件引起的无差别闪退。\n2019-9-13 21:17:49 中秋休息、\n2019-11-02 23:05:11 咳嗽严重，持续一周\n2019-11-04 20:02:05 不见好转。。。\n2019-11-05 23:57:26 今日完成中文简历，收到 bytedance 邀请；project commit 进度比较多。 \n\n2020-02-22 22:25:08 2020的病毒疫情实在严重，并且暴露出很多问题。\n","slug":"timeline","published":0,"date":"2020-03-15T21:05:07.236Z","updated":"2020-03-15T21:05:07.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w1000129fyhu1xgusn","content":"<p>2019 年 6 月 9 日：明日毕业照。<br>2019 年 6 月 10 日：今日毕业照，谈论到公司的技术路线问题。目前土巴兔的移动开发技术已经尝试使用 Flutter，相信近期适合跨平台开发者的发展路线。</p>\n<p>2019 年 6 月 10 日：短期内深圳才是我们应该混的地方。</p>\n<p>2019 年 6 月 11 日：今日完成图书交付，斗鱼开发者提上日程<br>2019 年 6 月 12 日：斗鱼开发者 token 获取异常，似乎需要权限而申请权限选项中并不包含。<br>2019 年 6 月 13 日：重新看回 Dart 编程语言一书。</p>\n<p>2019 年 6 月 15 日：看看 Dart 的异步机制。<br>2019 年 6 月 16 日：Dart 异步和 Isolate 的概念基本理清楚了。<br>2019 年 6 月 18 日：Dart 异步事件机制。<br>2019 年 6 月 21 日：Dart 类型整理。</p>\n<p>2019年6月25日：今日根据 Flickr API 测试 Flutter。</p>\n<p>2019年6月27日：今日根据实现 Flickr API 第二个接口，并改写工具类。</p>\n<p> 2019年6月28日：今日修复工具类的 bug。</p>\n<p>2019年6月29日：今日离校。</p>\n<p>2019年7月11日：肠胃炎休息一周。<br>2019年7月14日：肠胃炎并发发烧延迟入职，接着住院。<br>2019年7月15日：恢复中……<br>2019年7月16日：明日回深圳<br>2019年8月12日：家中丧事，断了几天。<br>2019年8月13日：土巴兔视频模块进度紧张。<br>2019年8月14日：昨夜加班。<br>2019-8-20 00:04:39 昨天遇到了许多 flutter 的异常，尚未整理。重点关注插件引起的无差别闪退。<br>2019-9-13 21:17:49 中秋休息、<br>2019-11-02 23:05:11 咳嗽严重，持续一周<br>2019-11-04 20:02:05 不见好转。。。<br>2019-11-05 23:57:26 今日完成中文简历，收到 bytedance 邀请；project commit 进度比较多。 </p>\n<p>2020-02-22 22:25:08 2020的病毒疫情实在严重，并且暴露出很多问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2019 年 6 月 9 日：明日毕业照。<br>2019 年 6 月 10 日：今日毕业照，谈论到公司的技术路线问题。目前土巴兔的移动开发技术已经尝试使用 Flutter，相信近期适合跨平台开发者的发展路线。</p>\n<p>2019 年 6 月 10 日：短期内深圳才是我们应该混的地方。</p>\n<p>2019 年 6 月 11 日：今日完成图书交付，斗鱼开发者提上日程<br>2019 年 6 月 12 日：斗鱼开发者 token 获取异常，似乎需要权限而申请权限选项中并不包含。<br>2019 年 6 月 13 日：重新看回 Dart 编程语言一书。</p>\n<p>2019 年 6 月 15 日：看看 Dart 的异步机制。<br>2019 年 6 月 16 日：Dart 异步和 Isolate 的概念基本理清楚了。<br>2019 年 6 月 18 日：Dart 异步事件机制。<br>2019 年 6 月 21 日：Dart 类型整理。</p>\n<p>2019年6月25日：今日根据 Flickr API 测试 Flutter。</p>\n<p>2019年6月27日：今日根据实现 Flickr API 第二个接口，并改写工具类。</p>\n<p> 2019年6月28日：今日修复工具类的 bug。</p>\n<p>2019年6月29日：今日离校。</p>\n<p>2019年7月11日：肠胃炎休息一周。<br>2019年7月14日：肠胃炎并发发烧延迟入职，接着住院。<br>2019年7月15日：恢复中……<br>2019年7月16日：明日回深圳<br>2019年8月12日：家中丧事，断了几天。<br>2019年8月13日：土巴兔视频模块进度紧张。<br>2019年8月14日：昨夜加班。<br>2019-8-20 00:04:39 昨天遇到了许多 flutter 的异常，尚未整理。重点关注插件引起的无差别闪退。<br>2019-9-13 21:17:49 中秋休息、<br>2019-11-02 23:05:11 咳嗽严重，持续一周<br>2019-11-04 20:02:05 不见好转。。。<br>2019-11-05 23:57:26 今日完成中文简历，收到 bytedance 邀请；project commit 进度比较多。 </p>\n<p>2020-02-22 22:25:08 2020的病毒疫情实在严重，并且暴露出很多问题。</p>\n"},{"title":"Dart tear-offs","date":"2020-03-12T16:46:44.000Z","_content":"\n### tear-offs\n\ntear-offs 是一种特殊的闭包，允许开发者通过 forEach 迭代向 Function 对象直接传递参数。本质是是闭包语法调用的语法糖，具有显著的可读性。\n\n\n\n<!--more-->\n\n> [此处可以对照 tear-off 与 lambda 的写法差距](https://dart-lang.github.io/linter/lints/unnecessary_lambdas.html)\n\n\n```dart\n/// This is a example of dart tear-offs.\n\n/// a \"tear-offs\" is a closure that takes the same parameters as the method and invokes it when you call it.\n\nList<int> a = [1,2,3,4,5,6];\nMap<int,String> b = new Map()\n  ..[0]= \"0000\"\n  ..[1]= \"1111\"\n  ..[2]= \"2222\"\n  ..[3]= \"3333\";\n\n\nc(int a ,String b){\n  print(a.toString() + \"----\"+ b );\n}\n\n\nvoid main(){\n  a.forEach(print);\n  b.forEach(c);\n  \n}\n```\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/905af578c168a18add7691f6aa65619b)\n\n\n\n\n\n\n\n\n","source":"_posts/Dart tear-offs.md","raw":"---\ntitle: Dart tear-offs\ndate: 2020-03-13 00:46:44\ntags: dart \n---\n\n### tear-offs\n\ntear-offs 是一种特殊的闭包，允许开发者通过 forEach 迭代向 Function 对象直接传递参数。本质是是闭包语法调用的语法糖，具有显著的可读性。\n\n\n\n<!--more-->\n\n> [此处可以对照 tear-off 与 lambda 的写法差距](https://dart-lang.github.io/linter/lints/unnecessary_lambdas.html)\n\n\n```dart\n/// This is a example of dart tear-offs.\n\n/// a \"tear-offs\" is a closure that takes the same parameters as the method and invokes it when you call it.\n\nList<int> a = [1,2,3,4,5,6];\nMap<int,String> b = new Map()\n  ..[0]= \"0000\"\n  ..[1]= \"1111\"\n  ..[2]= \"2222\"\n  ..[3]= \"3333\";\n\n\nc(int a ,String b){\n  print(a.toString() + \"----\"+ b );\n}\n\n\nvoid main(){\n  a.forEach(print);\n  b.forEach(c);\n  \n}\n```\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/905af578c168a18add7691f6aa65619b)\n\n\n\n\n\n\n\n\n","slug":"Dart tear-offs","published":1,"updated":"2020-03-15T21:05:07.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w2000229fyziwwshds","content":"<h3 id=\"tear-offs\"><a href=\"#tear-offs\" class=\"headerlink\" title=\"tear-offs\"></a>tear-offs</h3><p>tear-offs 是一种特殊的闭包，允许开发者通过 forEach 迭代向 Function 对象直接传递参数。本质是是闭包语法调用的语法糖，具有显著的可读性。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p><a href=\"https://dart-lang.github.io/linter/lints/unnecessary_lambdas.html\" target=\"_blank\" rel=\"noopener\">此处可以对照 tear-off 与 lambda 的写法差距</a></p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// This is a example of dart tear-offs.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// a \"tear-offs\" is a closure that takes the same parameters as the method and invokes it when you call it.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>,<span class=\"built_in\">String</span>&gt; b = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  ..[<span class=\"number\">0</span>]= <span class=\"string\">\"0000\"</span></span><br><span class=\"line\">  ..[<span class=\"number\">1</span>]= <span class=\"string\">\"1111\"</span></span><br><span class=\"line\">  ..[<span class=\"number\">2</span>]= <span class=\"string\">\"2222\"</span></span><br><span class=\"line\">  ..[<span class=\"number\">3</span>]= <span class=\"string\">\"3333\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">c(<span class=\"built_in\">int</span> a ,<span class=\"built_in\">String</span> b)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a.toString() + <span class=\"string\">\"----\"</span>+ b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  a.forEach(<span class=\"built_in\">print</span>);</span><br><span class=\"line\">  b.forEach(c);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/905af578c168a18add7691f6aa65619b\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"tear-offs\"><a href=\"#tear-offs\" class=\"headerlink\" title=\"tear-offs\"></a>tear-offs</h3><p>tear-offs 是一种特殊的闭包，允许开发者通过 forEach 迭代向 Function 对象直接传递参数。本质是是闭包语法调用的语法糖，具有显著的可读性。</p>","more":"<blockquote>\n<p><a href=\"https://dart-lang.github.io/linter/lints/unnecessary_lambdas.html\" target=\"_blank\" rel=\"noopener\">此处可以对照 tear-off 与 lambda 的写法差距</a></p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// This is a example of dart tear-offs.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// a \"tear-offs\" is a closure that takes the same parameters as the method and invokes it when you call it.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>,<span class=\"built_in\">String</span>&gt; b = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  ..[<span class=\"number\">0</span>]= <span class=\"string\">\"0000\"</span></span><br><span class=\"line\">  ..[<span class=\"number\">1</span>]= <span class=\"string\">\"1111\"</span></span><br><span class=\"line\">  ..[<span class=\"number\">2</span>]= <span class=\"string\">\"2222\"</span></span><br><span class=\"line\">  ..[<span class=\"number\">3</span>]= <span class=\"string\">\"3333\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">c(<span class=\"built_in\">int</span> a ,<span class=\"built_in\">String</span> b)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a.toString() + <span class=\"string\">\"----\"</span>+ b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  a.forEach(<span class=\"built_in\">print</span>);</span><br><span class=\"line\">  b.forEach(c);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/905af578c168a18add7691f6aa65619b\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>"},{"title":"Dart final & const","date":"2019-06-24T09:28:46.000Z","_content":"\n## final 与 const\n\nfinal 修饰一个编译时常量，final 修饰一个运行时常量。\n\nfinal 变量指的是只能进行初始化而不能进行赋值操作的变量；\nconst 变量指的必须使用编译时常量进行初始化并且不能进行赋值操作的变量（因此 const 变量总是隐式地具有 final 属性）；\n\n<!--more-->\n\n### const 常量\n\n如果在类的内部使用了常量变量应当在 const 之前加上 static 将其设置为静态常量变量。const 变量总是使用编译时常量进行初始化。\n\nconst 变量一旦定义就不可以被修改，尽管这是一个显然的事实，但是一旦 const 与容器结合起来，就容易出现一些违背直觉的情况。\n\n```dart\nconst constList_1 = [1]; // const List variable. \nconst constList_2 = const [2]; // const List variable. |use const redundantly\nvar constList_3 = const [3]; // List variable. | but [3] is is contant.\nconstList_3.add(4); // error\nconstList_3 = [5]; // no error\n```\n\n在上述例子中，const 修饰一个接受 List<int> 的变量，此使变量就被固定，然而为一个变量 constList_3 赋值一个 const 修饰的常数 List<int> 并不会改变 constList 的性质。尽管 const [3] 不能进行任何修改，但是 constList_3  仍然可以被重新赋值。\n\n### final 变量\n\n在之前的笔记中而可以知道，final 变量常见于无需赋值操作的类实例变量。\n\n因此这类变量没有 setter 。其初始化要在构造函数启动之前，因此初始化操作可以在构造函数参数或构造函数的初始化列表中。另一方面，由于延迟初始化的行为，初始化又只在第一使用才进行。\n\n","source":"_posts/Dart-final&const.md","raw":"---\ntitle: Dart final & const\ndate: 2019-06-24 17:28:46\ntags: Dart\n---\n\n## final 与 const\n\nfinal 修饰一个编译时常量，final 修饰一个运行时常量。\n\nfinal 变量指的是只能进行初始化而不能进行赋值操作的变量；\nconst 变量指的必须使用编译时常量进行初始化并且不能进行赋值操作的变量（因此 const 变量总是隐式地具有 final 属性）；\n\n<!--more-->\n\n### const 常量\n\n如果在类的内部使用了常量变量应当在 const 之前加上 static 将其设置为静态常量变量。const 变量总是使用编译时常量进行初始化。\n\nconst 变量一旦定义就不可以被修改，尽管这是一个显然的事实，但是一旦 const 与容器结合起来，就容易出现一些违背直觉的情况。\n\n```dart\nconst constList_1 = [1]; // const List variable. \nconst constList_2 = const [2]; // const List variable. |use const redundantly\nvar constList_3 = const [3]; // List variable. | but [3] is is contant.\nconstList_3.add(4); // error\nconstList_3 = [5]; // no error\n```\n\n在上述例子中，const 修饰一个接受 List<int> 的变量，此使变量就被固定，然而为一个变量 constList_3 赋值一个 const 修饰的常数 List<int> 并不会改变 constList 的性质。尽管 const [3] 不能进行任何修改，但是 constList_3  仍然可以被重新赋值。\n\n### final 变量\n\n在之前的笔记中而可以知道，final 变量常见于无需赋值操作的类实例变量。\n\n因此这类变量没有 setter 。其初始化要在构造函数启动之前，因此初始化操作可以在构造函数参数或构造函数的初始化列表中。另一方面，由于延迟初始化的行为，初始化又只在第一使用才进行。\n\n","slug":"Dart-final&const","published":1,"updated":"2020-03-15T21:05:07.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w3000329fy5q0fxc5s","content":"<h2 id=\"final-与-const\"><a href=\"#final-与-const\" class=\"headerlink\" title=\"final 与 const\"></a>final 与 const</h2><p>final 修饰一个编译时常量，final 修饰一个运行时常量。</p>\n<p>final 变量指的是只能进行初始化而不能进行赋值操作的变量；<br>const 变量指的必须使用编译时常量进行初始化并且不能进行赋值操作的变量（因此 const 变量总是隐式地具有 final 属性）；</p>\n<a id=\"more\"></a>\n\n<h3 id=\"const-常量\"><a href=\"#const-常量\" class=\"headerlink\" title=\"const 常量\"></a>const 常量</h3><p>如果在类的内部使用了常量变量应当在 const 之前加上 static 将其设置为静态常量变量。const 变量总是使用编译时常量进行初始化。</p>\n<p>const 变量一旦定义就不可以被修改，尽管这是一个显然的事实，但是一旦 const 与容器结合起来，就容易出现一些违背直觉的情况。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> constList_1 = [<span class=\"number\">1</span>]; <span class=\"comment\">// const List variable. </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> constList_2 = <span class=\"keyword\">const</span> [<span class=\"number\">2</span>]; <span class=\"comment\">// const List variable. |use const redundantly</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> constList_3 = <span class=\"keyword\">const</span> [<span class=\"number\">3</span>]; <span class=\"comment\">// List variable. | but [3] is is contant.</span></span><br><span class=\"line\">constList_3.add(<span class=\"number\">4</span>); <span class=\"comment\">// error</span></span><br><span class=\"line\">constList_3 = [<span class=\"number\">5</span>]; <span class=\"comment\">// no error</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述例子中，const 修饰一个接受 List<int> 的变量，此使变量就被固定，然而为一个变量 constList_3 赋值一个 const 修饰的常数 List<int> 并不会改变 constList 的性质。尽管 const [3] 不能进行任何修改，但是 constList_3  仍然可以被重新赋值。</int></int></p>\n<h3 id=\"final-变量\"><a href=\"#final-变量\" class=\"headerlink\" title=\"final 变量\"></a>final 变量</h3><p>在之前的笔记中而可以知道，final 变量常见于无需赋值操作的类实例变量。</p>\n<p>因此这类变量没有 setter 。其初始化要在构造函数启动之前，因此初始化操作可以在构造函数参数或构造函数的初始化列表中。另一方面，由于延迟初始化的行为，初始化又只在第一使用才进行。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"final-与-const\"><a href=\"#final-与-const\" class=\"headerlink\" title=\"final 与 const\"></a>final 与 const</h2><p>final 修饰一个编译时常量，final 修饰一个运行时常量。</p>\n<p>final 变量指的是只能进行初始化而不能进行赋值操作的变量；<br>const 变量指的必须使用编译时常量进行初始化并且不能进行赋值操作的变量（因此 const 变量总是隐式地具有 final 属性）；</p>","more":"<h3 id=\"const-常量\"><a href=\"#const-常量\" class=\"headerlink\" title=\"const 常量\"></a>const 常量</h3><p>如果在类的内部使用了常量变量应当在 const 之前加上 static 将其设置为静态常量变量。const 变量总是使用编译时常量进行初始化。</p>\n<p>const 变量一旦定义就不可以被修改，尽管这是一个显然的事实，但是一旦 const 与容器结合起来，就容易出现一些违背直觉的情况。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> constList_1 = [<span class=\"number\">1</span>]; <span class=\"comment\">// const List variable. </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> constList_2 = <span class=\"keyword\">const</span> [<span class=\"number\">2</span>]; <span class=\"comment\">// const List variable. |use const redundantly</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> constList_3 = <span class=\"keyword\">const</span> [<span class=\"number\">3</span>]; <span class=\"comment\">// List variable. | but [3] is is contant.</span></span><br><span class=\"line\">constList_3.add(<span class=\"number\">4</span>); <span class=\"comment\">// error</span></span><br><span class=\"line\">constList_3 = [<span class=\"number\">5</span>]; <span class=\"comment\">// no error</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述例子中，const 修饰一个接受 List<int> 的变量，此使变量就被固定，然而为一个变量 constList_3 赋值一个 const 修饰的常数 List<int> 并不会改变 constList 的性质。尽管 const [3] 不能进行任何修改，但是 constList_3  仍然可以被重新赋值。</int></int></p>\n<h3 id=\"final-变量\"><a href=\"#final-变量\" class=\"headerlink\" title=\"final 变量\"></a>final 变量</h3><p>在之前的笔记中而可以知道，final 变量常见于无需赋值操作的类实例变量。</p>\n<p>因此这类变量没有 setter 。其初始化要在构造函数启动之前，因此初始化操作可以在构造函数参数或构造函数的初始化列表中。另一方面，由于延迟初始化的行为，初始化又只在第一使用才进行。</p>"},{"title":"Dart factory 关键字","date":"2019-05-14T09:28:46.000Z","_content":"\n### factory 关键字\n\n\n官方文档中提到 factory 关键字是用来修饰是构造函数的。\n\n> 在一些特定的场景，类本身需要避免创建过多的实例，可以使用 factory 创建工厂构造函数。 \n\n官方提供了一个 Logger 的工厂构造函数从静态变量 _cache 中返回实例而无需重复创建类的实例。\n\n```dart\nclass Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map<String, Logger> _cache =\n      <String, Logger>{};\n\n  factory Logger(String name) {\n    if (_cache.containsKey(name)) {\n      return _cache[name];\n    } else {\n      final logger = Logger._internal(name);\n      _cache[name] = logger;\n      return logger;\n    }\n  }\n\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n\n```\n\n特别的 factory 需要返回一个对象，并且不允许使用 this 关键字。\n\n\n[在 DartPad 运行此代码]()\n\n\n\n","source":"_posts/Dart-foctory关键字.md","raw":"---\ntitle: Dart factory 关键字\ndate: 2019-05-14 17:28:46\ntags: Dart \n---\n\n### factory 关键字\n\n\n官方文档中提到 factory 关键字是用来修饰是构造函数的。\n\n> 在一些特定的场景，类本身需要避免创建过多的实例，可以使用 factory 创建工厂构造函数。 \n\n官方提供了一个 Logger 的工厂构造函数从静态变量 _cache 中返回实例而无需重复创建类的实例。\n\n```dart\nclass Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map<String, Logger> _cache =\n      <String, Logger>{};\n\n  factory Logger(String name) {\n    if (_cache.containsKey(name)) {\n      return _cache[name];\n    } else {\n      final logger = Logger._internal(name);\n      _cache[name] = logger;\n      return logger;\n    }\n  }\n\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n\n```\n\n特别的 factory 需要返回一个对象，并且不允许使用 this 关键字。\n\n\n[在 DartPad 运行此代码]()\n\n\n\n","slug":"Dart-foctory关键字","published":1,"updated":"2020-03-15T21:05:07.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w4000429fy9gpbb7zk","content":"<h3 id=\"factory-关键字\"><a href=\"#factory-关键字\" class=\"headerlink\" title=\"factory 关键字\"></a>factory 关键字</h3><p>官方文档中提到 factory 关键字是用来修饰是构造函数的。</p>\n<blockquote>\n<p>在一些特定的场景，类本身需要避免创建过多的实例，可以使用 factory 创建工厂构造函数。 </p>\n</blockquote>\n<p>官方提供了一个 Logger 的工厂构造函数从静态变量 _cache 中返回实例而无需重复创建类的实例。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to</span></span><br><span class=\"line\">  <span class=\"comment\">// the _ in front of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mute) <span class=\"built_in\">print</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特别的 factory 需要返回一个对象，并且不允许使用 this 关键字。</p>\n<p><a href>在 DartPad 运行此代码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"factory-关键字\"><a href=\"#factory-关键字\" class=\"headerlink\" title=\"factory 关键字\"></a>factory 关键字</h3><p>官方文档中提到 factory 关键字是用来修饰是构造函数的。</p>\n<blockquote>\n<p>在一些特定的场景，类本身需要避免创建过多的实例，可以使用 factory 创建工厂构造函数。 </p>\n</blockquote>\n<p>官方提供了一个 Logger 的工厂构造函数从静态变量 _cache 中返回实例而无需重复创建类的实例。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to</span></span><br><span class=\"line\">  <span class=\"comment\">// the _ in front of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mute) <span class=\"built_in\">print</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>特别的 factory 需要返回一个对象，并且不允许使用 this 关键字。</p>\n<p><a href>在 DartPad 运行此代码</a></p>\n"},{"title":"Dart 函数","date":"2019-05-17T02:06:46.000Z","_content":"\n### Dart 函数\n\n一个 dart 函数同通常包括函数声明和函数体。\n\n<!--more-->\n\n函数的声明有函数名称和函数的参数列表，规定了函数本身如何被调用；函数体提供了函数的运算主体。特别地，抽象函数不需要提供函数体。\n\n函数体具通常使用大括号包含若干语句，函数体依照次序执行直到 return 语句或抛出异常。除了构造函数以外，函数结束时仍没有提供返回值时，返回值将是 null。\n\n在 Dart 语法中，存在这样的语法糖：当函数只需要一个表达式时，使用箭头操作符（=>）为函数的返回值指定一个表达式作为返回值。\n\n#### 使用匿名函数和闭包（Closure）\n\n函数在一些情况下可以不提供函数名而提供一种简洁的方式来使用，这就是匿名函数。\n一个匿名函数可以是以下的形式。\n\n```dart\n// 这种列表的索引方式很常见\nvoid main() {\n  var list = ['apples', 'bananas', 'oranges'];\n  list.forEach((item) {\n    print('${list.indexOf(item)}: $item');\n  });\n}\n```\n\n匿名函数可以帮助开发者更容易地去创建一个无需手动调用的函数；但更重要的作用是用来实现闭包。\n\n没有学过 JavaScript 的开发者可能会对闭包这一概念比较陌生。闭包具有记录其他作用域的对象的作用。可以看以下的例子，我们还可以利用闭包的一些性质做到一些特殊的操作。\t\n\n```dart\n/// Returns a function that adds prefix to the\n/// function's  String object.\nFunction makePrefix(String prefix) {\n  return (String str) => prefix + str;\n}\n\nvoid main() {\n//   This statement will create a \"pro\" prefix for a String\n  var prefixPro = makePrefix(\"pro\");\n//   This statement will create a \"sub\" prefix for a String\n  var prefixSub = makePrefix(\"sub\");\n  String prefixValue = \"pre\";\n//   This statement will create a prefixValue prefix for a String\n  var prefixPre = makePrefix(prefixValue);\n\n  prefixValue = \"com\";\n\n  print(prefixPro(\"fessional\"));\n  print(prefixSub(\"channel\"));\n  print(prefixPre(\"sentation\"));\n  print(\n      \"The word presentation show that the closure have nothing about date binding. \\nThe closure record the input value as static varible when a closure is definded. \");\n\n//   Another example of closure.\n  final values = [1, 2, 3, 4, 5];\n  print(values);\n  printSumValue(List<int> nums) => nums.reduce((a, b) {\n        print('a = ' +\n            a.toString() +\n            '; b  = ' +\n            b.toString() +\n            '; a + b = ' +\n            (a + b).toString() + ';');\n        return a + b;\n      });\n  printProductValue(nums) => nums.fold(1, (a, b) {\n        print('a = ' +\n            a.toString() +\n            '; b  = ' +\n            b.toString() +\n            '; a * b = ' +\n            (a * b).toString() + ';');\n        return a * b;\n      });\n\n  print(\"The sum is :\" + printSumValue(values).toString());\n  print(\"The product is :\" + printProductValue(values).toString());\n}\n\n```\n\n[在 DartPad 上运行此代码](https://dartpad.dartlang.org/fcdcb0f4a30518e917d893b913634d47)\n以上的例子说明了闭包可以在定义时将其他作用域的变量作为参数捕获，并且不会随着被捕获对象的改变而变化。因此闭包本身不是数据绑定，而是保存了一个变量副本到闭包的私有空间中。\n\n#### 函数的级联语法\n\nDart 的级联语法是函数式程序设计的产物，能对同一对象进行一系列操作。使用级联语句与点操作符的作用是几乎一致的（.），只是每一个表达式的返回值都是对象本身而不再关注每个表达式的返回值。\n\n```\nquerySelector('#confirm') // Get an object.\n  ..text = 'Confirm' // Use its members.\n  ..classes.add('important') // \n  ..onClick.listen((e) => window.alert('Confirmed!'));\n```\n\n#### Function 的静态调用\n\n在 Dart 中，所有的变量和方法都属于 Object 的子类，而所有的函数就属于 Functoin 类。Function 类提供了一个静态方法：\n\n```dart\nexternal static apply(Function function, List positionalArguments,\n    [Map<Symbol, dynamic> namedArguments]);\n```\n\n因此我们可以使用 Function 类的静态方法显式调用函数，在以下的例子中两种调用方式是完全的。\n\n在 Dart 中，只要实现了 call() 方法，就相当于以接口形式实现了 Function 类。\n\n```dart\nclass WannabeFunction {\n  call(String a, String b, String c) => '$a $b $c!';\n}\n\nmain() {\n  var wf = new WannabeFunction();\n  var out = wf(\"Hi\",\"there,\",\"gang\");\n  print('$out'); \n var anotherOut = Function.apply(wf, [\"Hi\",\"there,\",\"gang\"]);\n  print('$anotherOut');\n}\n```\n\n[在 DartPad 上运行此代码](https://dartpad.dartlang.org/27bf2265822a514b5246c400c5a2ac1c)\n\n#### Function 的对象检查\n函数的 runtimeType 检查在于入参和返回值的检查，如果两个函数的入参和返回值类型一致，根据 runtimeType 会判别为相同值；而相等操作符(==)总是检查是否为同一对象。\n\n```dart\nf(x) {return (x)=>x;}\n\ng(){\n  \n  h() => 42;\n  print(\"h.runtimeType : \");\n  print(h.runtimeType);\n  print(h is Function);// true\n  print(h.runtimeType == (()=>42).runtimeType);// true\n  print(g.runtimeType == h.runtimeType);//false\n  print((()=>42).runtimeType == (()=>42).runtimeType); // true\n}\nvoid main(){\n  print(\"f.runtimeType : \");\n  print(f.runtimeType);\n  print(\"g.runtimeType : \");\n  print(g.runtimeType);\n  print(\"f(2).runtimeType\");\n  print(f(2).runtimeType);\n  print(f is Function);//true\n  print(f(3) is Function);// true\n  print(g is Function);//true\n  print(f(2).runtimeType == f.runtimeType);//true or false\n  print(f.runtimeType == g.runtimeType);//false\n  g();\n}\n```\n\n由于函数本身类型地特殊性，闭包在使用之时，常常由于其本身类型的模糊性而难以入手。\n使用以下这一例子能更好地帮助我们去使用闭包。\n\n\n```dart\n@proxy\nclass A {\n  int number;\n  A(this.number);\n}\n\nvar independentClosure = () {};\n\nvoid main() {\n  Function function1 = () {};\n  Function function2 = () {\n    print(function1);\n  };\n  String Function(int, int) function3 = (int a, int b) {\n    print(\"HelloWorld\");\n    return '';\n  };\n  Function function4 = () {};\n  Function function5 = function1;\n  Function function6 = independentClosure;\n\n// The runtimeType of the Function object is differentiated based on input parameters and output parameters.\n  print(\n      \"The runtimeType of the function is differentiated based on input parameters and output parameters.\");\n  print(independentClosure.runtimeType);\n  print(function1.runtimeType);\n  print(function2.runtimeType);\n  print(function3.runtimeType);\n  print(function4.runtimeType);\n  print(function5.runtimeType);\n  print(function6.runtimeType);\n\n// operator == of Function object depends on whether their addresses are the same\n  print(\n      \"operator == of Object object depends on whether their addresses are the same\");\n  print(function1 ==\n      function4); // function1 and function4 are at different addresses.\n  print(\n      function1 == function5); // function1 and function5 are at same addresses.\n  print(independentClosure ==\n      function6); // independentClosure and function5 are still at same addresses even int the different Scope.\n\n// operator == of Object object depends on whether their addresses are the same\n  A a1 = new A(1), a2 = a1;\n  print(a1 == a2);\n  print(a1);\n  print(a2);\n\n//\n  print(function1.hashCode == function4.hashCode);\n  print(function1.toString() == function4.toString());\n\n// String Function(int,int) Limit the input parameters and return type of a closure\n  Function.apply(function3, [1, 2]);\n  try {\n    Function.apply(function3, [1]);\n  } catch (e) {\n    print(e);\n  }\n  try {\n    int a = Function.apply(function3, [1, 2]);\n  } catch (e) {\n    print(e);\n  }\n\n//  toString() of closure Depends on its Scope and the order of declaration instead of initialzation\n  print(independentClosure.toString());\n  print(function1.toString());\n  print(function2.toString());\n  print(function3.toString());\n  print(function4.toString());\n  print(function5.toString());\n  // function5 is not a real object but a pointer or reference which points to function4\n  print(function6.toString());\n  // function6 is not a real object but a pointer or reference which points to independentClosure\n\n  print(function1.runtimeType == function4.runtimeType);\n}\n```\n\n\n\n\n\n\n\n\n","source":"_posts/Dart-函数.md","raw":"---\ntitle: Dart 函数\ndate: 2019-05-17 10:06:46\ntags: Dart\n---\n\n### Dart 函数\n\n一个 dart 函数同通常包括函数声明和函数体。\n\n<!--more-->\n\n函数的声明有函数名称和函数的参数列表，规定了函数本身如何被调用；函数体提供了函数的运算主体。特别地，抽象函数不需要提供函数体。\n\n函数体具通常使用大括号包含若干语句，函数体依照次序执行直到 return 语句或抛出异常。除了构造函数以外，函数结束时仍没有提供返回值时，返回值将是 null。\n\n在 Dart 语法中，存在这样的语法糖：当函数只需要一个表达式时，使用箭头操作符（=>）为函数的返回值指定一个表达式作为返回值。\n\n#### 使用匿名函数和闭包（Closure）\n\n函数在一些情况下可以不提供函数名而提供一种简洁的方式来使用，这就是匿名函数。\n一个匿名函数可以是以下的形式。\n\n```dart\n// 这种列表的索引方式很常见\nvoid main() {\n  var list = ['apples', 'bananas', 'oranges'];\n  list.forEach((item) {\n    print('${list.indexOf(item)}: $item');\n  });\n}\n```\n\n匿名函数可以帮助开发者更容易地去创建一个无需手动调用的函数；但更重要的作用是用来实现闭包。\n\n没有学过 JavaScript 的开发者可能会对闭包这一概念比较陌生。闭包具有记录其他作用域的对象的作用。可以看以下的例子，我们还可以利用闭包的一些性质做到一些特殊的操作。\t\n\n```dart\n/// Returns a function that adds prefix to the\n/// function's  String object.\nFunction makePrefix(String prefix) {\n  return (String str) => prefix + str;\n}\n\nvoid main() {\n//   This statement will create a \"pro\" prefix for a String\n  var prefixPro = makePrefix(\"pro\");\n//   This statement will create a \"sub\" prefix for a String\n  var prefixSub = makePrefix(\"sub\");\n  String prefixValue = \"pre\";\n//   This statement will create a prefixValue prefix for a String\n  var prefixPre = makePrefix(prefixValue);\n\n  prefixValue = \"com\";\n\n  print(prefixPro(\"fessional\"));\n  print(prefixSub(\"channel\"));\n  print(prefixPre(\"sentation\"));\n  print(\n      \"The word presentation show that the closure have nothing about date binding. \\nThe closure record the input value as static varible when a closure is definded. \");\n\n//   Another example of closure.\n  final values = [1, 2, 3, 4, 5];\n  print(values);\n  printSumValue(List<int> nums) => nums.reduce((a, b) {\n        print('a = ' +\n            a.toString() +\n            '; b  = ' +\n            b.toString() +\n            '; a + b = ' +\n            (a + b).toString() + ';');\n        return a + b;\n      });\n  printProductValue(nums) => nums.fold(1, (a, b) {\n        print('a = ' +\n            a.toString() +\n            '; b  = ' +\n            b.toString() +\n            '; a * b = ' +\n            (a * b).toString() + ';');\n        return a * b;\n      });\n\n  print(\"The sum is :\" + printSumValue(values).toString());\n  print(\"The product is :\" + printProductValue(values).toString());\n}\n\n```\n\n[在 DartPad 上运行此代码](https://dartpad.dartlang.org/fcdcb0f4a30518e917d893b913634d47)\n以上的例子说明了闭包可以在定义时将其他作用域的变量作为参数捕获，并且不会随着被捕获对象的改变而变化。因此闭包本身不是数据绑定，而是保存了一个变量副本到闭包的私有空间中。\n\n#### 函数的级联语法\n\nDart 的级联语法是函数式程序设计的产物，能对同一对象进行一系列操作。使用级联语句与点操作符的作用是几乎一致的（.），只是每一个表达式的返回值都是对象本身而不再关注每个表达式的返回值。\n\n```\nquerySelector('#confirm') // Get an object.\n  ..text = 'Confirm' // Use its members.\n  ..classes.add('important') // \n  ..onClick.listen((e) => window.alert('Confirmed!'));\n```\n\n#### Function 的静态调用\n\n在 Dart 中，所有的变量和方法都属于 Object 的子类，而所有的函数就属于 Functoin 类。Function 类提供了一个静态方法：\n\n```dart\nexternal static apply(Function function, List positionalArguments,\n    [Map<Symbol, dynamic> namedArguments]);\n```\n\n因此我们可以使用 Function 类的静态方法显式调用函数，在以下的例子中两种调用方式是完全的。\n\n在 Dart 中，只要实现了 call() 方法，就相当于以接口形式实现了 Function 类。\n\n```dart\nclass WannabeFunction {\n  call(String a, String b, String c) => '$a $b $c!';\n}\n\nmain() {\n  var wf = new WannabeFunction();\n  var out = wf(\"Hi\",\"there,\",\"gang\");\n  print('$out'); \n var anotherOut = Function.apply(wf, [\"Hi\",\"there,\",\"gang\"]);\n  print('$anotherOut');\n}\n```\n\n[在 DartPad 上运行此代码](https://dartpad.dartlang.org/27bf2265822a514b5246c400c5a2ac1c)\n\n#### Function 的对象检查\n函数的 runtimeType 检查在于入参和返回值的检查，如果两个函数的入参和返回值类型一致，根据 runtimeType 会判别为相同值；而相等操作符(==)总是检查是否为同一对象。\n\n```dart\nf(x) {return (x)=>x;}\n\ng(){\n  \n  h() => 42;\n  print(\"h.runtimeType : \");\n  print(h.runtimeType);\n  print(h is Function);// true\n  print(h.runtimeType == (()=>42).runtimeType);// true\n  print(g.runtimeType == h.runtimeType);//false\n  print((()=>42).runtimeType == (()=>42).runtimeType); // true\n}\nvoid main(){\n  print(\"f.runtimeType : \");\n  print(f.runtimeType);\n  print(\"g.runtimeType : \");\n  print(g.runtimeType);\n  print(\"f(2).runtimeType\");\n  print(f(2).runtimeType);\n  print(f is Function);//true\n  print(f(3) is Function);// true\n  print(g is Function);//true\n  print(f(2).runtimeType == f.runtimeType);//true or false\n  print(f.runtimeType == g.runtimeType);//false\n  g();\n}\n```\n\n由于函数本身类型地特殊性，闭包在使用之时，常常由于其本身类型的模糊性而难以入手。\n使用以下这一例子能更好地帮助我们去使用闭包。\n\n\n```dart\n@proxy\nclass A {\n  int number;\n  A(this.number);\n}\n\nvar independentClosure = () {};\n\nvoid main() {\n  Function function1 = () {};\n  Function function2 = () {\n    print(function1);\n  };\n  String Function(int, int) function3 = (int a, int b) {\n    print(\"HelloWorld\");\n    return '';\n  };\n  Function function4 = () {};\n  Function function5 = function1;\n  Function function6 = independentClosure;\n\n// The runtimeType of the Function object is differentiated based on input parameters and output parameters.\n  print(\n      \"The runtimeType of the function is differentiated based on input parameters and output parameters.\");\n  print(independentClosure.runtimeType);\n  print(function1.runtimeType);\n  print(function2.runtimeType);\n  print(function3.runtimeType);\n  print(function4.runtimeType);\n  print(function5.runtimeType);\n  print(function6.runtimeType);\n\n// operator == of Function object depends on whether their addresses are the same\n  print(\n      \"operator == of Object object depends on whether their addresses are the same\");\n  print(function1 ==\n      function4); // function1 and function4 are at different addresses.\n  print(\n      function1 == function5); // function1 and function5 are at same addresses.\n  print(independentClosure ==\n      function6); // independentClosure and function5 are still at same addresses even int the different Scope.\n\n// operator == of Object object depends on whether their addresses are the same\n  A a1 = new A(1), a2 = a1;\n  print(a1 == a2);\n  print(a1);\n  print(a2);\n\n//\n  print(function1.hashCode == function4.hashCode);\n  print(function1.toString() == function4.toString());\n\n// String Function(int,int) Limit the input parameters and return type of a closure\n  Function.apply(function3, [1, 2]);\n  try {\n    Function.apply(function3, [1]);\n  } catch (e) {\n    print(e);\n  }\n  try {\n    int a = Function.apply(function3, [1, 2]);\n  } catch (e) {\n    print(e);\n  }\n\n//  toString() of closure Depends on its Scope and the order of declaration instead of initialzation\n  print(independentClosure.toString());\n  print(function1.toString());\n  print(function2.toString());\n  print(function3.toString());\n  print(function4.toString());\n  print(function5.toString());\n  // function5 is not a real object but a pointer or reference which points to function4\n  print(function6.toString());\n  // function6 is not a real object but a pointer or reference which points to independentClosure\n\n  print(function1.runtimeType == function4.runtimeType);\n}\n```\n\n\n\n\n\n\n\n\n","slug":"Dart-函数","published":1,"updated":"2020-03-15T21:05:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w5000529fy1q62q6c8","content":"<h3 id=\"Dart-函数\"><a href=\"#Dart-函数\" class=\"headerlink\" title=\"Dart 函数\"></a>Dart 函数</h3><p>一个 dart 函数同通常包括函数声明和函数体。</p>\n<a id=\"more\"></a>\n\n<p>函数的声明有函数名称和函数的参数列表，规定了函数本身如何被调用；函数体提供了函数的运算主体。特别地，抽象函数不需要提供函数体。</p>\n<p>函数体具通常使用大括号包含若干语句，函数体依照次序执行直到 return 语句或抛出异常。除了构造函数以外，函数结束时仍没有提供返回值时，返回值将是 null。</p>\n<p>在 Dart 语法中，存在这样的语法糖：当函数只需要一个表达式时，使用箭头操作符（=&gt;）为函数的返回值指定一个表达式作为返回值。</p>\n<h4 id=\"使用匿名函数和闭包（Closure）\"><a href=\"#使用匿名函数和闭包（Closure）\" class=\"headerlink\" title=\"使用匿名函数和闭包（Closure）\"></a>使用匿名函数和闭包（Closure）</h4><p>函数在一些情况下可以不提供函数名而提供一种简洁的方式来使用，这就是匿名函数。<br>一个匿名函数可以是以下的形式。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这种列表的索引方式很常见</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> list = [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'oranges'</span>];</span><br><span class=\"line\">  list.forEach((item) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;list.indexOf(item)&#125;</span>: $item'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数可以帮助开发者更容易地去创建一个无需手动调用的函数；但更重要的作用是用来实现闭包。</p>\n<p>没有学过 JavaScript 的开发者可能会对闭包这一概念比较陌生。闭包具有记录其他作用域的对象的作用。可以看以下的例子，我们还可以利用闭包的一些性质做到一些特殊的操作。    </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Returns a function that adds prefix to the</span></span><br><span class=\"line\"><span class=\"comment\">/// function's  String object.</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makePrefix(<span class=\"built_in\">String</span> prefix) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">String</span> str) =&gt; prefix + str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\"><span class=\"comment\">//   This statement will create a \"pro\" prefix for a String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prefixPro = makePrefix(<span class=\"string\">\"pro\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//   This statement will create a \"sub\" prefix for a String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prefixSub = makePrefix(<span class=\"string\">\"sub\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">String</span> prefixValue = <span class=\"string\">\"pre\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//   This statement will create a prefixValue prefix for a String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prefixPre = makePrefix(prefixValue);</span><br><span class=\"line\"></span><br><span class=\"line\">  prefixValue = <span class=\"string\">\"com\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(prefixPro(<span class=\"string\">\"fessional\"</span>));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(prefixSub(<span class=\"string\">\"channel\"</span>));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(prefixPre(<span class=\"string\">\"sentation\"</span>));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      <span class=\"string\">\"The word presentation show that the closure have nothing about date binding. \\nThe closure record the input value as static varible when a closure is definded. \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   Another example of closure.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(values);</span><br><span class=\"line\">  printSumValue(<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; nums) =&gt; nums.reduce((a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'a = '</span> +</span><br><span class=\"line\">            a.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; b  = '</span> +</span><br><span class=\"line\">            b.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; a + b = '</span> +</span><br><span class=\"line\">            (a + b).toString() + <span class=\"string\">';'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  printProductValue(nums) =&gt; nums.fold(<span class=\"number\">1</span>, (a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'a = '</span> +</span><br><span class=\"line\">            a.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; b  = '</span> +</span><br><span class=\"line\">            b.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; a * b = '</span> +</span><br><span class=\"line\">            (a * b).toString() + <span class=\"string\">';'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"The sum is :\"</span> + printSumValue(values).toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"The product is :\"</span> + printProductValue(values).toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/fcdcb0f4a30518e917d893b913634d47\" target=\"_blank\" rel=\"noopener\">在 DartPad 上运行此代码</a><br>以上的例子说明了闭包可以在定义时将其他作用域的变量作为参数捕获，并且不会随着被捕获对象的改变而变化。因此闭包本身不是数据绑定，而是保存了一个变量副本到闭包的私有空间中。</p>\n<h4 id=\"函数的级联语法\"><a href=\"#函数的级联语法\" class=\"headerlink\" title=\"函数的级联语法\"></a>函数的级联语法</h4><p>Dart 的级联语法是函数式程序设计的产物，能对同一对象进行一系列操作。使用级联语句与点操作符的作用是几乎一致的（.），只是每一个表达式的返回值都是对象本身而不再关注每个表达式的返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">querySelector(&apos;#confirm&apos;) // Get an object.</span><br><span class=\"line\">  ..text = &apos;Confirm&apos; // Use its members.</span><br><span class=\"line\">  ..classes.add(&apos;important&apos;) // </span><br><span class=\"line\">  ..onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Function-的静态调用\"><a href=\"#Function-的静态调用\" class=\"headerlink\" title=\"Function 的静态调用\"></a>Function 的静态调用</h4><p>在 Dart 中，所有的变量和方法都属于 Object 的子类，而所有的函数就属于 Functoin 类。Function 类提供了一个静态方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"keyword\">static</span> apply(<span class=\"built_in\">Function</span> function, <span class=\"built_in\">List</span> positionalArguments,</span><br><span class=\"line\">    [<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, <span class=\"keyword\">dynamic</span>&gt; namedArguments]);</span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以使用 Function 类的静态方法显式调用函数，在以下的例子中两种调用方式是完全的。</p>\n<p>在 Dart 中，只要实现了 call() 方法，就相当于以接口形式实现了 Function 类。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">String</span> a, <span class=\"built_in\">String</span> b, <span class=\"built_in\">String</span> c) =&gt; <span class=\"string\">'$a $b $c!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = wf(<span class=\"string\">\"Hi\"</span>,<span class=\"string\">\"there,\"</span>,<span class=\"string\">\"gang\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'$out'</span>); </span><br><span class=\"line\"> <span class=\"keyword\">var</span> anotherOut = <span class=\"built_in\">Function</span>.apply(wf, [<span class=\"string\">\"Hi\"</span>,<span class=\"string\">\"there,\"</span>,<span class=\"string\">\"gang\"</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'$anotherOut'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/27bf2265822a514b5246c400c5a2ac1c\" target=\"_blank\" rel=\"noopener\">在 DartPad 上运行此代码</a></p>\n<h4 id=\"Function-的对象检查\"><a href=\"#Function-的对象检查\" class=\"headerlink\" title=\"Function 的对象检查\"></a>Function 的对象检查</h4><p>函数的 runtimeType 检查在于入参和返回值的检查，如果两个函数的入参和返回值类型一致，根据 runtimeType 会判别为相同值；而相等操作符(==)总是检查是否为同一对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x) &#123;<span class=\"keyword\">return</span> (x)=&gt;x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">g()&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  h() =&gt; <span class=\"number\">42</span>;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"h.runtimeType : \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(h.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(h <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(h.runtimeType == (()=&gt;<span class=\"number\">42</span>).runtimeType);<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(g.runtimeType == h.runtimeType);<span class=\"comment\">//false</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>((()=&gt;<span class=\"number\">42</span>).runtimeType == (()=&gt;<span class=\"number\">42</span>).runtimeType); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"f.runtimeType : \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"g.runtimeType : \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(g.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"f(2).runtimeType\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f(<span class=\"number\">2</span>).runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f(<span class=\"number\">3</span>) <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(g <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f(<span class=\"number\">2</span>).runtimeType == f.runtimeType);<span class=\"comment\">//true or false</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f.runtimeType == g.runtimeType);<span class=\"comment\">//false</span></span><br><span class=\"line\">  g();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于函数本身类型地特殊性，闭包在使用之时，常常由于其本身类型的模糊性而难以入手。<br>使用以下这一例子能更好地帮助我们去使用闭包。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@proxy</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> number;</span><br><span class=\"line\">  A(<span class=\"keyword\">this</span>.number);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> independentClosure = () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function1 = () &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function2 = () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(function1);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>) function3 = (<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"HelloWorld\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function4 = () &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function5 = function1;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function6 = independentClosure;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The runtimeType of the Function object is differentiated based on input parameters and output parameters.</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      <span class=\"string\">\"The runtimeType of the function is differentiated based on input parameters and output parameters.\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(independentClosure.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function2.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function3.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function4.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function5.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function6.runtimeType);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator == of Function object depends on whether their addresses are the same</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      <span class=\"string\">\"operator == of Object object depends on whether their addresses are the same\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1 ==</span><br><span class=\"line\">      function4); <span class=\"comment\">// function1 and function4 are at different addresses.</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      function1 == function5); <span class=\"comment\">// function1 and function5 are at same addresses.</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(independentClosure ==</span><br><span class=\"line\">      function6); <span class=\"comment\">// independentClosure and function5 are still at same addresses even int the different Scope.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator == of Object object depends on whether their addresses are the same</span></span><br><span class=\"line\">  A a1 = <span class=\"keyword\">new</span> A(<span class=\"number\">1</span>), a2 = a1;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a1 == a2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a1);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.hashCode == function4.hashCode);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.toString() == function4.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String Function(int,int) Limit the input parameters and return type of a closure</span></span><br><span class=\"line\">  <span class=\"built_in\">Function</span>.apply(function3, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.apply(function3, [<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> a = <span class=\"built_in\">Function</span>.apply(function3, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  toString() of closure Depends on its Scope and the order of declaration instead of initialzation</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(independentClosure.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function2.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function3.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function4.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function5.toString());</span><br><span class=\"line\">  <span class=\"comment\">// function5 is not a real object but a pointer or reference which points to function4</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function6.toString());</span><br><span class=\"line\">  <span class=\"comment\">// function6 is not a real object but a pointer or reference which points to independentClosure</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.runtimeType == function4.runtimeType);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"Dart-函数\"><a href=\"#Dart-函数\" class=\"headerlink\" title=\"Dart 函数\"></a>Dart 函数</h3><p>一个 dart 函数同通常包括函数声明和函数体。</p>","more":"<p>函数的声明有函数名称和函数的参数列表，规定了函数本身如何被调用；函数体提供了函数的运算主体。特别地，抽象函数不需要提供函数体。</p>\n<p>函数体具通常使用大括号包含若干语句，函数体依照次序执行直到 return 语句或抛出异常。除了构造函数以外，函数结束时仍没有提供返回值时，返回值将是 null。</p>\n<p>在 Dart 语法中，存在这样的语法糖：当函数只需要一个表达式时，使用箭头操作符（=&gt;）为函数的返回值指定一个表达式作为返回值。</p>\n<h4 id=\"使用匿名函数和闭包（Closure）\"><a href=\"#使用匿名函数和闭包（Closure）\" class=\"headerlink\" title=\"使用匿名函数和闭包（Closure）\"></a>使用匿名函数和闭包（Closure）</h4><p>函数在一些情况下可以不提供函数名而提供一种简洁的方式来使用，这就是匿名函数。<br>一个匿名函数可以是以下的形式。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这种列表的索引方式很常见</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> list = [<span class=\"string\">'apples'</span>, <span class=\"string\">'bananas'</span>, <span class=\"string\">'oranges'</span>];</span><br><span class=\"line\">  list.forEach((item) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$&#123;list.indexOf(item)&#125;</span>: $item'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数可以帮助开发者更容易地去创建一个无需手动调用的函数；但更重要的作用是用来实现闭包。</p>\n<p>没有学过 JavaScript 的开发者可能会对闭包这一概念比较陌生。闭包具有记录其他作用域的对象的作用。可以看以下的例子，我们还可以利用闭包的一些性质做到一些特殊的操作。    </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Returns a function that adds prefix to the</span></span><br><span class=\"line\"><span class=\"comment\">/// function's  String object.</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span> makePrefix(<span class=\"built_in\">String</span> prefix) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">String</span> str) =&gt; prefix + str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\"><span class=\"comment\">//   This statement will create a \"pro\" prefix for a String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prefixPro = makePrefix(<span class=\"string\">\"pro\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//   This statement will create a \"sub\" prefix for a String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prefixSub = makePrefix(<span class=\"string\">\"sub\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">String</span> prefixValue = <span class=\"string\">\"pre\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//   This statement will create a prefixValue prefix for a String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prefixPre = makePrefix(prefixValue);</span><br><span class=\"line\"></span><br><span class=\"line\">  prefixValue = <span class=\"string\">\"com\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(prefixPro(<span class=\"string\">\"fessional\"</span>));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(prefixSub(<span class=\"string\">\"channel\"</span>));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(prefixPre(<span class=\"string\">\"sentation\"</span>));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      <span class=\"string\">\"The word presentation show that the closure have nothing about date binding. \\nThe closure record the input value as static varible when a closure is definded. \"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   Another example of closure.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(values);</span><br><span class=\"line\">  printSumValue(<span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; nums) =&gt; nums.reduce((a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'a = '</span> +</span><br><span class=\"line\">            a.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; b  = '</span> +</span><br><span class=\"line\">            b.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; a + b = '</span> +</span><br><span class=\"line\">            (a + b).toString() + <span class=\"string\">';'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  printProductValue(nums) =&gt; nums.fold(<span class=\"number\">1</span>, (a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'a = '</span> +</span><br><span class=\"line\">            a.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; b  = '</span> +</span><br><span class=\"line\">            b.toString() +</span><br><span class=\"line\">            <span class=\"string\">'; a * b = '</span> +</span><br><span class=\"line\">            (a * b).toString() + <span class=\"string\">';'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"The sum is :\"</span> + printSumValue(values).toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"The product is :\"</span> + printProductValue(values).toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/fcdcb0f4a30518e917d893b913634d47\" target=\"_blank\" rel=\"noopener\">在 DartPad 上运行此代码</a><br>以上的例子说明了闭包可以在定义时将其他作用域的变量作为参数捕获，并且不会随着被捕获对象的改变而变化。因此闭包本身不是数据绑定，而是保存了一个变量副本到闭包的私有空间中。</p>\n<h4 id=\"函数的级联语法\"><a href=\"#函数的级联语法\" class=\"headerlink\" title=\"函数的级联语法\"></a>函数的级联语法</h4><p>Dart 的级联语法是函数式程序设计的产物，能对同一对象进行一系列操作。使用级联语句与点操作符的作用是几乎一致的（.），只是每一个表达式的返回值都是对象本身而不再关注每个表达式的返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">querySelector(&apos;#confirm&apos;) // Get an object.</span><br><span class=\"line\">  ..text = &apos;Confirm&apos; // Use its members.</span><br><span class=\"line\">  ..classes.add(&apos;important&apos;) // </span><br><span class=\"line\">  ..onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Function-的静态调用\"><a href=\"#Function-的静态调用\" class=\"headerlink\" title=\"Function 的静态调用\"></a>Function 的静态调用</h4><p>在 Dart 中，所有的变量和方法都属于 Object 的子类，而所有的函数就属于 Functoin 类。Function 类提供了一个静态方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"keyword\">static</span> apply(<span class=\"built_in\">Function</span> function, <span class=\"built_in\">List</span> positionalArguments,</span><br><span class=\"line\">    [<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, <span class=\"keyword\">dynamic</span>&gt; namedArguments]);</span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以使用 Function 类的静态方法显式调用函数，在以下的例子中两种调用方式是完全的。</p>\n<p>在 Dart 中，只要实现了 call() 方法，就相当于以接口形式实现了 Function 类。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">String</span> a, <span class=\"built_in\">String</span> b, <span class=\"built_in\">String</span> c) =&gt; <span class=\"string\">'$a $b $c!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = wf(<span class=\"string\">\"Hi\"</span>,<span class=\"string\">\"there,\"</span>,<span class=\"string\">\"gang\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'$out'</span>); </span><br><span class=\"line\"> <span class=\"keyword\">var</span> anotherOut = <span class=\"built_in\">Function</span>.apply(wf, [<span class=\"string\">\"Hi\"</span>,<span class=\"string\">\"there,\"</span>,<span class=\"string\">\"gang\"</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'$anotherOut'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/27bf2265822a514b5246c400c5a2ac1c\" target=\"_blank\" rel=\"noopener\">在 DartPad 上运行此代码</a></p>\n<h4 id=\"Function-的对象检查\"><a href=\"#Function-的对象检查\" class=\"headerlink\" title=\"Function 的对象检查\"></a>Function 的对象检查</h4><p>函数的 runtimeType 检查在于入参和返回值的检查，如果两个函数的入参和返回值类型一致，根据 runtimeType 会判别为相同值；而相等操作符(==)总是检查是否为同一对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x) &#123;<span class=\"keyword\">return</span> (x)=&gt;x;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">g()&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  h() =&gt; <span class=\"number\">42</span>;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"h.runtimeType : \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(h.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(h <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(h.runtimeType == (()=&gt;<span class=\"number\">42</span>).runtimeType);<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(g.runtimeType == h.runtimeType);<span class=\"comment\">//false</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>((()=&gt;<span class=\"number\">42</span>).runtimeType == (()=&gt;<span class=\"number\">42</span>).runtimeType); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"f.runtimeType : \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"g.runtimeType : \"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(g.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"f(2).runtimeType\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f(<span class=\"number\">2</span>).runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f(<span class=\"number\">3</span>) <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(g <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);<span class=\"comment\">//true</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f(<span class=\"number\">2</span>).runtimeType == f.runtimeType);<span class=\"comment\">//true or false</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(f.runtimeType == g.runtimeType);<span class=\"comment\">//false</span></span><br><span class=\"line\">  g();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于函数本身类型地特殊性，闭包在使用之时，常常由于其本身类型的模糊性而难以入手。<br>使用以下这一例子能更好地帮助我们去使用闭包。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@proxy</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> number;</span><br><span class=\"line\">  A(<span class=\"keyword\">this</span>.number);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> independentClosure = () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function1 = () &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function2 = () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(function1);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">int</span>, <span class=\"built_in\">int</span>) function3 = (<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"HelloWorld\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">''</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function4 = () &#123;&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function5 = function1;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> function6 = independentClosure;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The runtimeType of the Function object is differentiated based on input parameters and output parameters.</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      <span class=\"string\">\"The runtimeType of the function is differentiated based on input parameters and output parameters.\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(independentClosure.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function2.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function3.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function4.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function5.runtimeType);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function6.runtimeType);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator == of Function object depends on whether their addresses are the same</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      <span class=\"string\">\"operator == of Object object depends on whether their addresses are the same\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1 ==</span><br><span class=\"line\">      function4); <span class=\"comment\">// function1 and function4 are at different addresses.</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(</span><br><span class=\"line\">      function1 == function5); <span class=\"comment\">// function1 and function5 are at same addresses.</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(independentClosure ==</span><br><span class=\"line\">      function6); <span class=\"comment\">// independentClosure and function5 are still at same addresses even int the different Scope.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator == of Object object depends on whether their addresses are the same</span></span><br><span class=\"line\">  A a1 = <span class=\"keyword\">new</span> A(<span class=\"number\">1</span>), a2 = a1;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a1 == a2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a1);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.hashCode == function4.hashCode);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.toString() == function4.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String Function(int,int) Limit the input parameters and return type of a closure</span></span><br><span class=\"line\">  <span class=\"built_in\">Function</span>.apply(function3, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Function</span>.apply(function3, [<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> a = <span class=\"built_in\">Function</span>.apply(function3, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  toString() of closure Depends on its Scope and the order of declaration instead of initialzation</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(independentClosure.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function2.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function3.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function4.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function5.toString());</span><br><span class=\"line\">  <span class=\"comment\">// function5 is not a real object but a pointer or reference which points to function4</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function6.toString());</span><br><span class=\"line\">  <span class=\"comment\">// function6 is not a real object but a pointer or reference which points to independentClosure</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(function1.runtimeType == function4.runtimeType);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dart-Lazy-Initialization","date":"2019-05-09T20:28:48.000Z","_content":"\n### Dart 语言中类变量的延迟初始化\n\n> 类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。\n\n```dart\n  // 类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。\n  // Class variables are initialized lazily; the initializer of a class variable is executed the first time its getter is invoked—that is, the first time one attempts to read the variable.\n\n  class Animal {\n    Animal() {\n      print(\"Start Lazy Initialization\");\n    }\n  }\n  Animal animal = new Animal();\n\n  void main() {\n  //   animal; // This statement will call the initializer;\n    print(\"Before Initialization\");\n    animal;\n    print(\"After Initialization\");\n  }\n\n```\n\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/eab8a6fdc4b5f34008fa5d07f20f3f28)\n\n","source":"_posts/Dart-初始化延迟.md","raw":"---\ntitle: Dart-Lazy-Initialization\ndate: 2019-05-10 04:28:48\ntags: Dart\n---\n\n### Dart 语言中类变量的延迟初始化\n\n> 类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。\n\n```dart\n  // 类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。\n  // Class variables are initialized lazily; the initializer of a class variable is executed the first time its getter is invoked—that is, the first time one attempts to read the variable.\n\n  class Animal {\n    Animal() {\n      print(\"Start Lazy Initialization\");\n    }\n  }\n  Animal animal = new Animal();\n\n  void main() {\n  //   animal; // This statement will call the initializer;\n    print(\"Before Initialization\");\n    animal;\n    print(\"After Initialization\");\n  }\n\n```\n\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/eab8a6fdc4b5f34008fa5d07f20f3f28)\n\n","slug":"Dart-初始化延迟","published":1,"updated":"2020-03-15T21:05:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w5000629fyd5owt4oj","content":"<h3 id=\"Dart-语言中类变量的延迟初始化\"><a href=\"#Dart-语言中类变量的延迟初始化\" class=\"headerlink\" title=\"Dart 语言中类变量的延迟初始化\"></a>Dart 语言中类变量的延迟初始化</h3><blockquote>\n<p>类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。</span></span><br><span class=\"line\"><span class=\"comment\">// Class variables are initialized lazily; the initializer of a class variable is executed the first time its getter is invoked—that is, the first time one attempts to read the variable.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  Animal() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Start Lazy Initialization\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\"><span class=\"comment\">//   animal; // This statement will call the initializer;</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Before Initialization\"</span>);</span><br><span class=\"line\">  animal;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"After Initialization\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/eab8a6fdc4b5f34008fa5d07f20f3f28\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Dart-语言中类变量的延迟初始化\"><a href=\"#Dart-语言中类变量的延迟初始化\" class=\"headerlink\" title=\"Dart 语言中类变量的延迟初始化\"></a>Dart 语言中类变量的延迟初始化</h3><blockquote>\n<p>类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类变量存在延迟初始化行为，只有第一次调用时，类变量才执行初始化，即第一次尝试读取它时。</span></span><br><span class=\"line\"><span class=\"comment\">// Class variables are initialized lazily; the initializer of a class variable is executed the first time its getter is invoked—that is, the first time one attempts to read the variable.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  Animal() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Start Lazy Initialization\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal animal = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\"><span class=\"comment\">//   animal; // This statement will call the initializer;</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Before Initialization\"</span>);</span><br><span class=\"line\">  animal;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"After Initialization\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/eab8a6fdc4b5f34008fa5d07f20f3f28\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n"},{"title":"Dart 函数参数","date":"2019-05-15T17:27:35.000Z","_content":"\n\n\n### Dart 函数参数\n\n为了更好的了解 Dart 的函数参数传递，不妨从 Functoin 类的静态方法入手。\n\n```dart\nexternal static apply(Function function, List positionalArguments,\n    [Map<Symbol, dynamic> namedArguments]);\n```\n\n> Dynamically call function with the specified arguments.\n> Acts the same as calling function with positional arguments corresponding to the elements of [positionalArguments] and named arguments corresponding to the elements of [namedArguments].\n>\n> --<https://api.dartlang.org/stable/2.3.0/dart-core/Function/apply.html>\n\n该方法是 Function 类提供的静态调用方法，可以直接以特定的参数直接调用一个函数。\n\n<!--more-->\n\n从这个函数可以知道：Dart 函数的传入参数分为位置参数和命名参数。其中，位置参数以 List 传入，根据参数的列表索引作为参数索引；而命名参数则以 Map<Symbol, dynamic> 传入，以键值对的方式作为参数索引。\n\n\n#### 位置参数\n\n使用位置参数的函数与其他编程语言的函数没什么不同，将函数需要使用的参数依照函数原型规定的次序对应地传入即可调用函数，称之为位置参数是因为其具有根据参数位置次序进行参数索引的性质。\n\n位置参数可以是可选的，并且可以为其指定默认值。可选的位置参数必须位于函数原型的末尾并且以中括号([])进行包含。\n\n```dart\nnum add(int origin, [int value = 1]) => return origin +value; \n```\n\n#### 命名参数\n\n命名参数使用了（Symbol, dynamic）键值对的方式进行函数的参数索引。命名参数也应当位于函数原型的末尾并且以大括号({})即进行包含。一旦使用了命名参数，就不允许使用可选的位置参数。\n\n> 尽管我们之前没有提到命名参数的使用，但在 Flutter 控件的构造函数中很常见。\n\n命名参数的传入也可以是必选或可选的，默认情况下，所有的命名参数都是可选的。\n\n- 开发者应当为每一个可选的命名参数提供默认值，如果没有默认值，参数的的传入之将是 null。\n- 如果开发者需要指定部分的命名参数为必须传入，那么可以使用 (@required) 注解，告知使用者参数其不可缺失的性质；\n\n```dart \nconst Text(\n  this.data, {\n  Key key,\n  this.style,\n  this.strutStyle,\n  this.textAlign,\n  this.textDirection,\n  this.locale,\n  this.softWrap,\n  this.overflow,\n  this.textScaleFactor,\n  this.maxLines,\n  this.semanticsLabel,\n}) : assert(\n       data != null,\n       'A non-null String must be provided to a Text widget.',\n     ),\n     textSpan = null,\n     super(key: key);\n```\n上述例子是 Flutter 的 Text 控件的构造函数，在上述例子中，函数提供了参数空值检查并调用了父类的构造函数。","source":"_posts/Dart-函数参数.md","raw":"---\ntitle: Dart 函数参数\ndate: 2019-05-16 01:27:35\ntags: Dart\n---\n\n\n\n### Dart 函数参数\n\n为了更好的了解 Dart 的函数参数传递，不妨从 Functoin 类的静态方法入手。\n\n```dart\nexternal static apply(Function function, List positionalArguments,\n    [Map<Symbol, dynamic> namedArguments]);\n```\n\n> Dynamically call function with the specified arguments.\n> Acts the same as calling function with positional arguments corresponding to the elements of [positionalArguments] and named arguments corresponding to the elements of [namedArguments].\n>\n> --<https://api.dartlang.org/stable/2.3.0/dart-core/Function/apply.html>\n\n该方法是 Function 类提供的静态调用方法，可以直接以特定的参数直接调用一个函数。\n\n<!--more-->\n\n从这个函数可以知道：Dart 函数的传入参数分为位置参数和命名参数。其中，位置参数以 List 传入，根据参数的列表索引作为参数索引；而命名参数则以 Map<Symbol, dynamic> 传入，以键值对的方式作为参数索引。\n\n\n#### 位置参数\n\n使用位置参数的函数与其他编程语言的函数没什么不同，将函数需要使用的参数依照函数原型规定的次序对应地传入即可调用函数，称之为位置参数是因为其具有根据参数位置次序进行参数索引的性质。\n\n位置参数可以是可选的，并且可以为其指定默认值。可选的位置参数必须位于函数原型的末尾并且以中括号([])进行包含。\n\n```dart\nnum add(int origin, [int value = 1]) => return origin +value; \n```\n\n#### 命名参数\n\n命名参数使用了（Symbol, dynamic）键值对的方式进行函数的参数索引。命名参数也应当位于函数原型的末尾并且以大括号({})即进行包含。一旦使用了命名参数，就不允许使用可选的位置参数。\n\n> 尽管我们之前没有提到命名参数的使用，但在 Flutter 控件的构造函数中很常见。\n\n命名参数的传入也可以是必选或可选的，默认情况下，所有的命名参数都是可选的。\n\n- 开发者应当为每一个可选的命名参数提供默认值，如果没有默认值，参数的的传入之将是 null。\n- 如果开发者需要指定部分的命名参数为必须传入，那么可以使用 (@required) 注解，告知使用者参数其不可缺失的性质；\n\n```dart \nconst Text(\n  this.data, {\n  Key key,\n  this.style,\n  this.strutStyle,\n  this.textAlign,\n  this.textDirection,\n  this.locale,\n  this.softWrap,\n  this.overflow,\n  this.textScaleFactor,\n  this.maxLines,\n  this.semanticsLabel,\n}) : assert(\n       data != null,\n       'A non-null String must be provided to a Text widget.',\n     ),\n     textSpan = null,\n     super(key: key);\n```\n上述例子是 Flutter 的 Text 控件的构造函数，在上述例子中，函数提供了参数空值检查并调用了父类的构造函数。","slug":"Dart-函数参数","published":1,"updated":"2020-03-15T21:05:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w6000729fy5lk1ztp5","content":"<h3 id=\"Dart-函数参数\"><a href=\"#Dart-函数参数\" class=\"headerlink\" title=\"Dart 函数参数\"></a>Dart 函数参数</h3><p>为了更好的了解 Dart 的函数参数传递，不妨从 Functoin 类的静态方法入手。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"keyword\">static</span> apply(<span class=\"built_in\">Function</span> function, <span class=\"built_in\">List</span> positionalArguments,</span><br><span class=\"line\">    [<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, <span class=\"keyword\">dynamic</span>&gt; namedArguments]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Dynamically call function with the specified arguments.<br>Acts the same as calling function with positional arguments corresponding to the elements of [positionalArguments] and named arguments corresponding to the elements of [namedArguments].</p>\n<p>–<a href=\"https://api.dartlang.org/stable/2.3.0/dart-core/Function/apply.html\" target=\"_blank\" rel=\"noopener\">https://api.dartlang.org/stable/2.3.0/dart-core/Function/apply.html</a></p>\n</blockquote>\n<p>该方法是 Function 类提供的静态调用方法，可以直接以特定的参数直接调用一个函数。</p>\n<a id=\"more\"></a>\n\n<p>从这个函数可以知道：Dart 函数的传入参数分为位置参数和命名参数。其中，位置参数以 List 传入，根据参数的列表索引作为参数索引；而命名参数则以 Map&lt;Symbol, dynamic&gt; 传入，以键值对的方式作为参数索引。</p>\n<h4 id=\"位置参数\"><a href=\"#位置参数\" class=\"headerlink\" title=\"位置参数\"></a>位置参数</h4><p>使用位置参数的函数与其他编程语言的函数没什么不同，将函数需要使用的参数依照函数原型规定的次序对应地传入即可调用函数，称之为位置参数是因为其具有根据参数位置次序进行参数索引的性质。</p>\n<p>位置参数可以是可选的，并且可以为其指定默认值。可选的位置参数必须位于函数原型的末尾并且以中括号([])进行包含。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">num</span> add(<span class=\"built_in\">int</span> origin, [<span class=\"built_in\">int</span> value = <span class=\"number\">1</span>]) =&gt; <span class=\"keyword\">return</span> origin +value;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"命名参数\"><a href=\"#命名参数\" class=\"headerlink\" title=\"命名参数\"></a>命名参数</h4><p>命名参数使用了（Symbol, dynamic）键值对的方式进行函数的参数索引。命名参数也应当位于函数原型的末尾并且以大括号({})即进行包含。一旦使用了命名参数，就不允许使用可选的位置参数。</p>\n<blockquote>\n<p>尽管我们之前没有提到命名参数的使用，但在 Flutter 控件的构造函数中很常见。</p>\n</blockquote>\n<p>命名参数的传入也可以是必选或可选的，默认情况下，所有的命名参数都是可选的。</p>\n<ul>\n<li>开发者应当为每一个可选的命名参数提供默认值，如果没有默认值，参数的的传入之将是 null。</li>\n<li>如果开发者需要指定部分的命名参数为必须传入，那么可以使用 (@required) 注解，告知使用者参数其不可缺失的性质；</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text(</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.style,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.strutStyle,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textAlign,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.locale,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.softWrap,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.overflow,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textScaleFactor,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.maxLines,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.semanticsLabel,</span><br><span class=\"line\">&#125;) : <span class=\"keyword\">assert</span>(</span><br><span class=\"line\">       data != <span class=\"keyword\">null</span>,</span><br><span class=\"line\">       <span class=\"string\">'A non-null String must be provided to a Text widget.'</span>,</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     textSpan = <span class=\"keyword\">null</span>,</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(key: key);</span><br></pre></td></tr></table></figure>\n\n<p>上述例子是 Flutter 的 Text 控件的构造函数，在上述例子中，函数提供了参数空值检查并调用了父类的构造函数。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Dart-函数参数\"><a href=\"#Dart-函数参数\" class=\"headerlink\" title=\"Dart 函数参数\"></a>Dart 函数参数</h3><p>为了更好的了解 Dart 的函数参数传递，不妨从 Functoin 类的静态方法入手。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">external</span> <span class=\"keyword\">static</span> apply(<span class=\"built_in\">Function</span> function, <span class=\"built_in\">List</span> positionalArguments,</span><br><span class=\"line\">    [<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">Symbol</span>, <span class=\"keyword\">dynamic</span>&gt; namedArguments]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Dynamically call function with the specified arguments.<br>Acts the same as calling function with positional arguments corresponding to the elements of [positionalArguments] and named arguments corresponding to the elements of [namedArguments].</p>\n<p>–<a href=\"https://api.dartlang.org/stable/2.3.0/dart-core/Function/apply.html\" target=\"_blank\" rel=\"noopener\">https://api.dartlang.org/stable/2.3.0/dart-core/Function/apply.html</a></p>\n</blockquote>\n<p>该方法是 Function 类提供的静态调用方法，可以直接以特定的参数直接调用一个函数。</p>","more":"<p>从这个函数可以知道：Dart 函数的传入参数分为位置参数和命名参数。其中，位置参数以 List 传入，根据参数的列表索引作为参数索引；而命名参数则以 Map&lt;Symbol, dynamic&gt; 传入，以键值对的方式作为参数索引。</p>\n<h4 id=\"位置参数\"><a href=\"#位置参数\" class=\"headerlink\" title=\"位置参数\"></a>位置参数</h4><p>使用位置参数的函数与其他编程语言的函数没什么不同，将函数需要使用的参数依照函数原型规定的次序对应地传入即可调用函数，称之为位置参数是因为其具有根据参数位置次序进行参数索引的性质。</p>\n<p>位置参数可以是可选的，并且可以为其指定默认值。可选的位置参数必须位于函数原型的末尾并且以中括号([])进行包含。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">num</span> add(<span class=\"built_in\">int</span> origin, [<span class=\"built_in\">int</span> value = <span class=\"number\">1</span>]) =&gt; <span class=\"keyword\">return</span> origin +value;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"命名参数\"><a href=\"#命名参数\" class=\"headerlink\" title=\"命名参数\"></a>命名参数</h4><p>命名参数使用了（Symbol, dynamic）键值对的方式进行函数的参数索引。命名参数也应当位于函数原型的末尾并且以大括号({})即进行包含。一旦使用了命名参数，就不允许使用可选的位置参数。</p>\n<blockquote>\n<p>尽管我们之前没有提到命名参数的使用，但在 Flutter 控件的构造函数中很常见。</p>\n</blockquote>\n<p>命名参数的传入也可以是必选或可选的，默认情况下，所有的命名参数都是可选的。</p>\n<ul>\n<li>开发者应当为每一个可选的命名参数提供默认值，如果没有默认值，参数的的传入之将是 null。</li>\n<li>如果开发者需要指定部分的命名参数为必须传入，那么可以使用 (@required) 注解，告知使用者参数其不可缺失的性质；</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text(</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.style,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.strutStyle,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textAlign,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.locale,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.softWrap,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.overflow,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textScaleFactor,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.maxLines,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.semanticsLabel,</span><br><span class=\"line\">&#125;) : <span class=\"keyword\">assert</span>(</span><br><span class=\"line\">       data != <span class=\"keyword\">null</span>,</span><br><span class=\"line\">       <span class=\"string\">'A non-null String must be provided to a Text widget.'</span>,</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     textSpan = <span class=\"keyword\">null</span>,</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(key: key);</span><br></pre></td></tr></table></figure>\n\n<p>上述例子是 Flutter 的 Text 控件的构造函数，在上述例子中，函数提供了参数空值检查并调用了父类的构造函数。</p>"},{"title":"Dart-命名构造函数","date":"2019-05-14T09:28:46.000Z","_content":"\n### Dart 命名构造函数\n\n> 构造函数既可以与是默认构造函数（函数名与类名同名，最多存在一个），也可以是命名构造函数（函数名以类名.标志符出现）。\n> 在 Dart 开发者本身没有显示提供构造函数时，编译器会自动创建一个无参数的构造函数。需要更多构造函数时就需要命名构造函数来进行实现。\n\n<!--more-->\n\n```dart\n// Dart developer can user named constructors to create more than one constructors.\nclass Person {\n  int age;\n  String name;\n//   This is a default constructor. If devloper don't provide, it will produce one with do nothing.\n  Person(this.age, this.name);\n//   Thie is a named constructor. \n  Person.clonePerson(Person person) {\n    this.age = person.age;\n    this.name = person.name;\n  }\n  void selfIntrduction() => print(\"I'm $name. I'm $age years old\");\n}\n\nvoid main() {\n  Person personBob = new Person(17, 'Bob');\n  Person anotherBob = new Person.clonePerson(personBob);\n  anotherBob.selfIntrduction();\n}\n\n```\n[在 DartPad 运行此代码]()\n\n> 事实上 Person.clonePerson() 的作用相当于复制构造函数。这个方法创造并返回了一个 personBob 的副本。我们可以来看一下以下这个有趣的栗子🌰\n\n```dart\nclass Person {\n  int age;\n  String name;\n  Person(this.age, this.name);\n\n  Person.clonePerson(Person person) {\n    this.age = person.age;\n    this.name = person.name;\n  }\n  \n  void selfIntrduction() => print(\"I'm $name. I'm $age years old\");\n}\n\nvoid main() {\n  Person personBob = new Person(17, 'Bob'); \n//   shadowOfBob is not real Person because it just point to personBob.\n  Person shadowOfBob = personBob;\n//   anotherBob is an real Person and his change will not have any effect on personBob.\n  Person anotherBob = new Person.clonePerson(personBob);\n\tpersonBob.selfIntrduction();\n  shadowOfBob.age++;\n  print(\"shadowOfBob.age add 1;\");\n  personBob.selfIntrduction();\n  print(\"personBob have been accessed by shadowOfBob. = operator can not create an object. \");\n  anotherBob.age++;\n  print(\"anotherBob.age add 1\");\n  personBob.selfIntrduction();\n}\n\n```\n以上程序提供了一个复制构造函数的实现，由于 = 操作符创建的是对象的引用，本身不具备创建对象的功能并且无法被重载。因此一旦对象本身需要创建大量的副本，开发者就需要显式地提供复制构造函数。","source":"_posts/Dart-命名构造函数.md","raw":"---\ntitle: Dart-命名构造函数\ndate: 2019-05-14 17:28:46\ntags: Dart\n---\n\n### Dart 命名构造函数\n\n> 构造函数既可以与是默认构造函数（函数名与类名同名，最多存在一个），也可以是命名构造函数（函数名以类名.标志符出现）。\n> 在 Dart 开发者本身没有显示提供构造函数时，编译器会自动创建一个无参数的构造函数。需要更多构造函数时就需要命名构造函数来进行实现。\n\n<!--more-->\n\n```dart\n// Dart developer can user named constructors to create more than one constructors.\nclass Person {\n  int age;\n  String name;\n//   This is a default constructor. If devloper don't provide, it will produce one with do nothing.\n  Person(this.age, this.name);\n//   Thie is a named constructor. \n  Person.clonePerson(Person person) {\n    this.age = person.age;\n    this.name = person.name;\n  }\n  void selfIntrduction() => print(\"I'm $name. I'm $age years old\");\n}\n\nvoid main() {\n  Person personBob = new Person(17, 'Bob');\n  Person anotherBob = new Person.clonePerson(personBob);\n  anotherBob.selfIntrduction();\n}\n\n```\n[在 DartPad 运行此代码]()\n\n> 事实上 Person.clonePerson() 的作用相当于复制构造函数。这个方法创造并返回了一个 personBob 的副本。我们可以来看一下以下这个有趣的栗子🌰\n\n```dart\nclass Person {\n  int age;\n  String name;\n  Person(this.age, this.name);\n\n  Person.clonePerson(Person person) {\n    this.age = person.age;\n    this.name = person.name;\n  }\n  \n  void selfIntrduction() => print(\"I'm $name. I'm $age years old\");\n}\n\nvoid main() {\n  Person personBob = new Person(17, 'Bob'); \n//   shadowOfBob is not real Person because it just point to personBob.\n  Person shadowOfBob = personBob;\n//   anotherBob is an real Person and his change will not have any effect on personBob.\n  Person anotherBob = new Person.clonePerson(personBob);\n\tpersonBob.selfIntrduction();\n  shadowOfBob.age++;\n  print(\"shadowOfBob.age add 1;\");\n  personBob.selfIntrduction();\n  print(\"personBob have been accessed by shadowOfBob. = operator can not create an object. \");\n  anotherBob.age++;\n  print(\"anotherBob.age add 1\");\n  personBob.selfIntrduction();\n}\n\n```\n以上程序提供了一个复制构造函数的实现，由于 = 操作符创建的是对象的引用，本身不具备创建对象的功能并且无法被重载。因此一旦对象本身需要创建大量的副本，开发者就需要显式地提供复制构造函数。","slug":"Dart-命名构造函数","published":1,"updated":"2020-03-15T21:05:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w7000829fyrvu2zm5k","content":"<h3 id=\"Dart-命名构造函数\"><a href=\"#Dart-命名构造函数\" class=\"headerlink\" title=\"Dart 命名构造函数\"></a>Dart 命名构造函数</h3><blockquote>\n<p>构造函数既可以与是默认构造函数（函数名与类名同名，最多存在一个），也可以是命名构造函数（函数名以类名.标志符出现）。<br>在 Dart 开发者本身没有显示提供构造函数时，编译器会自动创建一个无参数的构造函数。需要更多构造函数时就需要命名构造函数来进行实现。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dart developer can user named constructors to create more than one constructors.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"><span class=\"comment\">//   This is a default constructor. If devloper don't provide, it will produce one with do nothing.</span></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>.age, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"><span class=\"comment\">//   Thie is a named constructor. </span></span><br><span class=\"line\">  Person.clonePerson(Person person) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = person.age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = person.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> selfIntrduction() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"I'm $name. I'm $age years old\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  Person personBob = <span class=\"keyword\">new</span> Person(<span class=\"number\">17</span>, <span class=\"string\">'Bob'</span>);</span><br><span class=\"line\">  Person anotherBob = <span class=\"keyword\">new</span> Person.clonePerson(personBob);</span><br><span class=\"line\">  anotherBob.selfIntrduction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href>在 DartPad 运行此代码</a></p>\n<blockquote>\n<p>事实上 Person.clonePerson() 的作用相当于复制构造函数。这个方法创造并返回了一个 personBob 的副本。我们可以来看一下以下这个有趣的栗子🌰</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>.age, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.clonePerson(Person person) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = person.age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = person.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">void</span> selfIntrduction() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"I'm $name. I'm $age years old\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  Person personBob = <span class=\"keyword\">new</span> Person(<span class=\"number\">17</span>, <span class=\"string\">'Bob'</span>); </span><br><span class=\"line\"><span class=\"comment\">//   shadowOfBob is not real Person because it just point to personBob.</span></span><br><span class=\"line\">  Person shadowOfBob = personBob;</span><br><span class=\"line\"><span class=\"comment\">//   anotherBob is an real Person and his change will not have any effect on personBob.</span></span><br><span class=\"line\">  Person anotherBob = <span class=\"keyword\">new</span> Person.clonePerson(personBob);</span><br><span class=\"line\">\tpersonBob.selfIntrduction();</span><br><span class=\"line\">  shadowOfBob.age++;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"shadowOfBob.age add 1;\"</span>);</span><br><span class=\"line\">  personBob.selfIntrduction();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"personBob have been accessed by shadowOfBob. = operator can not create an object. \"</span>);</span><br><span class=\"line\">  anotherBob.age++;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"anotherBob.age add 1\"</span>);</span><br><span class=\"line\">  personBob.selfIntrduction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上程序提供了一个复制构造函数的实现，由于 = 操作符创建的是对象的引用，本身不具备创建对象的功能并且无法被重载。因此一旦对象本身需要创建大量的副本，开发者就需要显式地提供复制构造函数。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Dart-命名构造函数\"><a href=\"#Dart-命名构造函数\" class=\"headerlink\" title=\"Dart 命名构造函数\"></a>Dart 命名构造函数</h3><blockquote>\n<p>构造函数既可以与是默认构造函数（函数名与类名同名，最多存在一个），也可以是命名构造函数（函数名以类名.标志符出现）。<br>在 Dart 开发者本身没有显示提供构造函数时，编译器会自动创建一个无参数的构造函数。需要更多构造函数时就需要命名构造函数来进行实现。</p>\n</blockquote>","more":"<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dart developer can user named constructors to create more than one constructors.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"><span class=\"comment\">//   This is a default constructor. If devloper don't provide, it will produce one with do nothing.</span></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>.age, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"><span class=\"comment\">//   Thie is a named constructor. </span></span><br><span class=\"line\">  Person.clonePerson(Person person) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = person.age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = person.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> selfIntrduction() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"I'm $name. I'm $age years old\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  Person personBob = <span class=\"keyword\">new</span> Person(<span class=\"number\">17</span>, <span class=\"string\">'Bob'</span>);</span><br><span class=\"line\">  Person anotherBob = <span class=\"keyword\">new</span> Person.clonePerson(personBob);</span><br><span class=\"line\">  anotherBob.selfIntrduction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href>在 DartPad 运行此代码</a></p>\n<blockquote>\n<p>事实上 Person.clonePerson() 的作用相当于复制构造函数。这个方法创造并返回了一个 personBob 的副本。我们可以来看一下以下这个有趣的栗子🌰</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>.age, <span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.clonePerson(Person person) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = person.age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = person.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">void</span> selfIntrduction() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"I'm $name. I'm $age years old\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  Person personBob = <span class=\"keyword\">new</span> Person(<span class=\"number\">17</span>, <span class=\"string\">'Bob'</span>); </span><br><span class=\"line\"><span class=\"comment\">//   shadowOfBob is not real Person because it just point to personBob.</span></span><br><span class=\"line\">  Person shadowOfBob = personBob;</span><br><span class=\"line\"><span class=\"comment\">//   anotherBob is an real Person and his change will not have any effect on personBob.</span></span><br><span class=\"line\">  Person anotherBob = <span class=\"keyword\">new</span> Person.clonePerson(personBob);</span><br><span class=\"line\">\tpersonBob.selfIntrduction();</span><br><span class=\"line\">  shadowOfBob.age++;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"shadowOfBob.age add 1;\"</span>);</span><br><span class=\"line\">  personBob.selfIntrduction();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"personBob have been accessed by shadowOfBob. = operator can not create an object. \"</span>);</span><br><span class=\"line\">  anotherBob.age++;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"anotherBob.age add 1\"</span>);</span><br><span class=\"line\">  personBob.selfIntrduction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上程序提供了一个复制构造函数的实现，由于 = 操作符创建的是对象的引用，本身不具备创建对象的功能并且无法被重载。因此一旦对象本身需要创建大量的副本，开发者就需要显式地提供复制构造函数。</p>"},{"title":"Dart 库","date":"2019-10-11T07:27:49.000Z","_content":"\n### 认识 Dart 的库概念\n\nDart 库就是一个 library，是一个模块化的、可共享的代码库。\n\nDart 库可以包含一组 import, export 和顶级声明。顶级声明可以是类、类型别名、函数或变量声明。\n\n<!--more-->\n\n```\ntopLevelDefinition:\nclassDefinition |\nenumType |\ntypeAlias |\nexternal? functionSignature ';' |\nexternal? getterSignature ';' |\nexternal? setterSignature ';' |\nfunctionSignature functionBody |\nreturnType? get identifier functionBody |\nreturnType? set identifier formalParameterList functionBody |\n(final | const) type? staticFinalDeclarationList ';' |\nvariableDeclaration ';'\n; \n\ngetOrSet:\nget |\nset\n;\n\nlibraryDeﬁnition:\nscriptTag? libraryName? importOrExport* partDirective* topLevelDefinition* \n;\n\nscriptTag:\n‘#!’ (˜NEWLINE)* NEWLINE \n;\n\nlibraryName:\nmetadata library identiﬁer (‘.’ identiﬁer)* ‘;’ \n;\n\nimportOrExport:\nlibraryImport |\nlibraryExport\n;\n```\n\n\n\n#### 库的访问权限\n\n与其他的编程语言不同的是，Dart 语法中不存在 public, private 和 protected 的关键字。成员标志符如果以下划线（_）开头可以将成员进行私有声明，库内部的私有声明只能为通过库内部的代码进行访问。\n\n\n由于顶级私有声明不会被导入，因此也不能被另一个库中使用。特别地对于任意的库，总是隐式地导入了 dart:core。\n\n库 L 的公共命名空间（包含的为库的可用对象）是一组映射，该映射将库 L 的每个公共顶级成员 m 的名称映射到成员 m。而库 L 的范围则包括了库中所有顶级声明的成员名称以及该库的引入（import）；\n\n\n\n#### Dart 库的命名\n\n开发者可以隐式或者显示地命名一个 Dart 库。\n\n- 显示命名 Dart 库：使用 library 关键字提供标识符和点的级联来为库命名。\n- 隐式命名 Dart 库：使用空字符串作为库的名称。\n\n#### import ：导入 Dart 库\n\nimport 允许将另一个库的非私有内容重用到当前文件。通常来说，import 语句以 URI （Uniform Resource Identifier）字符串来定位一个库的位置。\n\n```dart\nimport 'dart:core';\nimport 'package:flutter/material.dart';\nimport 'http://staxRUs/stack1.dart';\n```\n\n1. 使用 import as 来解决库内容的歧义冲突。\n假设两个需要导入的库当中存在两个同名的成员，这时编译器就无法区分开发者的意图了。对于这一问题，Dart 的解决方式与 Python 类似，可以使用 import as 语句在导入库时对不同的库使用不同的标志符进行区分。\n\n```dart\n// Assume that both package own a doSomething method. \nimport 'package1.dart' as p1;\nimport 'package2.dart' as p2;\np1.doSomething();\np2.doSomething();\n```\n2. 使用 import hide/show 来导入部分库成员\n\n如果开发者只需要导入部分库成员，那么可以使用显式地指定导入过程中需要部分导入或屏蔽的成员。\n\n```dart\n// Import only foo.\nimport 'package:lib1/lib1.dart' show foo;\n\n// Import all names EXCEPT foo.\nimport 'package:lib2/lib2.dart' hide foo;\n```\n\n#### part 拆分 Dart 库\n\n通常来讲一个库的内容很庞大，将一个庞大的代码库进行一定的分割是很有必要的，我们就会使用一对 part 命令来对 Dart 库进行分解。从 Dart 的官方文档看来， part 命令在后续的时间会被取代，不建议开发者使用。\n\n> part 命令是成对存在的，library 主文件中使用 part 指定一个 URI 来存放库的子系统的 dart 文件，相应地对应的 dart 文件也使用 part of library_name 来现实指定其归属的库。\n\n[Note: You may have heard of the part directive, which allows you to split a library into multiple Dart files. We recommend that you avoid using part and create mini libraries instead.](https://dart.dev/guides/libraries/create-library-packages#organizing-a-library-package)\n\n#### export 导出部分内容\n\n开发者可以通过 export 命令显式的将一部分库内容导出为库的公共 API，事实上这种方法应当尽可能取代 part 命令成为库管理的方式。\n\t\n```dart\nexport 'src/cascade.dart';\nexport 'src/handler.dart';\nexport 'src/handlers/logger.dart' show Logger;\nexport 'src/hijack_exception.dart';\nexport 'src/middleware.dart';\nexport 'src/pipeline.dart';\nexport 'src/request.dart' hide RequestException;\nexport 'src/response.dart';\nexport 'src/server.dart';\nexport 'src/server_handler.dart';\n```\n\n#### deferred as 延迟加载 Dart 库\n\n通常来讲 Dart 库在编译初期就会加载，这对于应用启动初期内存使用可能是一个负担。Dart 中的解决方法是延迟加载。\n\n使用 deferred as 为 import 指定一个需要延迟加载的库标志符，并在需要加载库的时候再使用异步函数显式地加载一个 Dart 库。\n\n```\nimport 'package:greetings/hello.dart' deferred as hello;\n\n...\n\nFuture greet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\t\n\n```","source":"_posts/Dart-库管理.md","raw":"---\ntitle: Dart 库\ndate: 2019-10-11 15:27:49\ntags: Dart\n---\n\n### 认识 Dart 的库概念\n\nDart 库就是一个 library，是一个模块化的、可共享的代码库。\n\nDart 库可以包含一组 import, export 和顶级声明。顶级声明可以是类、类型别名、函数或变量声明。\n\n<!--more-->\n\n```\ntopLevelDefinition:\nclassDefinition |\nenumType |\ntypeAlias |\nexternal? functionSignature ';' |\nexternal? getterSignature ';' |\nexternal? setterSignature ';' |\nfunctionSignature functionBody |\nreturnType? get identifier functionBody |\nreturnType? set identifier formalParameterList functionBody |\n(final | const) type? staticFinalDeclarationList ';' |\nvariableDeclaration ';'\n; \n\ngetOrSet:\nget |\nset\n;\n\nlibraryDeﬁnition:\nscriptTag? libraryName? importOrExport* partDirective* topLevelDefinition* \n;\n\nscriptTag:\n‘#!’ (˜NEWLINE)* NEWLINE \n;\n\nlibraryName:\nmetadata library identiﬁer (‘.’ identiﬁer)* ‘;’ \n;\n\nimportOrExport:\nlibraryImport |\nlibraryExport\n;\n```\n\n\n\n#### 库的访问权限\n\n与其他的编程语言不同的是，Dart 语法中不存在 public, private 和 protected 的关键字。成员标志符如果以下划线（_）开头可以将成员进行私有声明，库内部的私有声明只能为通过库内部的代码进行访问。\n\n\n由于顶级私有声明不会被导入，因此也不能被另一个库中使用。特别地对于任意的库，总是隐式地导入了 dart:core。\n\n库 L 的公共命名空间（包含的为库的可用对象）是一组映射，该映射将库 L 的每个公共顶级成员 m 的名称映射到成员 m。而库 L 的范围则包括了库中所有顶级声明的成员名称以及该库的引入（import）；\n\n\n\n#### Dart 库的命名\n\n开发者可以隐式或者显示地命名一个 Dart 库。\n\n- 显示命名 Dart 库：使用 library 关键字提供标识符和点的级联来为库命名。\n- 隐式命名 Dart 库：使用空字符串作为库的名称。\n\n#### import ：导入 Dart 库\n\nimport 允许将另一个库的非私有内容重用到当前文件。通常来说，import 语句以 URI （Uniform Resource Identifier）字符串来定位一个库的位置。\n\n```dart\nimport 'dart:core';\nimport 'package:flutter/material.dart';\nimport 'http://staxRUs/stack1.dart';\n```\n\n1. 使用 import as 来解决库内容的歧义冲突。\n假设两个需要导入的库当中存在两个同名的成员，这时编译器就无法区分开发者的意图了。对于这一问题，Dart 的解决方式与 Python 类似，可以使用 import as 语句在导入库时对不同的库使用不同的标志符进行区分。\n\n```dart\n// Assume that both package own a doSomething method. \nimport 'package1.dart' as p1;\nimport 'package2.dart' as p2;\np1.doSomething();\np2.doSomething();\n```\n2. 使用 import hide/show 来导入部分库成员\n\n如果开发者只需要导入部分库成员，那么可以使用显式地指定导入过程中需要部分导入或屏蔽的成员。\n\n```dart\n// Import only foo.\nimport 'package:lib1/lib1.dart' show foo;\n\n// Import all names EXCEPT foo.\nimport 'package:lib2/lib2.dart' hide foo;\n```\n\n#### part 拆分 Dart 库\n\n通常来讲一个库的内容很庞大，将一个庞大的代码库进行一定的分割是很有必要的，我们就会使用一对 part 命令来对 Dart 库进行分解。从 Dart 的官方文档看来， part 命令在后续的时间会被取代，不建议开发者使用。\n\n> part 命令是成对存在的，library 主文件中使用 part 指定一个 URI 来存放库的子系统的 dart 文件，相应地对应的 dart 文件也使用 part of library_name 来现实指定其归属的库。\n\n[Note: You may have heard of the part directive, which allows you to split a library into multiple Dart files. We recommend that you avoid using part and create mini libraries instead.](https://dart.dev/guides/libraries/create-library-packages#organizing-a-library-package)\n\n#### export 导出部分内容\n\n开发者可以通过 export 命令显式的将一部分库内容导出为库的公共 API，事实上这种方法应当尽可能取代 part 命令成为库管理的方式。\n\t\n```dart\nexport 'src/cascade.dart';\nexport 'src/handler.dart';\nexport 'src/handlers/logger.dart' show Logger;\nexport 'src/hijack_exception.dart';\nexport 'src/middleware.dart';\nexport 'src/pipeline.dart';\nexport 'src/request.dart' hide RequestException;\nexport 'src/response.dart';\nexport 'src/server.dart';\nexport 'src/server_handler.dart';\n```\n\n#### deferred as 延迟加载 Dart 库\n\n通常来讲 Dart 库在编译初期就会加载，这对于应用启动初期内存使用可能是一个负担。Dart 中的解决方法是延迟加载。\n\n使用 deferred as 为 import 指定一个需要延迟加载的库标志符，并在需要加载库的时候再使用异步函数显式地加载一个 Dart 库。\n\n```\nimport 'package:greetings/hello.dart' deferred as hello;\n\n...\n\nFuture greet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\t\n\n```","slug":"Dart-库管理","published":1,"updated":"2020-03-15T21:05:07.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3w8000929fyh5xqvrxm","content":"<h3 id=\"认识-Dart-的库概念\"><a href=\"#认识-Dart-的库概念\" class=\"headerlink\" title=\"认识 Dart 的库概念\"></a>认识 Dart 的库概念</h3><p>Dart 库就是一个 library，是一个模块化的、可共享的代码库。</p>\n<p>Dart 库可以包含一组 import, export 和顶级声明。顶级声明可以是类、类型别名、函数或变量声明。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">topLevelDefinition:</span><br><span class=\"line\">classDefinition |</span><br><span class=\"line\">enumType |</span><br><span class=\"line\">typeAlias |</span><br><span class=\"line\">external? functionSignature &apos;;&apos; |</span><br><span class=\"line\">external? getterSignature &apos;;&apos; |</span><br><span class=\"line\">external? setterSignature &apos;;&apos; |</span><br><span class=\"line\">functionSignature functionBody |</span><br><span class=\"line\">returnType? get identifier functionBody |</span><br><span class=\"line\">returnType? set identifier formalParameterList functionBody |</span><br><span class=\"line\">(final | const) type? staticFinalDeclarationList &apos;;&apos; |</span><br><span class=\"line\">variableDeclaration &apos;;&apos;</span><br><span class=\"line\">; </span><br><span class=\"line\"></span><br><span class=\"line\">getOrSet:</span><br><span class=\"line\">get |</span><br><span class=\"line\">set</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">libraryDeﬁnition:</span><br><span class=\"line\">scriptTag? libraryName? importOrExport* partDirective* topLevelDefinition* </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">scriptTag:</span><br><span class=\"line\">‘#!’ (˜NEWLINE)* NEWLINE </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">libraryName:</span><br><span class=\"line\">metadata library identiﬁer (‘.’ identiﬁer)* ‘;’ </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">importOrExport:</span><br><span class=\"line\">libraryImport |</span><br><span class=\"line\">libraryExport</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"库的访问权限\"><a href=\"#库的访问权限\" class=\"headerlink\" title=\"库的访问权限\"></a>库的访问权限</h4><p>与其他的编程语言不同的是，Dart 语法中不存在 public, private 和 protected 的关键字。成员标志符如果以下划线（_）开头可以将成员进行私有声明，库内部的私有声明只能为通过库内部的代码进行访问。</p>\n<p>由于顶级私有声明不会被导入，因此也不能被另一个库中使用。特别地对于任意的库，总是隐式地导入了 dart:core。</p>\n<p>库 L 的公共命名空间（包含的为库的可用对象）是一组映射，该映射将库 L 的每个公共顶级成员 m 的名称映射到成员 m。而库 L 的范围则包括了库中所有顶级声明的成员名称以及该库的引入（import）；</p>\n<h4 id=\"Dart-库的命名\"><a href=\"#Dart-库的命名\" class=\"headerlink\" title=\"Dart 库的命名\"></a>Dart 库的命名</h4><p>开发者可以隐式或者显示地命名一个 Dart 库。</p>\n<ul>\n<li>显示命名 Dart 库：使用 library 关键字提供标识符和点的级联来为库命名。</li>\n<li>隐式命名 Dart 库：使用空字符串作为库的名称。</li>\n</ul>\n<h4 id=\"import-：导入-Dart-库\"><a href=\"#import-：导入-Dart-库\" class=\"headerlink\" title=\"import ：导入 Dart 库\"></a>import ：导入 Dart 库</h4><p>import 允许将另一个库的非私有内容重用到当前文件。通常来说，import 语句以 URI （Uniform Resource Identifier）字符串来定位一个库的位置。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'http://staxRUs/stack1.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用 import as 来解决库内容的歧义冲突。<br>假设两个需要导入的库当中存在两个同名的成员，这时编译器就无法区分开发者的意图了。对于这一问题，Dart 的解决方式与 Python 类似，可以使用 import as 语句在导入库时对不同的库使用不同的标志符进行区分。</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Assume that both package own a doSomething method. </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package1.dart'</span> <span class=\"keyword\">as</span> p1;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package2.dart'</span> <span class=\"keyword\">as</span> p2;</span><br><span class=\"line\">p1.doSomething();</span><br><span class=\"line\">p2.doSomething();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 import hide/show 来导入部分库成员</li>\n</ol>\n<p>如果开发者只需要导入部分库成员，那么可以使用显式地指定导入过程中需要部分导入或屏蔽的成员。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Import only foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span> show foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Import all names EXCEPT foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"part-拆分-Dart-库\"><a href=\"#part-拆分-Dart-库\" class=\"headerlink\" title=\"part 拆分 Dart 库\"></a>part 拆分 Dart 库</h4><p>通常来讲一个库的内容很庞大，将一个庞大的代码库进行一定的分割是很有必要的，我们就会使用一对 part 命令来对 Dart 库进行分解。从 Dart 的官方文档看来， part 命令在后续的时间会被取代，不建议开发者使用。</p>\n<blockquote>\n<p>part 命令是成对存在的，library 主文件中使用 part 指定一个 URI 来存放库的子系统的 dart 文件，相应地对应的 dart 文件也使用 part of library_name 来现实指定其归属的库。</p>\n</blockquote>\n<p><a href=\"https://dart.dev/guides/libraries/create-library-packages#organizing-a-library-package\" target=\"_blank\" rel=\"noopener\">Note: You may have heard of the part directive, which allows you to split a library into multiple Dart files. We recommend that you avoid using part and create mini libraries instead.</a></p>\n<h4 id=\"export-导出部分内容\"><a href=\"#export-导出部分内容\" class=\"headerlink\" title=\"export 导出部分内容\"></a>export 导出部分内容</h4><p>开发者可以通过 export 命令显式的将一部分库内容导出为库的公共 API，事实上这种方法应当尽可能取代 part 命令成为库管理的方式。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/cascade.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/handler.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/handlers/logger.dart'</span> show Logger;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/hijack_exception.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/middleware.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/pipeline.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/request.dart'</span> hide RequestException;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/response.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/server.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/server_handler.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"deferred-as-延迟加载-Dart-库\"><a href=\"#deferred-as-延迟加载-Dart-库\" class=\"headerlink\" title=\"deferred as 延迟加载 Dart 库\"></a>deferred as 延迟加载 Dart 库</h4><p>通常来讲 Dart 库在编译初期就会加载，这对于应用启动初期内存使用可能是一个负担。Dart 中的解决方法是延迟加载。</p>\n<p>使用 deferred as 为 import 指定一个需要延迟加载的库标志符，并在需要加载库的时候再使用异步函数显式地加载一个 Dart 库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;package:greetings/hello.dart&apos; deferred as hello;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Future greet() async &#123;</span><br><span class=\"line\">  await hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"认识-Dart-的库概念\"><a href=\"#认识-Dart-的库概念\" class=\"headerlink\" title=\"认识 Dart 的库概念\"></a>认识 Dart 的库概念</h3><p>Dart 库就是一个 library，是一个模块化的、可共享的代码库。</p>\n<p>Dart 库可以包含一组 import, export 和顶级声明。顶级声明可以是类、类型别名、函数或变量声明。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">topLevelDefinition:</span><br><span class=\"line\">classDefinition |</span><br><span class=\"line\">enumType |</span><br><span class=\"line\">typeAlias |</span><br><span class=\"line\">external? functionSignature &apos;;&apos; |</span><br><span class=\"line\">external? getterSignature &apos;;&apos; |</span><br><span class=\"line\">external? setterSignature &apos;;&apos; |</span><br><span class=\"line\">functionSignature functionBody |</span><br><span class=\"line\">returnType? get identifier functionBody |</span><br><span class=\"line\">returnType? set identifier formalParameterList functionBody |</span><br><span class=\"line\">(final | const) type? staticFinalDeclarationList &apos;;&apos; |</span><br><span class=\"line\">variableDeclaration &apos;;&apos;</span><br><span class=\"line\">; </span><br><span class=\"line\"></span><br><span class=\"line\">getOrSet:</span><br><span class=\"line\">get |</span><br><span class=\"line\">set</span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">libraryDeﬁnition:</span><br><span class=\"line\">scriptTag? libraryName? importOrExport* partDirective* topLevelDefinition* </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">scriptTag:</span><br><span class=\"line\">‘#!’ (˜NEWLINE)* NEWLINE </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">libraryName:</span><br><span class=\"line\">metadata library identiﬁer (‘.’ identiﬁer)* ‘;’ </span><br><span class=\"line\">;</span><br><span class=\"line\"></span><br><span class=\"line\">importOrExport:</span><br><span class=\"line\">libraryImport |</span><br><span class=\"line\">libraryExport</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"库的访问权限\"><a href=\"#库的访问权限\" class=\"headerlink\" title=\"库的访问权限\"></a>库的访问权限</h4><p>与其他的编程语言不同的是，Dart 语法中不存在 public, private 和 protected 的关键字。成员标志符如果以下划线（_）开头可以将成员进行私有声明，库内部的私有声明只能为通过库内部的代码进行访问。</p>\n<p>由于顶级私有声明不会被导入，因此也不能被另一个库中使用。特别地对于任意的库，总是隐式地导入了 dart:core。</p>\n<p>库 L 的公共命名空间（包含的为库的可用对象）是一组映射，该映射将库 L 的每个公共顶级成员 m 的名称映射到成员 m。而库 L 的范围则包括了库中所有顶级声明的成员名称以及该库的引入（import）；</p>\n<h4 id=\"Dart-库的命名\"><a href=\"#Dart-库的命名\" class=\"headerlink\" title=\"Dart 库的命名\"></a>Dart 库的命名</h4><p>开发者可以隐式或者显示地命名一个 Dart 库。</p>\n<ul>\n<li>显示命名 Dart 库：使用 library 关键字提供标识符和点的级联来为库命名。</li>\n<li>隐式命名 Dart 库：使用空字符串作为库的名称。</li>\n</ul>\n<h4 id=\"import-：导入-Dart-库\"><a href=\"#import-：导入-Dart-库\" class=\"headerlink\" title=\"import ：导入 Dart 库\"></a>import ：导入 Dart 库</h4><p>import 允许将另一个库的非私有内容重用到当前文件。通常来说，import 语句以 URI （Uniform Resource Identifier）字符串来定位一个库的位置。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'http://staxRUs/stack1.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用 import as 来解决库内容的歧义冲突。<br>假设两个需要导入的库当中存在两个同名的成员，这时编译器就无法区分开发者的意图了。对于这一问题，Dart 的解决方式与 Python 类似，可以使用 import as 语句在导入库时对不同的库使用不同的标志符进行区分。</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Assume that both package own a doSomething method. </span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package1.dart'</span> <span class=\"keyword\">as</span> p1;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package2.dart'</span> <span class=\"keyword\">as</span> p2;</span><br><span class=\"line\">p1.doSomething();</span><br><span class=\"line\">p2.doSomething();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 import hide/show 来导入部分库成员</li>\n</ol>\n<p>如果开发者只需要导入部分库成员，那么可以使用显式地指定导入过程中需要部分导入或屏蔽的成员。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Import only foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span> show foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Import all names EXCEPT foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"part-拆分-Dart-库\"><a href=\"#part-拆分-Dart-库\" class=\"headerlink\" title=\"part 拆分 Dart 库\"></a>part 拆分 Dart 库</h4><p>通常来讲一个库的内容很庞大，将一个庞大的代码库进行一定的分割是很有必要的，我们就会使用一对 part 命令来对 Dart 库进行分解。从 Dart 的官方文档看来， part 命令在后续的时间会被取代，不建议开发者使用。</p>\n<blockquote>\n<p>part 命令是成对存在的，library 主文件中使用 part 指定一个 URI 来存放库的子系统的 dart 文件，相应地对应的 dart 文件也使用 part of library_name 来现实指定其归属的库。</p>\n</blockquote>\n<p><a href=\"https://dart.dev/guides/libraries/create-library-packages#organizing-a-library-package\" target=\"_blank\" rel=\"noopener\">Note: You may have heard of the part directive, which allows you to split a library into multiple Dart files. We recommend that you avoid using part and create mini libraries instead.</a></p>\n<h4 id=\"export-导出部分内容\"><a href=\"#export-导出部分内容\" class=\"headerlink\" title=\"export 导出部分内容\"></a>export 导出部分内容</h4><p>开发者可以通过 export 命令显式的将一部分库内容导出为库的公共 API，事实上这种方法应当尽可能取代 part 命令成为库管理的方式。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/cascade.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/handler.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/handlers/logger.dart'</span> show Logger;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/hijack_exception.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/middleware.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/pipeline.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/request.dart'</span> hide RequestException;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/response.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/server.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"string\">'src/server_handler.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"deferred-as-延迟加载-Dart-库\"><a href=\"#deferred-as-延迟加载-Dart-库\" class=\"headerlink\" title=\"deferred as 延迟加载 Dart 库\"></a>deferred as 延迟加载 Dart 库</h4><p>通常来讲 Dart 库在编译初期就会加载，这对于应用启动初期内存使用可能是一个负担。Dart 中的解决方法是延迟加载。</p>\n<p>使用 deferred as 为 import 指定一个需要延迟加载的库标志符，并在需要加载库的时候再使用异步函数显式地加载一个 Dart 库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;package:greetings/hello.dart&apos; deferred as hello;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">Future greet() async &#123;</span><br><span class=\"line\">  await hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dart异步","date":"2019-06-15T21:52:42.000Z","_content":"\n## 异步和 Isolate\n\n\n### 异步\n\n\n大多数时候，一个应用程序应该是并发执行的。由于 CPU 的执行速度几乎总是超前于外部事件（打开文件，访问网络）的响应，总是让应用程序处于同步执行状态无疑让 CPU 处于空闲状态。异步是相对同步而言的，对于同步通信，调用者将保持等待直到被调用者给出响应；对于异步通信而言，调用者发起调用请求之后，不进行等待而是立即执行后续程序。\n\n> Dart 并发基于 Isolate，依赖于 future 和 stream。\n\n<!--more-->\n\n### future \n\nfuture 是 Dart 中用于表示异步运算的结果，能用于异步运算中的变量传递。future 可以理解为一个等待运算结果传递至当前对象的容器。dart:async 库的 Future 泛型类用于实现这一过程，Future 类接受类型参数 T 传递future 接受的值类型。\n\n### Future 类 API\n\nFuture 对象可能以两种情况结束：成功与失败，也可能永远不结束。无论如何 Future 对象总是存在。\n\n使用 future 类的 API：then() 方法和 catchError() 方法是 future结束调用的方法，方法的参数为一个接受类型参数 T 的闭包，起作用分别是在 future 完成和异常结束操作 future 的值。\n\n```dart\nFuture<int> future = getFuture();\nfuture.then((value) => handleValue(value))\n      .catchError((error) => handleError(error));\n```\n\n### async 与 await\n\nasync 用来修饰一个异步函数。await 表达式使用的场合是异步并等待，因此 await 只能出现在异步函数中。await 语句能让异步函数进入立即返回一个未完成的 future，进入异步执行阶段，转而执行函数外部的同步代码。直到同步代码执行完成，异步代码继续执行。\n\n特别地，一个异步函数并非一开始就进入异步执行的阶段，而是在以下三种情况才返回一个未完成的 future。\n\n- 函数的第一个 await 表达式\n- return 语句\n- 函数结束\n\n    \n\n换言之，强制使用 async 修饰一个没有耗时操作的函数，该函数内部不触发异步执行。与 Future 对象不同的行为是，每一个 await 表达式总是让异步函数进入异步状态。\n\n> (值得一看的文章)[https://juejin.im/post/5c898b4af265da2de25bcc2d]，这篇文章第一个例子中，MethodC 实际上就不是一个异步函数。 \n\n```dart\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:async';\n\nFuture<void> printDailyNewsDigest() async {\n  var newsDigest = await gatherNewsReports();\n  print(newsDigest);\n}\n\nprintDailyNewsDigest1() async {\n  await print(\"Manual trigger async\");\n  print(\"123\");\n}\n\nmain() {\n  var a =  printDailyNewsDigest1();\n  print(a.toString());\n  printWinningLotteryNumbers();\n  printWeatherForecast();\n  printBaseballScore();\n}\n\nprintWinningLotteryNumbers() {\n  print('Winning lotto numbers: [23, 63, 87, 26, 2]');\n}\n\nprintWeatherForecast() {\n  print(\"Tomorrow's forecast: 70F, sunny.\");\n}\n\nprintBaseballScore() {\n  print('Baseball score: Red Sox 10, Yankees 0');\n}\n\nconst news = '<gathered news goes here>';\nconst oneSecond = Duration(seconds: 1);\n\n// Imagine that this function is more complex and slow. :)\nFuture<String> gatherNewsReports() =>\n    Future.delayed(oneSecond, () => news);\n\n// Alternatively, you can get news from a server using features\n// from either dart:io or dart:html. For example:\n//\n// import 'dart:html';\n//\n// Future<String> gatherNewsReportsFromServer() => HttpRequest.getString(\n//      'https://www.dartlang.org/f/dailyNewsDigest.txt',\n//    );\n```\n\n### Isolate \n\nDart 代码在一个单独的线程内部执行。\n> isolates: independent workers that are similar to threads but don't share memory, communicating only via messages.\n\nIsolate 是 Actor 模型的一个实现。每个 isolate 能够接受消息并执行顺序计算，isolate 之间相互隔离不共享内存空间并且使用 messageQueue 进行异步通信。Isolate 是 Dart 并发的最小单元。每个 Isolate 拥有独立的事件循环。\n\n(手动创建一个 Isolate)[https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a]\n\nIsolate 能够使用 Isolate.spawn() 方法创建一个新的 Isolate，并与其通过端口(port)进行通信，通过监听 ReceivePort 和为对方指定 sendPort 来进行通信\n\n```dart\n// main.dart\nmain() {  // in the main isolate\n    ReceivePort r1 = new ReceivePort();\n    SendPort s1 = r1.sendPort;\n    Isolate.spawnUri(new Uri(path:'./otherIsolate.dart'), [], s1);\n}\n\n// otherIsolate.dart\nmain(args, SendPort s1) { // in otherIsolate.dart\n    ReceivePort r2 = new ReceivePort();\n    SendPort s2 = r2.sendPort;\n    s1.send(s2);\n}\n```\n\n \n\n","source":"_posts/Dart-异步.md","raw":"---\ntitle: Dart异步\ndate: 2019-06-16 05:52:42\ntags: Dart\n---\n\n## 异步和 Isolate\n\n\n### 异步\n\n\n大多数时候，一个应用程序应该是并发执行的。由于 CPU 的执行速度几乎总是超前于外部事件（打开文件，访问网络）的响应，总是让应用程序处于同步执行状态无疑让 CPU 处于空闲状态。异步是相对同步而言的，对于同步通信，调用者将保持等待直到被调用者给出响应；对于异步通信而言，调用者发起调用请求之后，不进行等待而是立即执行后续程序。\n\n> Dart 并发基于 Isolate，依赖于 future 和 stream。\n\n<!--more-->\n\n### future \n\nfuture 是 Dart 中用于表示异步运算的结果，能用于异步运算中的变量传递。future 可以理解为一个等待运算结果传递至当前对象的容器。dart:async 库的 Future 泛型类用于实现这一过程，Future 类接受类型参数 T 传递future 接受的值类型。\n\n### Future 类 API\n\nFuture 对象可能以两种情况结束：成功与失败，也可能永远不结束。无论如何 Future 对象总是存在。\n\n使用 future 类的 API：then() 方法和 catchError() 方法是 future结束调用的方法，方法的参数为一个接受类型参数 T 的闭包，起作用分别是在 future 完成和异常结束操作 future 的值。\n\n```dart\nFuture<int> future = getFuture();\nfuture.then((value) => handleValue(value))\n      .catchError((error) => handleError(error));\n```\n\n### async 与 await\n\nasync 用来修饰一个异步函数。await 表达式使用的场合是异步并等待，因此 await 只能出现在异步函数中。await 语句能让异步函数进入立即返回一个未完成的 future，进入异步执行阶段，转而执行函数外部的同步代码。直到同步代码执行完成，异步代码继续执行。\n\n特别地，一个异步函数并非一开始就进入异步执行的阶段，而是在以下三种情况才返回一个未完成的 future。\n\n- 函数的第一个 await 表达式\n- return 语句\n- 函数结束\n\n    \n\n换言之，强制使用 async 修饰一个没有耗时操作的函数，该函数内部不触发异步执行。与 Future 对象不同的行为是，每一个 await 表达式总是让异步函数进入异步状态。\n\n> (值得一看的文章)[https://juejin.im/post/5c898b4af265da2de25bcc2d]，这篇文章第一个例子中，MethodC 实际上就不是一个异步函数。 \n\n```dart\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:async';\n\nFuture<void> printDailyNewsDigest() async {\n  var newsDigest = await gatherNewsReports();\n  print(newsDigest);\n}\n\nprintDailyNewsDigest1() async {\n  await print(\"Manual trigger async\");\n  print(\"123\");\n}\n\nmain() {\n  var a =  printDailyNewsDigest1();\n  print(a.toString());\n  printWinningLotteryNumbers();\n  printWeatherForecast();\n  printBaseballScore();\n}\n\nprintWinningLotteryNumbers() {\n  print('Winning lotto numbers: [23, 63, 87, 26, 2]');\n}\n\nprintWeatherForecast() {\n  print(\"Tomorrow's forecast: 70F, sunny.\");\n}\n\nprintBaseballScore() {\n  print('Baseball score: Red Sox 10, Yankees 0');\n}\n\nconst news = '<gathered news goes here>';\nconst oneSecond = Duration(seconds: 1);\n\n// Imagine that this function is more complex and slow. :)\nFuture<String> gatherNewsReports() =>\n    Future.delayed(oneSecond, () => news);\n\n// Alternatively, you can get news from a server using features\n// from either dart:io or dart:html. For example:\n//\n// import 'dart:html';\n//\n// Future<String> gatherNewsReportsFromServer() => HttpRequest.getString(\n//      'https://www.dartlang.org/f/dailyNewsDigest.txt',\n//    );\n```\n\n### Isolate \n\nDart 代码在一个单独的线程内部执行。\n> isolates: independent workers that are similar to threads but don't share memory, communicating only via messages.\n\nIsolate 是 Actor 模型的一个实现。每个 isolate 能够接受消息并执行顺序计算，isolate 之间相互隔离不共享内存空间并且使用 messageQueue 进行异步通信。Isolate 是 Dart 并发的最小单元。每个 Isolate 拥有独立的事件循环。\n\n(手动创建一个 Isolate)[https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a]\n\nIsolate 能够使用 Isolate.spawn() 方法创建一个新的 Isolate，并与其通过端口(port)进行通信，通过监听 ReceivePort 和为对方指定 sendPort 来进行通信\n\n```dart\n// main.dart\nmain() {  // in the main isolate\n    ReceivePort r1 = new ReceivePort();\n    SendPort s1 = r1.sendPort;\n    Isolate.spawnUri(new Uri(path:'./otherIsolate.dart'), [], s1);\n}\n\n// otherIsolate.dart\nmain(args, SendPort s1) { // in otherIsolate.dart\n    ReceivePort r2 = new ReceivePort();\n    SendPort s2 = r2.sendPort;\n    s1.send(s2);\n}\n```\n\n \n\n","slug":"Dart-异步","published":1,"updated":"2020-03-15T21:05:07.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wa000a29fy7r116vgo","content":"<h2 id=\"异步和-Isolate\"><a href=\"#异步和-Isolate\" class=\"headerlink\" title=\"异步和 Isolate\"></a>异步和 Isolate</h2><h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p>大多数时候，一个应用程序应该是并发执行的。由于 CPU 的执行速度几乎总是超前于外部事件（打开文件，访问网络）的响应，总是让应用程序处于同步执行状态无疑让 CPU 处于空闲状态。异步是相对同步而言的，对于同步通信，调用者将保持等待直到被调用者给出响应；对于异步通信而言，调用者发起调用请求之后，不进行等待而是立即执行后续程序。</p>\n<blockquote>\n<p>Dart 并发基于 Isolate，依赖于 future 和 stream。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h3><p>future 是 Dart 中用于表示异步运算的结果，能用于异步运算中的变量传递。future 可以理解为一个等待运算结果传递至当前对象的容器。dart:async 库的 Future 泛型类用于实现这一过程，Future 类接受类型参数 T 传递future 接受的值类型。</p>\n<h3 id=\"Future-类-API\"><a href=\"#Future-类-API\" class=\"headerlink\" title=\"Future 类 API\"></a>Future 类 API</h3><p>Future 对象可能以两种情况结束：成功与失败，也可能永远不结束。无论如何 Future 对象总是存在。</p>\n<p>使用 future 类的 API：then() 方法和 catchError() 方法是 future结束调用的方法，方法的参数为一个接受类型参数 T 的闭包，起作用分别是在 future 完成和异常结束操作 future 的值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; future = getFuture();</span><br><span class=\"line\">future.then((value) =&gt; handleValue(value))</span><br><span class=\"line\">      .catchError((error) =&gt; handleError(error));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async-与-await\"><a href=\"#async-与-await\" class=\"headerlink\" title=\"async 与 await\"></a>async 与 await</h3><p>async 用来修饰一个异步函数。await 表达式使用的场合是异步并等待，因此 await 只能出现在异步函数中。await 语句能让异步函数进入立即返回一个未完成的 future，进入异步执行阶段，转而执行函数外部的同步代码。直到同步代码执行完成，异步代码继续执行。</p>\n<p>特别地，一个异步函数并非一开始就进入异步执行的阶段，而是在以下三种情况才返回一个未完成的 future。</p>\n<ul>\n<li>函数的第一个 await 表达式</li>\n<li>return 语句</li>\n<li>函数结束</li>\n</ul>\n<p>换言之，强制使用 async 修饰一个没有耗时操作的函数，该函数内部不触发异步执行。与 Future 对象不同的行为是，每一个 await 表达式总是让异步函数进入异步状态。</p>\n<blockquote>\n<p>(值得一看的文章)[<a href=\"https://juejin.im/post/5c898b4af265da2de25bcc2d]，这篇文章第一个例子中，MethodC\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c898b4af265da2de25bcc2d]，这篇文章第一个例子中，MethodC</a> 实际上就不是一个异步函数。 </p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class=\"line\"><span class=\"comment\">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class=\"line\"><span class=\"comment\">// BSD-style license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"keyword\">void</span>&gt; printDailyNewsDigest() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newsDigest = <span class=\"keyword\">await</span> gatherNewsReports();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(newsDigest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printDailyNewsDigest1() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">print</span>(<span class=\"string\">\"Manual trigger async\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a =  printDailyNewsDigest1();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a.toString());</span><br><span class=\"line\">  printWinningLotteryNumbers();</span><br><span class=\"line\">  printWeatherForecast();</span><br><span class=\"line\">  printBaseballScore();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printWinningLotteryNumbers() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Winning lotto numbers: [23, 63, 87, 26, 2]'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printWeatherForecast() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Tomorrow's forecast: 70F, sunny.\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printBaseballScore() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Baseball score: Red Sox 10, Yankees 0'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> news = <span class=\"string\">'&lt;gathered news goes here&gt;'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> oneSecond = <span class=\"built_in\">Duration</span>(seconds: <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Imagine that this function is more complex and slow. :)</span></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; gatherNewsReports() =&gt;</span><br><span class=\"line\">    Future.delayed(oneSecond, () =&gt; news);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Alternatively, you can get news from a server using features</span></span><br><span class=\"line\"><span class=\"comment\">// from either dart:io or dart:html. For example:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// import 'dart:html';</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString(</span></span><br><span class=\"line\"><span class=\"comment\">//      'https://www.dartlang.org/f/dailyNewsDigest.txt',</span></span><br><span class=\"line\"><span class=\"comment\">//    );</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Isolate\"><a href=\"#Isolate\" class=\"headerlink\" title=\"Isolate\"></a>Isolate</h3><p>Dart 代码在一个单独的线程内部执行。</p>\n<blockquote>\n<p>isolates: independent workers that are similar to threads but don’t share memory, communicating only via messages.</p>\n</blockquote>\n<p>Isolate 是 Actor 模型的一个实现。每个 isolate 能够接受消息并执行顺序计算，isolate 之间相互隔离不共享内存空间并且使用 messageQueue 进行异步通信。Isolate 是 Dart 并发的最小单元。每个 Isolate 拥有独立的事件循环。</p>\n<p>(手动创建一个 Isolate)[<a href=\"https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a]\" target=\"_blank\" rel=\"noopener\">https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a]</a></p>\n<p>Isolate 能够使用 Isolate.spawn() 方法创建一个新的 Isolate，并与其通过端口(port)进行通信，通过监听 ReceivePort 和为对方指定 sendPort 来进行通信</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.dart</span></span><br><span class=\"line\">main() &#123;  <span class=\"comment\">// in the main isolate</span></span><br><span class=\"line\">    ReceivePort r1 = <span class=\"keyword\">new</span> ReceivePort();</span><br><span class=\"line\">    SendPort s1 = r1.sendPort;</span><br><span class=\"line\">    Isolate.spawnUri(<span class=\"keyword\">new</span> <span class=\"built_in\">Uri</span>(path:<span class=\"string\">'./otherIsolate.dart'</span>), [], s1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// otherIsolate.dart</span></span><br><span class=\"line\">main(args, SendPort s1) &#123; <span class=\"comment\">// in otherIsolate.dart</span></span><br><span class=\"line\">    ReceivePort r2 = <span class=\"keyword\">new</span> ReceivePort();</span><br><span class=\"line\">    SendPort s2 = r2.sendPort;</span><br><span class=\"line\">    s1.send(s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<h2 id=\"异步和-Isolate\"><a href=\"#异步和-Isolate\" class=\"headerlink\" title=\"异步和 Isolate\"></a>异步和 Isolate</h2><h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p>大多数时候，一个应用程序应该是并发执行的。由于 CPU 的执行速度几乎总是超前于外部事件（打开文件，访问网络）的响应，总是让应用程序处于同步执行状态无疑让 CPU 处于空闲状态。异步是相对同步而言的，对于同步通信，调用者将保持等待直到被调用者给出响应；对于异步通信而言，调用者发起调用请求之后，不进行等待而是立即执行后续程序。</p>\n<blockquote>\n<p>Dart 并发基于 Isolate，依赖于 future 和 stream。</p>\n</blockquote>","more":"<h3 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h3><p>future 是 Dart 中用于表示异步运算的结果，能用于异步运算中的变量传递。future 可以理解为一个等待运算结果传递至当前对象的容器。dart:async 库的 Future 泛型类用于实现这一过程，Future 类接受类型参数 T 传递future 接受的值类型。</p>\n<h3 id=\"Future-类-API\"><a href=\"#Future-类-API\" class=\"headerlink\" title=\"Future 类 API\"></a>Future 类 API</h3><p>Future 对象可能以两种情况结束：成功与失败，也可能永远不结束。无论如何 Future 对象总是存在。</p>\n<p>使用 future 类的 API：then() 方法和 catchError() 方法是 future结束调用的方法，方法的参数为一个接受类型参数 T 的闭包，起作用分别是在 future 完成和异常结束操作 future 的值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;<span class=\"built_in\">int</span>&gt; future = getFuture();</span><br><span class=\"line\">future.then((value) =&gt; handleValue(value))</span><br><span class=\"line\">      .catchError((error) =&gt; handleError(error));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async-与-await\"><a href=\"#async-与-await\" class=\"headerlink\" title=\"async 与 await\"></a>async 与 await</h3><p>async 用来修饰一个异步函数。await 表达式使用的场合是异步并等待，因此 await 只能出现在异步函数中。await 语句能让异步函数进入立即返回一个未完成的 future，进入异步执行阶段，转而执行函数外部的同步代码。直到同步代码执行完成，异步代码继续执行。</p>\n<p>特别地，一个异步函数并非一开始就进入异步执行的阶段，而是在以下三种情况才返回一个未完成的 future。</p>\n<ul>\n<li>函数的第一个 await 表达式</li>\n<li>return 语句</li>\n<li>函数结束</li>\n</ul>\n<p>换言之，强制使用 async 修饰一个没有耗时操作的函数，该函数内部不触发异步执行。与 Future 对象不同的行为是，每一个 await 表达式总是让异步函数进入异步状态。</p>\n<blockquote>\n<p>(值得一看的文章)[<a href=\"https://juejin.im/post/5c898b4af265da2de25bcc2d]，这篇文章第一个例子中，MethodC\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c898b4af265da2de25bcc2d]，这篇文章第一个例子中，MethodC</a> 实际上就不是一个异步函数。 </p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class=\"line\"><span class=\"comment\">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class=\"line\"><span class=\"comment\">// BSD-style license that can be found in the LICENSE file.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"keyword\">void</span>&gt; printDailyNewsDigest() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newsDigest = <span class=\"keyword\">await</span> gatherNewsReports();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(newsDigest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printDailyNewsDigest1() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">print</span>(<span class=\"string\">\"Manual trigger async\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a =  printDailyNewsDigest1();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(a.toString());</span><br><span class=\"line\">  printWinningLotteryNumbers();</span><br><span class=\"line\">  printWeatherForecast();</span><br><span class=\"line\">  printBaseballScore();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printWinningLotteryNumbers() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Winning lotto numbers: [23, 63, 87, 26, 2]'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printWeatherForecast() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Tomorrow's forecast: 70F, sunny.\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printBaseballScore() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Baseball score: Red Sox 10, Yankees 0'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> news = <span class=\"string\">'&lt;gathered news goes here&gt;'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> oneSecond = <span class=\"built_in\">Duration</span>(seconds: <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Imagine that this function is more complex and slow. :)</span></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; gatherNewsReports() =&gt;</span><br><span class=\"line\">    Future.delayed(oneSecond, () =&gt; news);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Alternatively, you can get news from a server using features</span></span><br><span class=\"line\"><span class=\"comment\">// from either dart:io or dart:html. For example:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// import 'dart:html';</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString(</span></span><br><span class=\"line\"><span class=\"comment\">//      'https://www.dartlang.org/f/dailyNewsDigest.txt',</span></span><br><span class=\"line\"><span class=\"comment\">//    );</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Isolate\"><a href=\"#Isolate\" class=\"headerlink\" title=\"Isolate\"></a>Isolate</h3><p>Dart 代码在一个单独的线程内部执行。</p>\n<blockquote>\n<p>isolates: independent workers that are similar to threads but don’t share memory, communicating only via messages.</p>\n</blockquote>\n<p>Isolate 是 Actor 模型的一个实现。每个 isolate 能够接受消息并执行顺序计算，isolate 之间相互隔离不共享内存空间并且使用 messageQueue 进行异步通信。Isolate 是 Dart 并发的最小单元。每个 Isolate 拥有独立的事件循环。</p>\n<p>(手动创建一个 Isolate)[<a href=\"https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a]\" target=\"_blank\" rel=\"noopener\">https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a]</a></p>\n<p>Isolate 能够使用 Isolate.spawn() 方法创建一个新的 Isolate，并与其通过端口(port)进行通信，通过监听 ReceivePort 和为对方指定 sendPort 来进行通信</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.dart</span></span><br><span class=\"line\">main() &#123;  <span class=\"comment\">// in the main isolate</span></span><br><span class=\"line\">    ReceivePort r1 = <span class=\"keyword\">new</span> ReceivePort();</span><br><span class=\"line\">    SendPort s1 = r1.sendPort;</span><br><span class=\"line\">    Isolate.spawnUri(<span class=\"keyword\">new</span> <span class=\"built_in\">Uri</span>(path:<span class=\"string\">'./otherIsolate.dart'</span>), [], s1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// otherIsolate.dart</span></span><br><span class=\"line\">main(args, SendPort s1) &#123; <span class=\"comment\">// in otherIsolate.dart</span></span><br><span class=\"line\">    ReceivePort r2 = <span class=\"keyword\">new</span> ReceivePort();</span><br><span class=\"line\">    SendPort s2 = r2.sendPort;</span><br><span class=\"line\">    s1.send(s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dart-抽象方法、抽象类和接口","date":"2019-05-11T01:26:07.000Z","_content":"\n\n\n### 抽象方法、抽象类和接口\n\n> - 抽象方法是只提供声明不提供实现方法的方法，只能存在于抽象类中。\n> - 抽象类是包含有抽象方法的类，需要使用 abstract 关键字来修饰，无法实例化。\n> - 接口是一个抽象类型，是抽象方法的集合。类通过实现接口的方式从而继承接口的抽象方法。\n\n<!--more-->\n\n```dart\n// A abstract class has more than one abstract method\nabstract class Animal{\n    // A abstract method has no implementation. \n    move();\n    // Abstract can be getter or setter. \n    get age();\n    set eat();\n}\n```\n\n抽象方法可以是普通方法，也可以是 getter 、setter 方法。抽象方法不需要给出具体实现，而是将实现交给其他类。抽象方法意味着方法仅在运行时可用。\n\n抽象类是使用关键字 abstract 进行修饰的类。一旦使用 abstract 进行修饰，类就被赋予了无法实例化的特性。\n\n以上的抽象类仅提供了抽象方法，并不包含具体实现，因此本质上这就是一个接口。Dart 语言中，每个类都隐式定义了接口，该接口包含该类的所有实例成员（显然不包括静态成员和构造函数）及其实现的任何接口，只要使用 implements 子句声明需要实现的接口，而无需建立继承关系。\n\n```dart\n// Any class have a implicit interface\nclass Animal{\n// all instance members are in the interface\n  final weight;\n  void doSomething(){ print(\"My weight is : \" + this.weight);}\n// other menbers are not in the interface\n  Animal(this.weight);\n}\n\nclass Cat implements Animal{\n// all members in the interface should be implemented\n    get weight => \"Cat's weight\";\n    void doSomething(){ print(\"Cat a mouse. \");}\n}\n\nvoid main(){\n  Animal animal = new Animal(\"123\");\n  animal.doSomething();\n  Cat cat = new Cat();\n  cat.doSomething();\n}\n```\n\n在实际上，我们通常会使用抽象类来完成习惯意义上的接口。\n\n[在 DartPad 运行此代码](<https://dartpad.dartlang.org/0f918428f5f7a3b5aa81f785bcf1d0cc>)\n\n","source":"_posts/Dart-抽象方法、抽象类和接口.md","raw":"---\ntitle: Dart-抽象方法、抽象类和接口\ndate: 2019-05-11 09:26:07\ntags: Dart\n---\n\n\n\n### 抽象方法、抽象类和接口\n\n> - 抽象方法是只提供声明不提供实现方法的方法，只能存在于抽象类中。\n> - 抽象类是包含有抽象方法的类，需要使用 abstract 关键字来修饰，无法实例化。\n> - 接口是一个抽象类型，是抽象方法的集合。类通过实现接口的方式从而继承接口的抽象方法。\n\n<!--more-->\n\n```dart\n// A abstract class has more than one abstract method\nabstract class Animal{\n    // A abstract method has no implementation. \n    move();\n    // Abstract can be getter or setter. \n    get age();\n    set eat();\n}\n```\n\n抽象方法可以是普通方法，也可以是 getter 、setter 方法。抽象方法不需要给出具体实现，而是将实现交给其他类。抽象方法意味着方法仅在运行时可用。\n\n抽象类是使用关键字 abstract 进行修饰的类。一旦使用 abstract 进行修饰，类就被赋予了无法实例化的特性。\n\n以上的抽象类仅提供了抽象方法，并不包含具体实现，因此本质上这就是一个接口。Dart 语言中，每个类都隐式定义了接口，该接口包含该类的所有实例成员（显然不包括静态成员和构造函数）及其实现的任何接口，只要使用 implements 子句声明需要实现的接口，而无需建立继承关系。\n\n```dart\n// Any class have a implicit interface\nclass Animal{\n// all instance members are in the interface\n  final weight;\n  void doSomething(){ print(\"My weight is : \" + this.weight);}\n// other menbers are not in the interface\n  Animal(this.weight);\n}\n\nclass Cat implements Animal{\n// all members in the interface should be implemented\n    get weight => \"Cat's weight\";\n    void doSomething(){ print(\"Cat a mouse. \");}\n}\n\nvoid main(){\n  Animal animal = new Animal(\"123\");\n  animal.doSomething();\n  Cat cat = new Cat();\n  cat.doSomething();\n}\n```\n\n在实际上，我们通常会使用抽象类来完成习惯意义上的接口。\n\n[在 DartPad 运行此代码](<https://dartpad.dartlang.org/0f918428f5f7a3b5aa81f785bcf1d0cc>)\n\n","slug":"Dart-抽象方法、抽象类和接口","published":1,"updated":"2020-03-15T21:05:07.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wa000b29fyac7xo072","content":"<h3 id=\"抽象方法、抽象类和接口\"><a href=\"#抽象方法、抽象类和接口\" class=\"headerlink\" title=\"抽象方法、抽象类和接口\"></a>抽象方法、抽象类和接口</h3><blockquote>\n<ul>\n<li>抽象方法是只提供声明不提供实现方法的方法，只能存在于抽象类中。</li>\n<li>抽象类是包含有抽象方法的类，需要使用 abstract 关键字来修饰，无法实例化。</li>\n<li>接口是一个抽象类型，是抽象方法的集合。类通过实现接口的方式从而继承接口的抽象方法。</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A abstract class has more than one abstract method</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// A abstract method has no implementation. </span></span><br><span class=\"line\">    move();</span><br><span class=\"line\">    <span class=\"comment\">// Abstract can be getter or setter. </span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> age();</span><br><span class=\"line\">    <span class=\"keyword\">set</span> eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抽象方法可以是普通方法，也可以是 getter 、setter 方法。抽象方法不需要给出具体实现，而是将实现交给其他类。抽象方法意味着方法仅在运行时可用。</p>\n<p>抽象类是使用关键字 abstract 进行修饰的类。一旦使用 abstract 进行修饰，类就被赋予了无法实例化的特性。</p>\n<p>以上的抽象类仅提供了抽象方法，并不包含具体实现，因此本质上这就是一个接口。Dart 语言中，每个类都隐式定义了接口，该接口包含该类的所有实例成员（显然不包括静态成员和构造函数）及其实现的任何接口，只要使用 implements 子句声明需要实现的接口，而无需建立继承关系。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Any class have a implicit interface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// all instance members are in the interface</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> weight;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> doSomething()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"My weight is : \"</span> + <span class=\"keyword\">this</span>.weight);&#125;</span><br><span class=\"line\"><span class=\"comment\">// other menbers are not in the interface</span></span><br><span class=\"line\">  Animal(<span class=\"keyword\">this</span>.weight);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// all members in the interface should be implemented</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> weight =&gt; <span class=\"string\">\"Cat's weight\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> doSomething()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Cat a mouse. \"</span>);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  Animal animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">  animal.doSomething();</span><br><span class=\"line\">  Cat cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">  cat.doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实际上，我们通常会使用抽象类来完成习惯意义上的接口。</p>\n<p><a href=\"https://dartpad.dartlang.org/0f918428f5f7a3b5aa81f785bcf1d0cc\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"抽象方法、抽象类和接口\"><a href=\"#抽象方法、抽象类和接口\" class=\"headerlink\" title=\"抽象方法、抽象类和接口\"></a>抽象方法、抽象类和接口</h3><blockquote>\n<ul>\n<li>抽象方法是只提供声明不提供实现方法的方法，只能存在于抽象类中。</li>\n<li>抽象类是包含有抽象方法的类，需要使用 abstract 关键字来修饰，无法实例化。</li>\n<li>接口是一个抽象类型，是抽象方法的集合。类通过实现接口的方式从而继承接口的抽象方法。</li>\n</ul>\n</blockquote>","more":"<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A abstract class has more than one abstract method</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// A abstract method has no implementation. </span></span><br><span class=\"line\">    move();</span><br><span class=\"line\">    <span class=\"comment\">// Abstract can be getter or setter. </span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> age();</span><br><span class=\"line\">    <span class=\"keyword\">set</span> eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抽象方法可以是普通方法，也可以是 getter 、setter 方法。抽象方法不需要给出具体实现，而是将实现交给其他类。抽象方法意味着方法仅在运行时可用。</p>\n<p>抽象类是使用关键字 abstract 进行修饰的类。一旦使用 abstract 进行修饰，类就被赋予了无法实例化的特性。</p>\n<p>以上的抽象类仅提供了抽象方法，并不包含具体实现，因此本质上这就是一个接口。Dart 语言中，每个类都隐式定义了接口，该接口包含该类的所有实例成员（显然不包括静态成员和构造函数）及其实现的任何接口，只要使用 implements 子句声明需要实现的接口，而无需建立继承关系。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Any class have a implicit interface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// all instance members are in the interface</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> weight;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> doSomething()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"My weight is : \"</span> + <span class=\"keyword\">this</span>.weight);&#125;</span><br><span class=\"line\"><span class=\"comment\">// other menbers are not in the interface</span></span><br><span class=\"line\">  Animal(<span class=\"keyword\">this</span>.weight);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">implements</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// all members in the interface should be implemented</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> weight =&gt; <span class=\"string\">\"Cat's weight\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> doSomething()&#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Cat a mouse. \"</span>);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  Animal animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">  animal.doSomething();</span><br><span class=\"line\">  Cat cat = <span class=\"keyword\">new</span> Cat();</span><br><span class=\"line\">  cat.doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实际上，我们通常会使用抽象类来完成习惯意义上的接口。</p>\n<p><a href=\"https://dartpad.dartlang.org/0f918428f5f7a3b5aa81f785bcf1d0cc\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>"},{"layout":"drafts","title":"Dart-语句","date":"2019-06-20T06:23:00.000Z","_content":"\n## Dart 控制流语句\n\n对于 Dart 而言，其代码执行的流总是从上而下逐条语句依次进行。但是可以使用一些控制流语句来实现控制 Dart 代码的执行流。\n\n有以下一些语句会直接影响 Dart 代码的执行流：\n\n- if-else 分支\n- for 循环\n- while 循环\n- break & continue\n- switch 分支\n- try-catch 语句\n- return 语句\n- assert 语句\n\n<!--more-->\n\n### if else\n\nif else 是最基本的分支语句。\n\nif 语句通过布尔表达式来控制子句的执行与否，可选的 else 语句作为另一选项而存在。\n\n```\nif(x > 0) print(x); else print(-x);\nif(x > 0){\n\tprint(x);\n}else{\n\tprint(-x);\n}\n```\n分支语句的判断是基于布尔表达式的值作为判断基准的，因此传入的表达式的类型推断为非 bool 类型时，会导致编译器的警告；若传入的表达式的类型不确定，也会导致运行时错误。\n\n### for loop\n\n经典 for 循环的写法如下：\n\n```\n// for(初始化; 检测; 更新索引) 循环体\nfor(int index= 0;index < M;index++){\n\t;\n}\n```\n\n对于实现了 Iterable 接口的类，还可以使用 for-in 语句对其进行遍历访问。\n\n```dart\nfor(v in [1,2,3,4]) pritn(v);\n```\n\n警惕闭包行为对于 Dart 的异常之处。\n\n### while & do-while loop\n\nwhile 循环基于一个循环条件，如果循环条件检测为真则执行循环体。\n\ndo-while 是 while 循环的变体，区别在于 do-while 总是先进入循环体一次再进行循环条件检测。\n\n```dart\nwhile (!isDone()) {\n  doSomething();\n}\ndo {\n  printLine();\n} while (!atEndOfPage());\n```\n\n###break & continue\n\n相信学过 C/C++ 的应该对于 break & continue ，这两个关键字是用来控制半结构化控制流。\n\nbreak： 跳出迭代过程。\ncontine：直接进入下一次迭代。\n\n```dart\nwhile (true) {\n  if (shutDownRequested()) break;\n  processIncomingRequests();\n}\nfor (int i = 0; i < candidates.length; i++) {\n  var candidate = candidates[i];\n  if (candidate.yearsExperience < 5) {\n    continue;\n  }\n  candidate.interview();\n}\n```\n\n### switch \n\nswitch 语句支持根据同一类型的整型，字符串编译时常量判断的分支。严格来讲，所有 switch 语句都可以使用 if-else 语句来代替，但是使用 switch 语句能将基础的分支结构变得清晰可见。\n\n每一个 case 子句都伴随一个编译时常量作为分支条件，并且以 break 语句结束；\n\n```dart\nvar index = 2;\nswitch (index) {\n    case 0:\n        print(0);\n        break;\n    case 1:\n        print('hello');\n        break;\n    case 2:\n    case 3:\n        print('two or three');\n        break;\n    default:\n        print('Default');\n}\n```\n\n\n\n### try-catch\n\ntry-catch 语句的作用是捕获异常，在可能引发异常的情况下，应当使用 try-catch 来控制代码的执行流。\ntry 语句后伴随可能抛出异常的语句；\nthrow 可以显示的抛出一个对象；\non T catch 可以捕获一个 T 类型的对象；\nfinally 中的语句无论异常情况如何总是执行；\nrethrow 支持将异常重新抛出；\n\n```dart\nvoid main() {\n//  int x = -1;\n  int x;\n  try {\n    if (x >= 0) {\n      print('x >= 0');\n    } else {\n      throw 'negative x = $x';\n    }\n  } on String catch (e) {\n    print(e.toString());\n  } catch (o) {\n    print('Unknown Type Exception :$o');\n  } finally{\n    print('Always execute');\n  }\n}\n\n```\n\n\n### return \n\nreturn 语句将函数运行结果交付给函数的调用者，当开发者不显示指定返回值时，默认返回 null；特别的，try-catch 语句中，return 会交付到 finally 子句。\n\n### assert\n\nassert 语句是一种调试断言的手段。在生产环境下不会运行。\nassert(value) 接受一个布尔型的参数，一旦参数为 false 则语句会立即抛出 AssertionError 异常。\n\n这一类语句的使用是为了让开发者可以让一些事件符合预期，如以下的代码是 Text 类的构造函数原型。assert 语句能够显示地避免一些异常情况而不增大运行时的时间和空间开销。\n\n```dart\nconst Text(\n  this.data, {\n  Key key,\n  this.style,\n  this.strutStyle,\n  this.textAlign,\n  this.textDirection,\n  this.locale,\n  this.softWrap,\n  this.overflow,\n  this.textScaleFactor,\n  this.maxLines,\n  this.semanticsLabel,\n}) : assert(\n       data != null,\n       'A non-null String must be provided to a Text widget.',\n     ),\n     textSpan = null,\n     super(key: key);\n```\n","source":"_posts/Dart-控制流语句.md","raw":"---\nlayout: drafts\ntitle: Dart-语句\ndate: 2019-06-20 14:23:00\ntags: Dart\n---\n\n## Dart 控制流语句\n\n对于 Dart 而言，其代码执行的流总是从上而下逐条语句依次进行。但是可以使用一些控制流语句来实现控制 Dart 代码的执行流。\n\n有以下一些语句会直接影响 Dart 代码的执行流：\n\n- if-else 分支\n- for 循环\n- while 循环\n- break & continue\n- switch 分支\n- try-catch 语句\n- return 语句\n- assert 语句\n\n<!--more-->\n\n### if else\n\nif else 是最基本的分支语句。\n\nif 语句通过布尔表达式来控制子句的执行与否，可选的 else 语句作为另一选项而存在。\n\n```\nif(x > 0) print(x); else print(-x);\nif(x > 0){\n\tprint(x);\n}else{\n\tprint(-x);\n}\n```\n分支语句的判断是基于布尔表达式的值作为判断基准的，因此传入的表达式的类型推断为非 bool 类型时，会导致编译器的警告；若传入的表达式的类型不确定，也会导致运行时错误。\n\n### for loop\n\n经典 for 循环的写法如下：\n\n```\n// for(初始化; 检测; 更新索引) 循环体\nfor(int index= 0;index < M;index++){\n\t;\n}\n```\n\n对于实现了 Iterable 接口的类，还可以使用 for-in 语句对其进行遍历访问。\n\n```dart\nfor(v in [1,2,3,4]) pritn(v);\n```\n\n警惕闭包行为对于 Dart 的异常之处。\n\n### while & do-while loop\n\nwhile 循环基于一个循环条件，如果循环条件检测为真则执行循环体。\n\ndo-while 是 while 循环的变体，区别在于 do-while 总是先进入循环体一次再进行循环条件检测。\n\n```dart\nwhile (!isDone()) {\n  doSomething();\n}\ndo {\n  printLine();\n} while (!atEndOfPage());\n```\n\n###break & continue\n\n相信学过 C/C++ 的应该对于 break & continue ，这两个关键字是用来控制半结构化控制流。\n\nbreak： 跳出迭代过程。\ncontine：直接进入下一次迭代。\n\n```dart\nwhile (true) {\n  if (shutDownRequested()) break;\n  processIncomingRequests();\n}\nfor (int i = 0; i < candidates.length; i++) {\n  var candidate = candidates[i];\n  if (candidate.yearsExperience < 5) {\n    continue;\n  }\n  candidate.interview();\n}\n```\n\n### switch \n\nswitch 语句支持根据同一类型的整型，字符串编译时常量判断的分支。严格来讲，所有 switch 语句都可以使用 if-else 语句来代替，但是使用 switch 语句能将基础的分支结构变得清晰可见。\n\n每一个 case 子句都伴随一个编译时常量作为分支条件，并且以 break 语句结束；\n\n```dart\nvar index = 2;\nswitch (index) {\n    case 0:\n        print(0);\n        break;\n    case 1:\n        print('hello');\n        break;\n    case 2:\n    case 3:\n        print('two or three');\n        break;\n    default:\n        print('Default');\n}\n```\n\n\n\n### try-catch\n\ntry-catch 语句的作用是捕获异常，在可能引发异常的情况下，应当使用 try-catch 来控制代码的执行流。\ntry 语句后伴随可能抛出异常的语句；\nthrow 可以显示的抛出一个对象；\non T catch 可以捕获一个 T 类型的对象；\nfinally 中的语句无论异常情况如何总是执行；\nrethrow 支持将异常重新抛出；\n\n```dart\nvoid main() {\n//  int x = -1;\n  int x;\n  try {\n    if (x >= 0) {\n      print('x >= 0');\n    } else {\n      throw 'negative x = $x';\n    }\n  } on String catch (e) {\n    print(e.toString());\n  } catch (o) {\n    print('Unknown Type Exception :$o');\n  } finally{\n    print('Always execute');\n  }\n}\n\n```\n\n\n### return \n\nreturn 语句将函数运行结果交付给函数的调用者，当开发者不显示指定返回值时，默认返回 null；特别的，try-catch 语句中，return 会交付到 finally 子句。\n\n### assert\n\nassert 语句是一种调试断言的手段。在生产环境下不会运行。\nassert(value) 接受一个布尔型的参数，一旦参数为 false 则语句会立即抛出 AssertionError 异常。\n\n这一类语句的使用是为了让开发者可以让一些事件符合预期，如以下的代码是 Text 类的构造函数原型。assert 语句能够显示地避免一些异常情况而不增大运行时的时间和空间开销。\n\n```dart\nconst Text(\n  this.data, {\n  Key key,\n  this.style,\n  this.strutStyle,\n  this.textAlign,\n  this.textDirection,\n  this.locale,\n  this.softWrap,\n  this.overflow,\n  this.textScaleFactor,\n  this.maxLines,\n  this.semanticsLabel,\n}) : assert(\n       data != null,\n       'A non-null String must be provided to a Text widget.',\n     ),\n     textSpan = null,\n     super(key: key);\n```\n","slug":"Dart-控制流语句","published":1,"updated":"2020-03-15T21:05:07.239Z","comments":1,"photos":[],"link":"","_id":"ck7tjf3wb000c29fyqjhdin77","content":"<h2 id=\"Dart-控制流语句\"><a href=\"#Dart-控制流语句\" class=\"headerlink\" title=\"Dart 控制流语句\"></a>Dart 控制流语句</h2><p>对于 Dart 而言，其代码执行的流总是从上而下逐条语句依次进行。但是可以使用一些控制流语句来实现控制 Dart 代码的执行流。</p>\n<p>有以下一些语句会直接影响 Dart 代码的执行流：</p>\n<ul>\n<li>if-else 分支</li>\n<li>for 循环</li>\n<li>while 循环</li>\n<li>break &amp; continue</li>\n<li>switch 分支</li>\n<li>try-catch 语句</li>\n<li>return 语句</li>\n<li>assert 语句</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h3><p>if else 是最基本的分支语句。</p>\n<p>if 语句通过布尔表达式来控制子句的执行与否，可选的 else 语句作为另一选项而存在。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(x &gt; 0) print(x); else print(-x);</span><br><span class=\"line\">if(x &gt; 0)&#123;</span><br><span class=\"line\">\tprint(x);</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\tprint(-x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分支语句的判断是基于布尔表达式的值作为判断基准的，因此传入的表达式的类型推断为非 bool 类型时，会导致编译器的警告；若传入的表达式的类型不确定，也会导致运行时错误。</p>\n<h3 id=\"for-loop\"><a href=\"#for-loop\" class=\"headerlink\" title=\"for loop\"></a>for loop</h3><p>经典 for 循环的写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// for(初始化; 检测; 更新索引) 循环体</span><br><span class=\"line\">for(int index= 0;index &lt; M;index++)&#123;</span><br><span class=\"line\">\t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于实现了 Iterable 接口的类，还可以使用 for-in 语句对其进行遍历访问。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(v <span class=\"keyword\">in</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]) pritn(v);</span><br></pre></td></tr></table></figure>\n\n<p>警惕闭包行为对于 Dart 的异常之处。</p>\n<h3 id=\"while-amp-do-while-loop\"><a href=\"#while-amp-do-while-loop\" class=\"headerlink\" title=\"while &amp; do-while loop\"></a>while &amp; do-while loop</h3><p>while 循环基于一个循环条件，如果循环条件检测为真则执行循环体。</p>\n<p>do-while 是 while 循环的变体，区别在于 do-while 总是先进入循环体一次再进行循环条件检测。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!isDone()) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  printLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (!atEndOfPage());</span><br></pre></td></tr></table></figure>\n\n<p>###break &amp; continue</p>\n<p>相信学过 C/C++ 的应该对于 break &amp; continue ，这两个关键字是用来控制半结构化控制流。</p>\n<p>break： 跳出迭代过程。<br>contine：直接进入下一次迭代。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shutDownRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  processIncomingRequests();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> candidate = candidates[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (candidate.yearsExperience &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  candidate.interview();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3><p>switch 语句支持根据同一类型的整型，字符串编译时常量判断的分支。严格来讲，所有 switch 语句都可以使用 if-else 语句来代替，但是使用 switch 语句能将基础的分支结构变得清晰可见。</p>\n<p>每一个 case 子句都伴随一个编译时常量作为分支条件，并且以 break 语句结束；</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'two or three'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'Default'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try-catch\"></a>try-catch</h3><p>try-catch 语句的作用是捕获异常，在可能引发异常的情况下，应当使用 try-catch 来控制代码的执行流。<br>try 语句后伴随可能抛出异常的语句；<br>throw 可以显示的抛出一个对象；<br>on T catch 可以捕获一个 T 类型的对象；<br>finally 中的语句无论异常情况如何总是执行；<br>rethrow 支持将异常重新抛出；</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\"><span class=\"comment\">//  int x = -1;</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'x &gt;= 0'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">'negative x = $x'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; on <span class=\"built_in\">String</span> <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e.toString());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (o) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown Type Exception :$o'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Always execute'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h3><p>return 语句将函数运行结果交付给函数的调用者，当开发者不显示指定返回值时，默认返回 null；特别的，try-catch 语句中，return 会交付到 finally 子句。</p>\n<h3 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h3><p>assert 语句是一种调试断言的手段。在生产环境下不会运行。<br>assert(value) 接受一个布尔型的参数，一旦参数为 false 则语句会立即抛出 AssertionError 异常。</p>\n<p>这一类语句的使用是为了让开发者可以让一些事件符合预期，如以下的代码是 Text 类的构造函数原型。assert 语句能够显示地避免一些异常情况而不增大运行时的时间和空间开销。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text(</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.style,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.strutStyle,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textAlign,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.locale,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.softWrap,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.overflow,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textScaleFactor,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.maxLines,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.semanticsLabel,</span><br><span class=\"line\">&#125;) : <span class=\"keyword\">assert</span>(</span><br><span class=\"line\">       data != <span class=\"keyword\">null</span>,</span><br><span class=\"line\">       <span class=\"string\">'A non-null String must be provided to a Text widget.'</span>,</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     textSpan = <span class=\"keyword\">null</span>,</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(key: key);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"Dart-控制流语句\"><a href=\"#Dart-控制流语句\" class=\"headerlink\" title=\"Dart 控制流语句\"></a>Dart 控制流语句</h2><p>对于 Dart 而言，其代码执行的流总是从上而下逐条语句依次进行。但是可以使用一些控制流语句来实现控制 Dart 代码的执行流。</p>\n<p>有以下一些语句会直接影响 Dart 代码的执行流：</p>\n<ul>\n<li>if-else 分支</li>\n<li>for 循环</li>\n<li>while 循环</li>\n<li>break &amp; continue</li>\n<li>switch 分支</li>\n<li>try-catch 语句</li>\n<li>return 语句</li>\n<li>assert 语句</li>\n</ul>","more":"<h3 id=\"if-else\"><a href=\"#if-else\" class=\"headerlink\" title=\"if else\"></a>if else</h3><p>if else 是最基本的分支语句。</p>\n<p>if 语句通过布尔表达式来控制子句的执行与否，可选的 else 语句作为另一选项而存在。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(x &gt; 0) print(x); else print(-x);</span><br><span class=\"line\">if(x &gt; 0)&#123;</span><br><span class=\"line\">\tprint(x);</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">\tprint(-x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分支语句的判断是基于布尔表达式的值作为判断基准的，因此传入的表达式的类型推断为非 bool 类型时，会导致编译器的警告；若传入的表达式的类型不确定，也会导致运行时错误。</p>\n<h3 id=\"for-loop\"><a href=\"#for-loop\" class=\"headerlink\" title=\"for loop\"></a>for loop</h3><p>经典 for 循环的写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// for(初始化; 检测; 更新索引) 循环体</span><br><span class=\"line\">for(int index= 0;index &lt; M;index++)&#123;</span><br><span class=\"line\">\t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于实现了 Iterable 接口的类，还可以使用 for-in 语句对其进行遍历访问。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(v <span class=\"keyword\">in</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]) pritn(v);</span><br></pre></td></tr></table></figure>\n\n<p>警惕闭包行为对于 Dart 的异常之处。</p>\n<h3 id=\"while-amp-do-while-loop\"><a href=\"#while-amp-do-while-loop\" class=\"headerlink\" title=\"while &amp; do-while loop\"></a>while &amp; do-while loop</h3><p>while 循环基于一个循环条件，如果循环条件检测为真则执行循环体。</p>\n<p>do-while 是 while 循环的变体，区别在于 do-while 总是先进入循环体一次再进行循环条件检测。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (!isDone()) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  printLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (!atEndOfPage());</span><br></pre></td></tr></table></figure>\n\n<p>###break &amp; continue</p>\n<p>相信学过 C/C++ 的应该对于 break &amp; continue ，这两个关键字是用来控制半结构化控制流。</p>\n<p>break： 跳出迭代过程。<br>contine：直接进入下一次迭代。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shutDownRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  processIncomingRequests();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> candidate = candidates[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (candidate.yearsExperience &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  candidate.interview();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3><p>switch 语句支持根据同一类型的整型，字符串编译时常量判断的分支。严格来讲，所有 switch 语句都可以使用 if-else 语句来代替，但是使用 switch 语句能将基础的分支结构变得清晰可见。</p>\n<p>每一个 case 子句都伴随一个编译时常量作为分支条件，并且以 break 语句结束；</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'hello'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'two or three'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'Default'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"try-catch\"><a href=\"#try-catch\" class=\"headerlink\" title=\"try-catch\"></a>try-catch</h3><p>try-catch 语句的作用是捕获异常，在可能引发异常的情况下，应当使用 try-catch 来控制代码的执行流。<br>try 语句后伴随可能抛出异常的语句；<br>throw 可以显示的抛出一个对象；<br>on T catch 可以捕获一个 T 类型的对象；<br>finally 中的语句无论异常情况如何总是执行；<br>rethrow 支持将异常重新抛出；</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\"><span class=\"comment\">//  int x = -1;</span></span><br><span class=\"line\">  <span class=\"built_in\">int</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'x &gt;= 0'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">'negative x = $x'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; on <span class=\"built_in\">String</span> <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e.toString());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (o) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown Type Exception :$o'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Always execute'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"return\"><a href=\"#return\" class=\"headerlink\" title=\"return\"></a>return</h3><p>return 语句将函数运行结果交付给函数的调用者，当开发者不显示指定返回值时，默认返回 null；特别的，try-catch 语句中，return 会交付到 finally 子句。</p>\n<h3 id=\"assert\"><a href=\"#assert\" class=\"headerlink\" title=\"assert\"></a>assert</h3><p>assert 语句是一种调试断言的手段。在生产环境下不会运行。<br>assert(value) 接受一个布尔型的参数，一旦参数为 false 则语句会立即抛出 AssertionError 异常。</p>\n<p>这一类语句的使用是为了让开发者可以让一些事件符合预期，如以下的代码是 Text 类的构造函数原型。assert 语句能够显示地避免一些异常情况而不增大运行时的时间和空间开销。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Text(</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data, &#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.style,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.strutStyle,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textAlign,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.locale,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.softWrap,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.overflow,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textScaleFactor,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.maxLines,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.semanticsLabel,</span><br><span class=\"line\">&#125;) : <span class=\"keyword\">assert</span>(</span><br><span class=\"line\">       data != <span class=\"keyword\">null</span>,</span><br><span class=\"line\">       <span class=\"string\">'A non-null String must be provided to a Text widget.'</span>,</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     textSpan = <span class=\"keyword\">null</span>,</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(key: key);</span><br></pre></td></tr></table></figure>"},{"title":"Dart-泛型","date":"2019-06-20T16:20:00.000Z","_content":"\n### Dart 泛型（Generics）\n\n泛型指的是参数化类型，把类型像参数一样传递。泛型的好处是可以使得类和方法的定义不依赖于具体的类型。List 容器就是一个基于泛型实现的泛型类，其类型为 List<E>。\n\n```dart\nabstract class List<E> implements EfficientLengthIterable<E>{}\n```\n\n泛型有两个显然的好处：\n\n- 对于需要接受特定类型的情况，泛型能控制参数传递的类型合法性；\n- 对于逻辑上耦合的代码，使用泛型能大大减少重复的代码\n\n> 对于 Dart 而言，不存在函数的重载机制，但是很多时候能用泛型参数来解决问题。\n\n<!--more-->\n\n### 使用泛型\n\n通常来说，使用 <...> 声明一个泛型，使用一个大写字母来作为泛型参数。\n\n通常来讲：\n\n- E 表示元素\n- K，V 表示键和值\n- T 表示类\n\n实例化一个泛型类时，可以选择性的为泛型类传递泛型参数，不传递参数时，默认类型参数为 dynamic。\n\n```dart\nList listA = new List();//  List<dynamic>\nList<int> listB = new List();//  List<int>\nList listC = new List<int>();//  List<int>\nList<int> listD = new List<int>();//  List<int>\n```\n\n### 限制泛型的使用 \n\n使用泛型可以帮我们减少重复代码的使用，但是有时候只需要为某一个类的子类提供泛型，可以使用 extends 关键字来实现。\n\n```dart\nclass Foo<T extends num> {\n  T value;\n\n  Foo([this.value]);\n\n  T addOne() {\n    this.value += 1;\n  }\n}\n// Foo can only receive num class as type parameter.\nvoid main() {\n  Foo foo  = new Foo();//  Foo<num>\n  Foo<int> fooA = new Foo();//  Foo<int>\n  Foo<double> fooB= new Foo();//  Foo<double>\n//  Foo<String> fooC; //String is not a subtype of num\n}\n```\n\n### 泛型函数\n\n泛型语法几乎可以用户函数的任何成分：\n\n- 函数的参数列表\n- 函数实现中的类型声明\n- 函数的返回类型\n- 作为函数内部中泛型类和泛型方法的参数\n- 作为 Type 对象\n- 作为 is 语句的右操作数\n\n<https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md>\n\n","source":"_posts/Dart-泛型.md","raw":"---\ntitle: Dart-泛型\ndate: 2019-06-21 00:20:00\ntags: Dart\n---\n\n### Dart 泛型（Generics）\n\n泛型指的是参数化类型，把类型像参数一样传递。泛型的好处是可以使得类和方法的定义不依赖于具体的类型。List 容器就是一个基于泛型实现的泛型类，其类型为 List<E>。\n\n```dart\nabstract class List<E> implements EfficientLengthIterable<E>{}\n```\n\n泛型有两个显然的好处：\n\n- 对于需要接受特定类型的情况，泛型能控制参数传递的类型合法性；\n- 对于逻辑上耦合的代码，使用泛型能大大减少重复的代码\n\n> 对于 Dart 而言，不存在函数的重载机制，但是很多时候能用泛型参数来解决问题。\n\n<!--more-->\n\n### 使用泛型\n\n通常来说，使用 <...> 声明一个泛型，使用一个大写字母来作为泛型参数。\n\n通常来讲：\n\n- E 表示元素\n- K，V 表示键和值\n- T 表示类\n\n实例化一个泛型类时，可以选择性的为泛型类传递泛型参数，不传递参数时，默认类型参数为 dynamic。\n\n```dart\nList listA = new List();//  List<dynamic>\nList<int> listB = new List();//  List<int>\nList listC = new List<int>();//  List<int>\nList<int> listD = new List<int>();//  List<int>\n```\n\n### 限制泛型的使用 \n\n使用泛型可以帮我们减少重复代码的使用，但是有时候只需要为某一个类的子类提供泛型，可以使用 extends 关键字来实现。\n\n```dart\nclass Foo<T extends num> {\n  T value;\n\n  Foo([this.value]);\n\n  T addOne() {\n    this.value += 1;\n  }\n}\n// Foo can only receive num class as type parameter.\nvoid main() {\n  Foo foo  = new Foo();//  Foo<num>\n  Foo<int> fooA = new Foo();//  Foo<int>\n  Foo<double> fooB= new Foo();//  Foo<double>\n//  Foo<String> fooC; //String is not a subtype of num\n}\n```\n\n### 泛型函数\n\n泛型语法几乎可以用户函数的任何成分：\n\n- 函数的参数列表\n- 函数实现中的类型声明\n- 函数的返回类型\n- 作为函数内部中泛型类和泛型方法的参数\n- 作为 Type 对象\n- 作为 is 语句的右操作数\n\n<https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md>\n\n","slug":"Dart-泛型","published":1,"updated":"2020-03-15T21:05:07.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wc000d29fygj0xz7cq","content":"<h3 id=\"Dart-泛型（Generics）\"><a href=\"#Dart-泛型（Generics）\" class=\"headerlink\" title=\"Dart 泛型（Generics）\"></a>Dart 泛型（Generics）</h3><p>泛型指的是参数化类型，把类型像参数一样传递。泛型的好处是可以使得类和方法的定义不依赖于具体的类型。List 容器就是一个基于泛型实现的泛型类，其类型为 List<e>。</e></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">EfficientLengthIterable</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>泛型有两个显然的好处：</p>\n<ul>\n<li>对于需要接受特定类型的情况，泛型能控制参数传递的类型合法性；</li>\n<li>对于逻辑上耦合的代码，使用泛型能大大减少重复的代码</li>\n</ul>\n<blockquote>\n<p>对于 Dart 而言，不存在函数的重载机制，但是很多时候能用泛型参数来解决问题。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h3><p>通常来说，使用 &lt;…&gt; 声明一个泛型，使用一个大写字母来作为泛型参数。</p>\n<p>通常来讲：</p>\n<ul>\n<li>E 表示元素</li>\n<li>K，V 表示键和值</li>\n<li>T 表示类</li>\n</ul>\n<p>实例化一个泛型类时，可以选择性的为泛型类传递泛型参数，不传递参数时，默认类型参数为 dynamic。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span> listA = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>();<span class=\"comment\">//  List&lt;dynamic&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; listB = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>();<span class=\"comment\">//  List&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span> listC = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt;();<span class=\"comment\">//  List&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; listD = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt;();<span class=\"comment\">//  List&lt;int&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制泛型的使用\"><a href=\"#限制泛型的使用\" class=\"headerlink\" title=\"限制泛型的使用\"></a>限制泛型的使用</h3><p>使用泛型可以帮我们减少重复代码的使用，但是有时候只需要为某一个类的子类提供泛型，可以使用 extends 关键字来实现。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">num</span>&gt; </span>&#123;</span><br><span class=\"line\">  T value;</span><br><span class=\"line\"></span><br><span class=\"line\">  Foo([<span class=\"keyword\">this</span>.value]);</span><br><span class=\"line\"></span><br><span class=\"line\">  T addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value += <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Foo can only receive num class as type parameter.</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  Foo foo  = <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//  Foo&lt;num&gt;</span></span><br><span class=\"line\">  Foo&lt;<span class=\"built_in\">int</span>&gt; fooA = <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//  Foo&lt;int&gt;</span></span><br><span class=\"line\">  Foo&lt;<span class=\"built_in\">double</span>&gt; fooB= <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//  Foo&lt;double&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//  Foo&lt;String&gt; fooC; //String is not a subtype of num</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型函数\"><a href=\"#泛型函数\" class=\"headerlink\" title=\"泛型函数\"></a>泛型函数</h3><p>泛型语法几乎可以用户函数的任何成分：</p>\n<ul>\n<li>函数的参数列表</li>\n<li>函数实现中的类型声明</li>\n<li>函数的返回类型</li>\n<li>作为函数内部中泛型类和泛型方法的参数</li>\n<li>作为 Type 对象</li>\n<li>作为 is 语句的右操作数</li>\n</ul>\n<p><a href=\"https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md\" target=\"_blank\" rel=\"noopener\">https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Dart-泛型（Generics）\"><a href=\"#Dart-泛型（Generics）\" class=\"headerlink\" title=\"Dart 泛型（Generics）\"></a>Dart 泛型（Generics）</h3><p>泛型指的是参数化类型，把类型像参数一样传递。泛型的好处是可以使得类和方法的定义不依赖于具体的类型。List 容器就是一个基于泛型实现的泛型类，其类型为 List<e>。</e></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">EfficientLengthIterable</span>&lt;<span class=\"title\">E</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>泛型有两个显然的好处：</p>\n<ul>\n<li>对于需要接受特定类型的情况，泛型能控制参数传递的类型合法性；</li>\n<li>对于逻辑上耦合的代码，使用泛型能大大减少重复的代码</li>\n</ul>\n<blockquote>\n<p>对于 Dart 而言，不存在函数的重载机制，但是很多时候能用泛型参数来解决问题。</p>\n</blockquote>","more":"<h3 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h3><p>通常来说，使用 &lt;…&gt; 声明一个泛型，使用一个大写字母来作为泛型参数。</p>\n<p>通常来讲：</p>\n<ul>\n<li>E 表示元素</li>\n<li>K，V 表示键和值</li>\n<li>T 表示类</li>\n</ul>\n<p>实例化一个泛型类时，可以选择性的为泛型类传递泛型参数，不传递参数时，默认类型参数为 dynamic。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span> listA = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>();<span class=\"comment\">//  List&lt;dynamic&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; listB = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>();<span class=\"comment\">//  List&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span> listC = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt;();<span class=\"comment\">//  List&lt;int&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt; listD = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">int</span>&gt;();<span class=\"comment\">//  List&lt;int&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制泛型的使用\"><a href=\"#限制泛型的使用\" class=\"headerlink\" title=\"限制泛型的使用\"></a>限制泛型的使用</h3><p>使用泛型可以帮我们减少重复代码的使用，但是有时候只需要为某一个类的子类提供泛型，可以使用 extends 关键字来实现。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">num</span>&gt; </span>&#123;</span><br><span class=\"line\">  T value;</span><br><span class=\"line\"></span><br><span class=\"line\">  Foo([<span class=\"keyword\">this</span>.value]);</span><br><span class=\"line\"></span><br><span class=\"line\">  T addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value += <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Foo can only receive num class as type parameter.</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  Foo foo  = <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//  Foo&lt;num&gt;</span></span><br><span class=\"line\">  Foo&lt;<span class=\"built_in\">int</span>&gt; fooA = <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//  Foo&lt;int&gt;</span></span><br><span class=\"line\">  Foo&lt;<span class=\"built_in\">double</span>&gt; fooB= <span class=\"keyword\">new</span> Foo();<span class=\"comment\">//  Foo&lt;double&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//  Foo&lt;String&gt; fooC; //String is not a subtype of num</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型函数\"><a href=\"#泛型函数\" class=\"headerlink\" title=\"泛型函数\"></a>泛型函数</h3><p>泛型语法几乎可以用户函数的任何成分：</p>\n<ul>\n<li>函数的参数列表</li>\n<li>函数实现中的类型声明</li>\n<li>函数的返回类型</li>\n<li>作为函数内部中泛型类和泛型方法的参数</li>\n<li>作为 Type 对象</li>\n<li>作为 is 语句的右操作数</li>\n</ul>\n<p><a href=\"https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md\" target=\"_blank\" rel=\"noopener\">https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md</a></p>"},{"title":"Dart-Equal-Explore","date":"2019-05-09T20:40:48.000Z","_content":"\n### Dart中的相等判别\n\n> 在 Dart 的公共基类 Object 类中，== 操作符调用 dart:core 的 identical() 方法，判别的依据是左右操作数是否为同一个对象，与一般情况下的相等有所区别；开发者在使用 == 进行判别时应当根据自身需要对 == 操作符和 hashCode 字段进行覆盖重写。\n\n<!--more-->\n\n### 相等的定义\n\n相等在数学上的定义中有一些性质：\n\n- 自反性：对于任意量 a 而言，都有 a = a；\n- 对称性：对于任意量 a 和 b 而言，如果 a = b，则 b = a；\n- 传递性：对于任意量 a, b 和 c 而言，如果 a = b 且 b = c，则 a = c；\n\n在 Dart 语法中，所有对象都是 Object 类的子类。Object 类当中的 == 方法当且仅当该对象与另一对象是同一对象时返回 true，否则返回 false；因此每个对象沿用了父类的 == 方法。\n\n在 Object 类中，存在 [runtimeType](https://api.dartlang.org/stable/2.3.0/dart-core/Object/runtimeType.html) 和 [hashCode](https://api.dartlang.org/stable/2.3.0/dart-core/Object/hashCode.html) 两个字段，在不同的对象中，hashCode 不相同\n\n即使覆盖了 Object  对象中的 == 方法，hashCode 值也不会相同\n\n作为开发者应当同时覆盖 hashCode 和 == 方法。\n\n\n\n```dart\n// When developer override the [==] operator, the [hashCode] property can be different, so that developer should override these properties at the same time. \n// == 操作符和 hashCode 字段应当同时被覆盖。\nclass Animal {\n  int value;\n  Animal([int value = 0]) {\n    this.value = value;\n  }\n  operator ==(animal) =>\n      (animal is Animal && animal.value == this.value) ? true : false;\n  get hashCode => this.value;\n}\n\nclass Cat {\n  int value;\n  Cat([int value = 0]) {\n    this.value = value;\n  }\n  get hashCode => value;\n}\n\nclass Dog {\n  int value;\n  Dog([int value = 0]) {\n    this.value = this.value;\n  }\n  operator ==(dog) => (dog is Dog && this.value == dog.value) ? true : false;\n}\n\nvoid main() {\n  Object object1 = new Object();\n  Object object2 = new Object();\n  print(object1==object2);\n  print(\"object1.hashCode: \" +\n      object1.hashCode.toString() +\n      \"\\nobject2.hashCode：\" +\n      object2.hashCode.toString());\n  print(identical(object1, object2));\n  print('');\n  \n\tCat cat1 = new Cat(1);\n\tCat cat2 = new Cat(1);\n  print(cat1 == cat2);\n  print(\"cat1.hashCode: \" +\n      cat1.hashCode.toString() +\n      \"\\ncat2.hashCode：\" +\n      cat2.hashCode.toString());\n  print(identical(cat1, cat2));\n  print('');\n  \n\tDog dog1 = new Dog(1);\n\tDog dog2 = new Dog(1);\n  print(dog1==dog2);\n  print(\"dog1.hashCode: \" +\n      dog1.hashCode.toString() +\n      \"\\ndog2.hashCode：\" +\n      dog2.hashCode.toString());\n  print(identical(dog1, dog2));\n  print('');\n  \n\tAnimal animal1 = new Animal(1);\n\tAnimal animal2 = new Animal(1);\n  print(animal1==animal2);\n  print(\"animal1.hashCode: \" +\n      animal1.hashCode.toString() +\n      \"\\nanimal2.hashCode：\" +\n      animal2.hashCode.toString());\n  print(identical(animal1, animal2));\n  print('');\n  \n// Specially，you may find the output below show that identical(animal1,animal3) return true. That is because animal1 and animal3 are essentially the same object. The reference of first 'new Animal(1)' was assigned to animal1 and animal3 by the = operator, so that animal1 and animal3 point to the same object.\n  Animal animal3 = animal1;\n  print(identical(animal3, animal1));\n  print(animal1.value);\n  animal3.value = 2;\n  print(animal1.value);  \n  print(identical(animal3, animal1));\n}\n\n```\n\n\n\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/11f88dc36b684c6f4ff33a23b56b2fba)\n\n开发者需要谨慎地同时重写 == 操作符和 hashCode 字段，在一般情况下 Object 的 == 操作符绑定了 dart:core 的 identical() 方法，该方法的作用是判断左右值是否为同一对象。特别地，即使开发者同时重写了 == 操作符和 hashCode  字段，identical 方法在判别两个字段相同的实例时仍然会返回 false（本质上，完全相同的两个对象也具有不同的地址；identical 方法只在对象引用指向同一内存时返回 true 如 animal1 和 animal3，该方法针对的是同一个对象）。 ","source":"_posts/Dart-相等的探索.md","raw":"---\ntitle: Dart-Equal-Explore\ndate: 2019-05-10 04:40:48\ntags: Dart\n---\n\n### Dart中的相等判别\n\n> 在 Dart 的公共基类 Object 类中，== 操作符调用 dart:core 的 identical() 方法，判别的依据是左右操作数是否为同一个对象，与一般情况下的相等有所区别；开发者在使用 == 进行判别时应当根据自身需要对 == 操作符和 hashCode 字段进行覆盖重写。\n\n<!--more-->\n\n### 相等的定义\n\n相等在数学上的定义中有一些性质：\n\n- 自反性：对于任意量 a 而言，都有 a = a；\n- 对称性：对于任意量 a 和 b 而言，如果 a = b，则 b = a；\n- 传递性：对于任意量 a, b 和 c 而言，如果 a = b 且 b = c，则 a = c；\n\n在 Dart 语法中，所有对象都是 Object 类的子类。Object 类当中的 == 方法当且仅当该对象与另一对象是同一对象时返回 true，否则返回 false；因此每个对象沿用了父类的 == 方法。\n\n在 Object 类中，存在 [runtimeType](https://api.dartlang.org/stable/2.3.0/dart-core/Object/runtimeType.html) 和 [hashCode](https://api.dartlang.org/stable/2.3.0/dart-core/Object/hashCode.html) 两个字段，在不同的对象中，hashCode 不相同\n\n即使覆盖了 Object  对象中的 == 方法，hashCode 值也不会相同\n\n作为开发者应当同时覆盖 hashCode 和 == 方法。\n\n\n\n```dart\n// When developer override the [==] operator, the [hashCode] property can be different, so that developer should override these properties at the same time. \n// == 操作符和 hashCode 字段应当同时被覆盖。\nclass Animal {\n  int value;\n  Animal([int value = 0]) {\n    this.value = value;\n  }\n  operator ==(animal) =>\n      (animal is Animal && animal.value == this.value) ? true : false;\n  get hashCode => this.value;\n}\n\nclass Cat {\n  int value;\n  Cat([int value = 0]) {\n    this.value = value;\n  }\n  get hashCode => value;\n}\n\nclass Dog {\n  int value;\n  Dog([int value = 0]) {\n    this.value = this.value;\n  }\n  operator ==(dog) => (dog is Dog && this.value == dog.value) ? true : false;\n}\n\nvoid main() {\n  Object object1 = new Object();\n  Object object2 = new Object();\n  print(object1==object2);\n  print(\"object1.hashCode: \" +\n      object1.hashCode.toString() +\n      \"\\nobject2.hashCode：\" +\n      object2.hashCode.toString());\n  print(identical(object1, object2));\n  print('');\n  \n\tCat cat1 = new Cat(1);\n\tCat cat2 = new Cat(1);\n  print(cat1 == cat2);\n  print(\"cat1.hashCode: \" +\n      cat1.hashCode.toString() +\n      \"\\ncat2.hashCode：\" +\n      cat2.hashCode.toString());\n  print(identical(cat1, cat2));\n  print('');\n  \n\tDog dog1 = new Dog(1);\n\tDog dog2 = new Dog(1);\n  print(dog1==dog2);\n  print(\"dog1.hashCode: \" +\n      dog1.hashCode.toString() +\n      \"\\ndog2.hashCode：\" +\n      dog2.hashCode.toString());\n  print(identical(dog1, dog2));\n  print('');\n  \n\tAnimal animal1 = new Animal(1);\n\tAnimal animal2 = new Animal(1);\n  print(animal1==animal2);\n  print(\"animal1.hashCode: \" +\n      animal1.hashCode.toString() +\n      \"\\nanimal2.hashCode：\" +\n      animal2.hashCode.toString());\n  print(identical(animal1, animal2));\n  print('');\n  \n// Specially，you may find the output below show that identical(animal1,animal3) return true. That is because animal1 and animal3 are essentially the same object. The reference of first 'new Animal(1)' was assigned to animal1 and animal3 by the = operator, so that animal1 and animal3 point to the same object.\n  Animal animal3 = animal1;\n  print(identical(animal3, animal1));\n  print(animal1.value);\n  animal3.value = 2;\n  print(animal1.value);  \n  print(identical(animal3, animal1));\n}\n\n```\n\n\n\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/11f88dc36b684c6f4ff33a23b56b2fba)\n\n开发者需要谨慎地同时重写 == 操作符和 hashCode 字段，在一般情况下 Object 的 == 操作符绑定了 dart:core 的 identical() 方法，该方法的作用是判断左右值是否为同一对象。特别地，即使开发者同时重写了 == 操作符和 hashCode  字段，identical 方法在判别两个字段相同的实例时仍然会返回 false（本质上，完全相同的两个对象也具有不同的地址；identical 方法只在对象引用指向同一内存时返回 true 如 animal1 和 animal3，该方法针对的是同一个对象）。 ","slug":"Dart-相等的探索","published":1,"updated":"2020-03-15T21:05:07.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wd000e29fyom8hfrcc","content":"<h3 id=\"Dart中的相等判别\"><a href=\"#Dart中的相等判别\" class=\"headerlink\" title=\"Dart中的相等判别\"></a>Dart中的相等判别</h3><blockquote>\n<p>在 Dart 的公共基类 Object 类中，== 操作符调用 dart:core 的 identical() 方法，判别的依据是左右操作数是否为同一个对象，与一般情况下的相等有所区别；开发者在使用 == 进行判别时应当根据自身需要对 == 操作符和 hashCode 字段进行覆盖重写。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"相等的定义\"><a href=\"#相等的定义\" class=\"headerlink\" title=\"相等的定义\"></a>相等的定义</h3><p>相等在数学上的定义中有一些性质：</p>\n<ul>\n<li>自反性：对于任意量 a 而言，都有 a = a；</li>\n<li>对称性：对于任意量 a 和 b 而言，如果 a = b，则 b = a；</li>\n<li>传递性：对于任意量 a, b 和 c 而言，如果 a = b 且 b = c，则 a = c；</li>\n</ul>\n<p>在 Dart 语法中，所有对象都是 Object 类的子类。Object 类当中的 == 方法当且仅当该对象与另一对象是同一对象时返回 true，否则返回 false；因此每个对象沿用了父类的 == 方法。</p>\n<p>在 Object 类中，存在 <a href=\"https://api.dartlang.org/stable/2.3.0/dart-core/Object/runtimeType.html\" target=\"_blank\" rel=\"noopener\">runtimeType</a> 和 <a href=\"https://api.dartlang.org/stable/2.3.0/dart-core/Object/hashCode.html\" target=\"_blank\" rel=\"noopener\">hashCode</a> 两个字段，在不同的对象中，hashCode 不相同</p>\n<p>即使覆盖了 Object  对象中的 == 方法，hashCode 值也不会相同</p>\n<p>作为开发者应当同时覆盖 hashCode 和 == 方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When developer override the [==] operator, the [hashCode] property can be different, so that developer should override these properties at the same time. </span></span><br><span class=\"line\"><span class=\"comment\">// == 操作符和 hashCode 字段应当同时被覆盖。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">  Animal([<span class=\"built_in\">int</span> value = <span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">operator</span> ==(animal) =&gt;</span><br><span class=\"line\">      (animal <span class=\"keyword\">is</span> Animal &amp;&amp; animal.value == <span class=\"keyword\">this</span>.value) ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> hashCode =&gt; <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">  Cat([<span class=\"built_in\">int</span> value = <span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> hashCode =&gt; value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">  Dog([<span class=\"built_in\">int</span> value = <span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">operator</span> ==(dog) =&gt; (dog <span class=\"keyword\">is</span> Dog &amp;&amp; <span class=\"keyword\">this</span>.value == dog.value) ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> object1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> object2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(object1==object2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"object1.hashCode: \"</span> +</span><br><span class=\"line\">      object1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\nobject2.hashCode：\"</span> +</span><br><span class=\"line\">      object2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(object1, object2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tCat cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tCat cat2 = <span class=\"keyword\">new</span> Cat(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(cat1 == cat2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"cat1.hashCode: \"</span> +</span><br><span class=\"line\">      cat1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\ncat2.hashCode：\"</span> +</span><br><span class=\"line\">      cat2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(cat1, cat2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tDog dog1 = <span class=\"keyword\">new</span> Dog(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tDog dog2 = <span class=\"keyword\">new</span> Dog(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(dog1==dog2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"dog1.hashCode: \"</span> +</span><br><span class=\"line\">      dog1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\ndog2.hashCode：\"</span> +</span><br><span class=\"line\">      dog2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(dog1, dog2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tAnimal animal1 = <span class=\"keyword\">new</span> Animal(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tAnimal animal2 = <span class=\"keyword\">new</span> Animal(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(animal1==animal2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"animal1.hashCode: \"</span> +</span><br><span class=\"line\">      animal1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\nanimal2.hashCode：\"</span> +</span><br><span class=\"line\">      animal2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(animal1, animal2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// Specially，you may find the output below show that identical(animal1,animal3) return true. That is because animal1 and animal3 are essentially the same object. The reference of first 'new Animal(1)' was assigned to animal1 and animal3 by the = operator, so that animal1 and animal3 point to the same object.</span></span><br><span class=\"line\">  Animal animal3 = animal1;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(animal3, animal1));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(animal1.value);</span><br><span class=\"line\">  animal3.value = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(animal1.value);  </span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(animal3, animal1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/11f88dc36b684c6f4ff33a23b56b2fba\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n<p>开发者需要谨慎地同时重写 == 操作符和 hashCode 字段，在一般情况下 Object 的 == 操作符绑定了 dart:core 的 identical() 方法，该方法的作用是判断左右值是否为同一对象。特别地，即使开发者同时重写了 == 操作符和 hashCode  字段，identical 方法在判别两个字段相同的实例时仍然会返回 false（本质上，完全相同的两个对象也具有不同的地址；identical 方法只在对象引用指向同一内存时返回 true 如 animal1 和 animal3，该方法针对的是同一个对象）。 </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Dart中的相等判别\"><a href=\"#Dart中的相等判别\" class=\"headerlink\" title=\"Dart中的相等判别\"></a>Dart中的相等判别</h3><blockquote>\n<p>在 Dart 的公共基类 Object 类中，== 操作符调用 dart:core 的 identical() 方法，判别的依据是左右操作数是否为同一个对象，与一般情况下的相等有所区别；开发者在使用 == 进行判别时应当根据自身需要对 == 操作符和 hashCode 字段进行覆盖重写。</p>\n</blockquote>","more":"<h3 id=\"相等的定义\"><a href=\"#相等的定义\" class=\"headerlink\" title=\"相等的定义\"></a>相等的定义</h3><p>相等在数学上的定义中有一些性质：</p>\n<ul>\n<li>自反性：对于任意量 a 而言，都有 a = a；</li>\n<li>对称性：对于任意量 a 和 b 而言，如果 a = b，则 b = a；</li>\n<li>传递性：对于任意量 a, b 和 c 而言，如果 a = b 且 b = c，则 a = c；</li>\n</ul>\n<p>在 Dart 语法中，所有对象都是 Object 类的子类。Object 类当中的 == 方法当且仅当该对象与另一对象是同一对象时返回 true，否则返回 false；因此每个对象沿用了父类的 == 方法。</p>\n<p>在 Object 类中，存在 <a href=\"https://api.dartlang.org/stable/2.3.0/dart-core/Object/runtimeType.html\" target=\"_blank\" rel=\"noopener\">runtimeType</a> 和 <a href=\"https://api.dartlang.org/stable/2.3.0/dart-core/Object/hashCode.html\" target=\"_blank\" rel=\"noopener\">hashCode</a> 两个字段，在不同的对象中，hashCode 不相同</p>\n<p>即使覆盖了 Object  对象中的 == 方法，hashCode 值也不会相同</p>\n<p>作为开发者应当同时覆盖 hashCode 和 == 方法。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When developer override the [==] operator, the [hashCode] property can be different, so that developer should override these properties at the same time. </span></span><br><span class=\"line\"><span class=\"comment\">// == 操作符和 hashCode 字段应当同时被覆盖。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">  Animal([<span class=\"built_in\">int</span> value = <span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">operator</span> ==(animal) =&gt;</span><br><span class=\"line\">      (animal <span class=\"keyword\">is</span> Animal &amp;&amp; animal.value == <span class=\"keyword\">this</span>.value) ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> hashCode =&gt; <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">  Cat([<span class=\"built_in\">int</span> value = <span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> hashCode =&gt; value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">  Dog([<span class=\"built_in\">int</span> value = <span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">operator</span> ==(dog) =&gt; (dog <span class=\"keyword\">is</span> Dog &amp;&amp; <span class=\"keyword\">this</span>.value == dog.value) ? <span class=\"keyword\">true</span> : <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> object1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> object2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(object1==object2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"object1.hashCode: \"</span> +</span><br><span class=\"line\">      object1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\nobject2.hashCode：\"</span> +</span><br><span class=\"line\">      object2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(object1, object2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tCat cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tCat cat2 = <span class=\"keyword\">new</span> Cat(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(cat1 == cat2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"cat1.hashCode: \"</span> +</span><br><span class=\"line\">      cat1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\ncat2.hashCode：\"</span> +</span><br><span class=\"line\">      cat2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(cat1, cat2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tDog dog1 = <span class=\"keyword\">new</span> Dog(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tDog dog2 = <span class=\"keyword\">new</span> Dog(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(dog1==dog2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"dog1.hashCode: \"</span> +</span><br><span class=\"line\">      dog1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\ndog2.hashCode：\"</span> +</span><br><span class=\"line\">      dog2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(dog1, dog2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">\tAnimal animal1 = <span class=\"keyword\">new</span> Animal(<span class=\"number\">1</span>);</span><br><span class=\"line\">\tAnimal animal2 = <span class=\"keyword\">new</span> Animal(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(animal1==animal2);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"animal1.hashCode: \"</span> +</span><br><span class=\"line\">      animal1.hashCode.toString() +</span><br><span class=\"line\">      <span class=\"string\">\"\\nanimal2.hashCode：\"</span> +</span><br><span class=\"line\">      animal2.hashCode.toString());</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(animal1, animal2));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// Specially，you may find the output below show that identical(animal1,animal3) return true. That is because animal1 and animal3 are essentially the same object. The reference of first 'new Animal(1)' was assigned to animal1 and animal3 by the = operator, so that animal1 and animal3 point to the same object.</span></span><br><span class=\"line\">  Animal animal3 = animal1;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(animal3, animal1));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(animal1.value);</span><br><span class=\"line\">  animal3.value = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(animal1.value);  </span><br><span class=\"line\">  <span class=\"built_in\">print</span>(identical(animal3, animal1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/11f88dc36b684c6f4ff33a23b56b2fba\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n<p>开发者需要谨慎地同时重写 == 操作符和 hashCode 字段，在一般情况下 Object 的 == 操作符绑定了 dart:core 的 identical() 方法，该方法的作用是判断左右值是否为同一对象。特别地，即使开发者同时重写了 == 操作符和 hashCode  字段，identical 方法在判别两个字段相同的实例时仍然会返回 false（本质上，完全相同的两个对象也具有不同的地址；identical 方法只在对象引用指向同一内存时返回 true 如 animal1 和 animal3，该方法针对的是同一个对象）。 </p>"},{"title":"Dart-类型","date":"2019-06-22T09:47:14.000Z","_content":"\n## Dart 类型\n\nDart 类型的性质在 Dart 2 发布前后使截然不同的，本篇讨论了 Dart 类型的各种性质。\n\n<!--more-->\n\n### 可选类型（Dart 2 之前）\n\nDart 中的可选类型的特征指的是：\n\n- 类型在语法层面上是可选的；\n- 类型对运行时语义没有影响。\n\nDart 是动态类型的体现在开发者可以编写完全没有类型注解的程序，而不会有任何区别。\n\n> Dart 类型注解不会影响语义。\n\n### 类型注解\n\n尽管由于可选类型的原因，类型注解不是必须的，但是类型注解仍然有很多好处：\n\n- 开发者更好的阅读代码\n- 帮助 IDE 识别类型\n- 帮助静态检查器在初期检查错误\n\n### 类型推断\n\n分析器可以推断参数的类型，一旦推断类型成为难题时，最终推断为 dynamic 。\n\n- 输入参数推断：根据上下文推断\n- 静态成员的推断\n- 局部变量的推断：根据初始化推断\n- 类成员的推断：\n\n尽管类型推断一直存在，但是如果推断的结果与开发者的意图不符合，还是应该使用显示的类型注解。\n\n### 类型安全\n\nDart 的类型安全基于静态类型检查和运行时检查，二者确保变量值于变量的类型匹配。\n\n- 静态类型分析能的使用 Dart 的静态分析器在执行前找出显著的类型安全错误。\n\n- 运行时检查能使用 Dart VM 和 dartdevc 等工具来处理静态分析器无法捕获的安全问题。\n\n```dart\nvoid main() {\n  var list = new List<TempFile>.from(\n      [new TempFile(), new BankAccount()]);\n  cleanUp(list);\n}\nvoid cleanUp(List<TempFile> files) =>\n    files.forEach((f) => f.delete());\nclass TempFile {\n  void delete() => print('TempFile deleted.');\n}\nclass BankAccount {\n  void delete() => print('BankAccount deleted. Whoops!');\n}\n// 静态分析其无法捕获这个异常\n```\n\n### Dart 不支持函数重载\n\n\n由于 Dart 中类型不会影响语义，也不会改变 Dart 代码的行为，因此函数重载也无法在 Dart 中实现，可选的代替方案是：\n\n1. 使用 dynamic 类型参数接收并使用 is 语句进行类型检查。\n2. 为每一个不同的函数提供不同的函数名称。\n\n```dart\nclass Foo {\n  void bar() => print('bar()');\n  void bar(String name) => print('bar($name)');\n  void bar(int number) => print('bar($number)');\n}\n\nvoid main() {\n  dynamic foo = new Foo();\n\t\n\n  // OK\n  foo.bar();\n\n  // Runtime error: Ambiguous dispatch. 2 or more implementations of `bar` exist.\n  foo.bar('Hello');\n}\n```\n> 参见 Dart 官方对函数重载的解释 [https://github.com/dart-lang/sdk/issues/26488](https://github.com/dart-lang/sdk/issues/26488)\n\n\nDart 的类型声明通常情况下只发挥了注解的功能：能够为阅读代码的人提供类型的的注释\n\n```dart\nint i ;\nint j = 0;\nsum(a,b) => a+b;\n\nvoid main(){\n  print(sum(i,j));\n}\n// These code will cause : NoSuchMethodError: The method '+' was called on null.\n```\n这是由于变量 i 在不进行初始化的时候分配了 null 值，此时 Null 类并没有对 + 操作符进行重载。\n\n### 类型检查\n\nDart 2 的更新是加入了类型推断机制\n\n通常来讲，一些事件会触发 Dart 的类型检查机制。\n\n- 执行复制操作\n- 传递实参给函数\n- 函数传递一个返回值\n\n\n```dart\nclass Animal{\n}\nclass Cat extends Animal{\n  Cat(this.say);\n  String say = \"miao\";\n}\n\nvoid main(){\n  List<Animal> animals = [new Animal(),new Cat(\"1\"),new Cat(\"2\")];\n  //  This statement will not cause an exception.\n  //  We dont need a cast to state the type of animal[2];  \n  Cat cat  = animals[2];\n  print(cat.say);\n  try{\n    Cat anotherCat = animals[0];\n  }catch(e){\n    print(e.toString());\n  }\n}\n```\n\n### 接口类型\n\nDart 没有声明接口的语法，因为 Dart 类都存在隐式接口，任意一个类都可以使用 implements 关键字来实现一个接口。\n\n实现一个接口可以获得一个类的实例成员，但是并不会继承接口的实现，因此实现一个接口意味着需要同时提供所有接口的具体实现。\n\n```dart\n// A person. The implicit interface contains greet().\nclass Person {\n  // In the interface, but visible only in this library.\n  final _name;\n\n  // Not in the interface, since this is a constructor.\n  Person(this._name);\n\n  // In the interface.\n  String greet(String who) => 'Hello, $who. I am $_name.';\n}\n\n// An implementation of the Person interface.\nclass Impostor implements Person {\n  get _name => '';\n\n  String greet(String who) => 'Hi $who. Do you know who I am?';\n}\n\nString greetBob(Person person) => person.greet('Bob');\n\nvoid main() {\n  print(greetBob(Person('Kathy')));\n  print(greetBob(Impostor()));\n}\n```\n\n","source":"_posts/Dart-类型.md","raw":"---\ntitle: Dart-类型\ndate: 2019-06-22 17:47:14\ntags: Dart\n---\n\n## Dart 类型\n\nDart 类型的性质在 Dart 2 发布前后使截然不同的，本篇讨论了 Dart 类型的各种性质。\n\n<!--more-->\n\n### 可选类型（Dart 2 之前）\n\nDart 中的可选类型的特征指的是：\n\n- 类型在语法层面上是可选的；\n- 类型对运行时语义没有影响。\n\nDart 是动态类型的体现在开发者可以编写完全没有类型注解的程序，而不会有任何区别。\n\n> Dart 类型注解不会影响语义。\n\n### 类型注解\n\n尽管由于可选类型的原因，类型注解不是必须的，但是类型注解仍然有很多好处：\n\n- 开发者更好的阅读代码\n- 帮助 IDE 识别类型\n- 帮助静态检查器在初期检查错误\n\n### 类型推断\n\n分析器可以推断参数的类型，一旦推断类型成为难题时，最终推断为 dynamic 。\n\n- 输入参数推断：根据上下文推断\n- 静态成员的推断\n- 局部变量的推断：根据初始化推断\n- 类成员的推断：\n\n尽管类型推断一直存在，但是如果推断的结果与开发者的意图不符合，还是应该使用显示的类型注解。\n\n### 类型安全\n\nDart 的类型安全基于静态类型检查和运行时检查，二者确保变量值于变量的类型匹配。\n\n- 静态类型分析能的使用 Dart 的静态分析器在执行前找出显著的类型安全错误。\n\n- 运行时检查能使用 Dart VM 和 dartdevc 等工具来处理静态分析器无法捕获的安全问题。\n\n```dart\nvoid main() {\n  var list = new List<TempFile>.from(\n      [new TempFile(), new BankAccount()]);\n  cleanUp(list);\n}\nvoid cleanUp(List<TempFile> files) =>\n    files.forEach((f) => f.delete());\nclass TempFile {\n  void delete() => print('TempFile deleted.');\n}\nclass BankAccount {\n  void delete() => print('BankAccount deleted. Whoops!');\n}\n// 静态分析其无法捕获这个异常\n```\n\n### Dart 不支持函数重载\n\n\n由于 Dart 中类型不会影响语义，也不会改变 Dart 代码的行为，因此函数重载也无法在 Dart 中实现，可选的代替方案是：\n\n1. 使用 dynamic 类型参数接收并使用 is 语句进行类型检查。\n2. 为每一个不同的函数提供不同的函数名称。\n\n```dart\nclass Foo {\n  void bar() => print('bar()');\n  void bar(String name) => print('bar($name)');\n  void bar(int number) => print('bar($number)');\n}\n\nvoid main() {\n  dynamic foo = new Foo();\n\t\n\n  // OK\n  foo.bar();\n\n  // Runtime error: Ambiguous dispatch. 2 or more implementations of `bar` exist.\n  foo.bar('Hello');\n}\n```\n> 参见 Dart 官方对函数重载的解释 [https://github.com/dart-lang/sdk/issues/26488](https://github.com/dart-lang/sdk/issues/26488)\n\n\nDart 的类型声明通常情况下只发挥了注解的功能：能够为阅读代码的人提供类型的的注释\n\n```dart\nint i ;\nint j = 0;\nsum(a,b) => a+b;\n\nvoid main(){\n  print(sum(i,j));\n}\n// These code will cause : NoSuchMethodError: The method '+' was called on null.\n```\n这是由于变量 i 在不进行初始化的时候分配了 null 值，此时 Null 类并没有对 + 操作符进行重载。\n\n### 类型检查\n\nDart 2 的更新是加入了类型推断机制\n\n通常来讲，一些事件会触发 Dart 的类型检查机制。\n\n- 执行复制操作\n- 传递实参给函数\n- 函数传递一个返回值\n\n\n```dart\nclass Animal{\n}\nclass Cat extends Animal{\n  Cat(this.say);\n  String say = \"miao\";\n}\n\nvoid main(){\n  List<Animal> animals = [new Animal(),new Cat(\"1\"),new Cat(\"2\")];\n  //  This statement will not cause an exception.\n  //  We dont need a cast to state the type of animal[2];  \n  Cat cat  = animals[2];\n  print(cat.say);\n  try{\n    Cat anotherCat = animals[0];\n  }catch(e){\n    print(e.toString());\n  }\n}\n```\n\n### 接口类型\n\nDart 没有声明接口的语法，因为 Dart 类都存在隐式接口，任意一个类都可以使用 implements 关键字来实现一个接口。\n\n实现一个接口可以获得一个类的实例成员，但是并不会继承接口的实现，因此实现一个接口意味着需要同时提供所有接口的具体实现。\n\n```dart\n// A person. The implicit interface contains greet().\nclass Person {\n  // In the interface, but visible only in this library.\n  final _name;\n\n  // Not in the interface, since this is a constructor.\n  Person(this._name);\n\n  // In the interface.\n  String greet(String who) => 'Hello, $who. I am $_name.';\n}\n\n// An implementation of the Person interface.\nclass Impostor implements Person {\n  get _name => '';\n\n  String greet(String who) => 'Hi $who. Do you know who I am?';\n}\n\nString greetBob(Person person) => person.greet('Bob');\n\nvoid main() {\n  print(greetBob(Person('Kathy')));\n  print(greetBob(Impostor()));\n}\n```\n\n","slug":"Dart-类型","published":1,"updated":"2020-03-15T21:05:07.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3we000f29fy2bo86lsh","content":"<h2 id=\"Dart-类型\"><a href=\"#Dart-类型\" class=\"headerlink\" title=\"Dart 类型\"></a>Dart 类型</h2><p>Dart 类型的性质在 Dart 2 发布前后使截然不同的，本篇讨论了 Dart 类型的各种性质。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"可选类型（Dart-2-之前）\"><a href=\"#可选类型（Dart-2-之前）\" class=\"headerlink\" title=\"可选类型（Dart 2 之前）\"></a>可选类型（Dart 2 之前）</h3><p>Dart 中的可选类型的特征指的是：</p>\n<ul>\n<li>类型在语法层面上是可选的；</li>\n<li>类型对运行时语义没有影响。</li>\n</ul>\n<p>Dart 是动态类型的体现在开发者可以编写完全没有类型注解的程序，而不会有任何区别。</p>\n<blockquote>\n<p>Dart 类型注解不会影响语义。</p>\n</blockquote>\n<h3 id=\"类型注解\"><a href=\"#类型注解\" class=\"headerlink\" title=\"类型注解\"></a>类型注解</h3><p>尽管由于可选类型的原因，类型注解不是必须的，但是类型注解仍然有很多好处：</p>\n<ul>\n<li>开发者更好的阅读代码</li>\n<li>帮助 IDE 识别类型</li>\n<li>帮助静态检查器在初期检查错误</li>\n</ul>\n<h3 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h3><p>分析器可以推断参数的类型，一旦推断类型成为难题时，最终推断为 dynamic 。</p>\n<ul>\n<li>输入参数推断：根据上下文推断</li>\n<li>静态成员的推断</li>\n<li>局部变量的推断：根据初始化推断</li>\n<li>类成员的推断：</li>\n</ul>\n<p>尽管类型推断一直存在，但是如果推断的结果与开发者的意图不符合，还是应该使用显示的类型注解。</p>\n<h3 id=\"类型安全\"><a href=\"#类型安全\" class=\"headerlink\" title=\"类型安全\"></a>类型安全</h3><p>Dart 的类型安全基于静态类型检查和运行时检查，二者确保变量值于变量的类型匹配。</p>\n<ul>\n<li><p>静态类型分析能的使用 Dart 的静态分析器在执行前找出显著的类型安全错误。</p>\n</li>\n<li><p>运行时检查能使用 Dart VM 和 dartdevc 等工具来处理静态分析器无法捕获的安全问题。</p>\n</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> list = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;TempFile&gt;.from(</span><br><span class=\"line\">      [<span class=\"keyword\">new</span> TempFile(), <span class=\"keyword\">new</span> BankAccount()]);</span><br><span class=\"line\">  cleanUp(list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> cleanUp(<span class=\"built_in\">List</span>&lt;TempFile&gt; files) =&gt;</span><br><span class=\"line\">    files.forEach((f) =&gt; f.delete());</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TempFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> delete() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'TempFile deleted.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> delete() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'BankAccount deleted. Whoops!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 静态分析其无法捕获这个异常</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Dart-不支持函数重载\"><a href=\"#Dart-不支持函数重载\" class=\"headerlink\" title=\"Dart 不支持函数重载\"></a>Dart 不支持函数重载</h3><p>由于 Dart 中类型不会影响语义，也不会改变 Dart 代码的行为，因此函数重载也无法在 Dart 中实现，可选的代替方案是：</p>\n<ol>\n<li>使用 dynamic 类型参数接收并使用 is 语句进行类型检查。</li>\n<li>为每一个不同的函数提供不同的函数名称。</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> bar() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'bar()'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> bar(<span class=\"built_in\">String</span> name) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'bar($name)'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> bar(<span class=\"built_in\">int</span> number) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'bar($number)'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">dynamic</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// OK</span></span><br><span class=\"line\">  foo.bar();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Runtime error: Ambiguous dispatch. 2 or more implementations of `bar` exist.</span></span><br><span class=\"line\">  foo.bar(<span class=\"string\">'Hello'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参见 Dart 官方对函数重载的解释 <a href=\"https://github.com/dart-lang/sdk/issues/26488\" target=\"_blank\" rel=\"noopener\">https://github.com/dart-lang/sdk/issues/26488</a></p>\n</blockquote>\n<p>Dart 的类型声明通常情况下只发挥了注解的功能：能够为阅读代码的人提供类型的的注释</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> i ;</span><br><span class=\"line\"><span class=\"built_in\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">sum(a,b) =&gt; a+b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(sum(i,j));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// These code will cause : NoSuchMethodError: The method '+' was called on null.</span></span><br></pre></td></tr></table></figure>\n\n<p>这是由于变量 i 在不进行初始化的时候分配了 null 值，此时 Null 类并没有对 + 操作符进行重载。</p>\n<h3 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h3><p>Dart 2 的更新是加入了类型推断机制</p>\n<p>通常来讲，一些事件会触发 Dart 的类型检查机制。</p>\n<ul>\n<li>执行复制操作</li>\n<li>传递实参给函数</li>\n<li>函数传递一个返回值</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  Cat(<span class=\"keyword\">this</span>.say);</span><br><span class=\"line\">  <span class=\"built_in\">String</span> say = <span class=\"string\">\"miao\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Animal&gt; animals = [<span class=\"keyword\">new</span> Animal(),<span class=\"keyword\">new</span> Cat(<span class=\"string\">\"1\"</span>),<span class=\"keyword\">new</span> Cat(<span class=\"string\">\"2\"</span>)];</span><br><span class=\"line\">  <span class=\"comment\">//  This statement will not cause an exception.</span></span><br><span class=\"line\">  <span class=\"comment\">//  We dont need a cast to state the type of animal[2];  </span></span><br><span class=\"line\">  Cat cat  = animals[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(cat.say);</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Cat anotherCat = animals[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><p>Dart 没有声明接口的语法，因为 Dart 类都存在隐式接口，任意一个类都可以使用 implements 关键字来实现一个接口。</p>\n<p>实现一个接口可以获得一个类的实例成员，但是并不会继承接口的实现，因此实现一个接口意味着需要同时提供所有接口的具体实现。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A person. The implicit interface contains greet().</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// In the interface, but visible only in this library.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Not in the interface, since this is a constructor.</span></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>._name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// In the interface.</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hello, $who. I am $_name.'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An implementation of the Person interface.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impostor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> _name =&gt; <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hi $who. Do you know who I am?'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> greetBob(Person person) =&gt; person.greet(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Person(<span class=\"string\">'Kathy'</span>)));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Impostor()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"Dart-类型\"><a href=\"#Dart-类型\" class=\"headerlink\" title=\"Dart 类型\"></a>Dart 类型</h2><p>Dart 类型的性质在 Dart 2 发布前后使截然不同的，本篇讨论了 Dart 类型的各种性质。</p>","more":"<h3 id=\"可选类型（Dart-2-之前）\"><a href=\"#可选类型（Dart-2-之前）\" class=\"headerlink\" title=\"可选类型（Dart 2 之前）\"></a>可选类型（Dart 2 之前）</h3><p>Dart 中的可选类型的特征指的是：</p>\n<ul>\n<li>类型在语法层面上是可选的；</li>\n<li>类型对运行时语义没有影响。</li>\n</ul>\n<p>Dart 是动态类型的体现在开发者可以编写完全没有类型注解的程序，而不会有任何区别。</p>\n<blockquote>\n<p>Dart 类型注解不会影响语义。</p>\n</blockquote>\n<h3 id=\"类型注解\"><a href=\"#类型注解\" class=\"headerlink\" title=\"类型注解\"></a>类型注解</h3><p>尽管由于可选类型的原因，类型注解不是必须的，但是类型注解仍然有很多好处：</p>\n<ul>\n<li>开发者更好的阅读代码</li>\n<li>帮助 IDE 识别类型</li>\n<li>帮助静态检查器在初期检查错误</li>\n</ul>\n<h3 id=\"类型推断\"><a href=\"#类型推断\" class=\"headerlink\" title=\"类型推断\"></a>类型推断</h3><p>分析器可以推断参数的类型，一旦推断类型成为难题时，最终推断为 dynamic 。</p>\n<ul>\n<li>输入参数推断：根据上下文推断</li>\n<li>静态成员的推断</li>\n<li>局部变量的推断：根据初始化推断</li>\n<li>类成员的推断：</li>\n</ul>\n<p>尽管类型推断一直存在，但是如果推断的结果与开发者的意图不符合，还是应该使用显示的类型注解。</p>\n<h3 id=\"类型安全\"><a href=\"#类型安全\" class=\"headerlink\" title=\"类型安全\"></a>类型安全</h3><p>Dart 的类型安全基于静态类型检查和运行时检查，二者确保变量值于变量的类型匹配。</p>\n<ul>\n<li><p>静态类型分析能的使用 Dart 的静态分析器在执行前找出显著的类型安全错误。</p>\n</li>\n<li><p>运行时检查能使用 Dart VM 和 dartdevc 等工具来处理静态分析器无法捕获的安全问题。</p>\n</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> list = <span class=\"keyword\">new</span> <span class=\"built_in\">List</span>&lt;TempFile&gt;.from(</span><br><span class=\"line\">      [<span class=\"keyword\">new</span> TempFile(), <span class=\"keyword\">new</span> BankAccount()]);</span><br><span class=\"line\">  cleanUp(list);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> cleanUp(<span class=\"built_in\">List</span>&lt;TempFile&gt; files) =&gt;</span><br><span class=\"line\">    files.forEach((f) =&gt; f.delete());</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TempFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> delete() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'TempFile deleted.'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> delete() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'BankAccount deleted. Whoops!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 静态分析其无法捕获这个异常</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Dart-不支持函数重载\"><a href=\"#Dart-不支持函数重载\" class=\"headerlink\" title=\"Dart 不支持函数重载\"></a>Dart 不支持函数重载</h3><p>由于 Dart 中类型不会影响语义，也不会改变 Dart 代码的行为，因此函数重载也无法在 Dart 中实现，可选的代替方案是：</p>\n<ol>\n<li>使用 dynamic 类型参数接收并使用 is 语句进行类型检查。</li>\n<li>为每一个不同的函数提供不同的函数名称。</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> bar() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'bar()'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> bar(<span class=\"built_in\">String</span> name) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'bar($name)'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> bar(<span class=\"built_in\">int</span> number) =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'bar($number)'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">dynamic</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// OK</span></span><br><span class=\"line\">  foo.bar();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Runtime error: Ambiguous dispatch. 2 or more implementations of `bar` exist.</span></span><br><span class=\"line\">  foo.bar(<span class=\"string\">'Hello'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参见 Dart 官方对函数重载的解释 <a href=\"https://github.com/dart-lang/sdk/issues/26488\" target=\"_blank\" rel=\"noopener\">https://github.com/dart-lang/sdk/issues/26488</a></p>\n</blockquote>\n<p>Dart 的类型声明通常情况下只发挥了注解的功能：能够为阅读代码的人提供类型的的注释</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> i ;</span><br><span class=\"line\"><span class=\"built_in\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">sum(a,b) =&gt; a+b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(sum(i,j));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// These code will cause : NoSuchMethodError: The method '+' was called on null.</span></span><br></pre></td></tr></table></figure>\n\n<p>这是由于变量 i 在不进行初始化的时候分配了 null 值，此时 Null 类并没有对 + 操作符进行重载。</p>\n<h3 id=\"类型检查\"><a href=\"#类型检查\" class=\"headerlink\" title=\"类型检查\"></a>类型检查</h3><p>Dart 2 的更新是加入了类型推断机制</p>\n<p>通常来讲，一些事件会触发 Dart 的类型检查机制。</p>\n<ul>\n<li>执行复制操作</li>\n<li>传递实参给函数</li>\n<li>函数传递一个返回值</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\">  Cat(<span class=\"keyword\">this</span>.say);</span><br><span class=\"line\">  <span class=\"built_in\">String</span> say = <span class=\"string\">\"miao\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Animal&gt; animals = [<span class=\"keyword\">new</span> Animal(),<span class=\"keyword\">new</span> Cat(<span class=\"string\">\"1\"</span>),<span class=\"keyword\">new</span> Cat(<span class=\"string\">\"2\"</span>)];</span><br><span class=\"line\">  <span class=\"comment\">//  This statement will not cause an exception.</span></span><br><span class=\"line\">  <span class=\"comment\">//  We dont need a cast to state the type of animal[2];  </span></span><br><span class=\"line\">  Cat cat  = animals[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(cat.say);</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Cat anotherCat = animals[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(e.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"接口类型\"><a href=\"#接口类型\" class=\"headerlink\" title=\"接口类型\"></a>接口类型</h3><p>Dart 没有声明接口的语法，因为 Dart 类都存在隐式接口，任意一个类都可以使用 implements 关键字来实现一个接口。</p>\n<p>实现一个接口可以获得一个类的实例成员，但是并不会继承接口的实现，因此实现一个接口意味着需要同时提供所有接口的具体实现。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A person. The implicit interface contains greet().</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// In the interface, but visible only in this library.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Not in the interface, since this is a constructor.</span></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>._name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// In the interface.</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hello, $who. I am $_name.'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An implementation of the Person interface.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impostor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> _name =&gt; <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hi $who. Do you know who I am?'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> greetBob(Person person) =&gt; person.greet(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Person(<span class=\"string\">'Kathy'</span>)));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Impostor()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dart-类成员的初始化","date":"2019-05-12T15:45:23.000Z","_content":"\n### Dart 类成员的初始化\n\nDart 类成员的初始化有四种方式：\n- 声明时进行初始化；\n- 在构造函数为变量指定初始化的实例成员；\n- 使用初始化列表（初始化列表在进入构造函数之前进行）；\n- 非 final 成员可以使用在构造函数内部进行初始化（这会调用 setter 方法）；\n\n<!--more-->\n\n```dart\nclass Animal{\n//   1. initialize at the declaration\n  num age = 1;\n//   2. assign variable in the constructor\n  num leg;\n  Animal(this.leg);\n}\n\nclass Plant{\n//   3. use the initialozer list\n  num weight;\n  num height;\n  Plant(weight,height):this.weight = weight,this.height = height; \n}\n\nclass Human{\n//   4. no-final variable can be initialize in the constructor. \n  final String name;\n  num age;\n  Human(name,age):this.name = name{\n    this.age = age;\n  }\n\n//     The constructor below will casue a compile error because a final variable do not have a setter.\n//     this.name = name;\n//   Human(name,age){\n//     this.age = age;\n//     this.name = name;\n//   }\n  \n}\n\nvoid main (){\n  Animal animal = new Animal(4);\n  Plant plant = new Plant(1,2);\n  Human human = new Human(\"Tom\", 14);\n}\n```\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/4cfa1f2b78ccbff316c43a0c76fbd042)\n\n特别地 final 实例成员变量必须进行初始化，并且无法被赋值（这要求该成员需要一个 setter 方法）。因此 final 成员必须使用 前三种方式进行初始化。\n\n \t","source":"_posts/Dart-类成员的初始化.md","raw":"---\ntitle: Dart-类成员的初始化\ndate: 2019-05-12 23:45:23\ntags: Dart\n---\n\n### Dart 类成员的初始化\n\nDart 类成员的初始化有四种方式：\n- 声明时进行初始化；\n- 在构造函数为变量指定初始化的实例成员；\n- 使用初始化列表（初始化列表在进入构造函数之前进行）；\n- 非 final 成员可以使用在构造函数内部进行初始化（这会调用 setter 方法）；\n\n<!--more-->\n\n```dart\nclass Animal{\n//   1. initialize at the declaration\n  num age = 1;\n//   2. assign variable in the constructor\n  num leg;\n  Animal(this.leg);\n}\n\nclass Plant{\n//   3. use the initialozer list\n  num weight;\n  num height;\n  Plant(weight,height):this.weight = weight,this.height = height; \n}\n\nclass Human{\n//   4. no-final variable can be initialize in the constructor. \n  final String name;\n  num age;\n  Human(name,age):this.name = name{\n    this.age = age;\n  }\n\n//     The constructor below will casue a compile error because a final variable do not have a setter.\n//     this.name = name;\n//   Human(name,age){\n//     this.age = age;\n//     this.name = name;\n//   }\n  \n}\n\nvoid main (){\n  Animal animal = new Animal(4);\n  Plant plant = new Plant(1,2);\n  Human human = new Human(\"Tom\", 14);\n}\n```\n[在 DartPad 运行此代码](https://dartpad.dartlang.org/4cfa1f2b78ccbff316c43a0c76fbd042)\n\n特别地 final 实例成员变量必须进行初始化，并且无法被赋值（这要求该成员需要一个 setter 方法）。因此 final 成员必须使用 前三种方式进行初始化。\n\n \t","slug":"Dart-类成员的初始化","published":1,"updated":"2020-03-15T21:05:07.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wf000g29fyzgusjb0p","content":"<h3 id=\"Dart-类成员的初始化\"><a href=\"#Dart-类成员的初始化\" class=\"headerlink\" title=\"Dart 类成员的初始化\"></a>Dart 类成员的初始化</h3><p>Dart 类成员的初始化有四种方式：</p>\n<ul>\n<li>声明时进行初始化；</li>\n<li>在构造函数为变量指定初始化的实例成员；</li>\n<li>使用初始化列表（初始化列表在进入构造函数之前进行）；</li>\n<li>非 final 成员可以使用在构造函数内部进行初始化（这会调用 setter 方法）；</li>\n</ul>\n<a id=\"more\"></a>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//   1. initialize at the declaration</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> age = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//   2. assign variable in the constructor</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> leg;</span><br><span class=\"line\">  Animal(<span class=\"keyword\">this</span>.leg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Plant</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//   3. use the initialozer list</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> weight;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> height;</span><br><span class=\"line\">  Plant(weight,height):<span class=\"keyword\">this</span>.weight = weight,<span class=\"keyword\">this</span>.height = height; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//   4. no-final variable can be initialize in the constructor. </span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> age;</span><br><span class=\"line\">  Human(name,age):<span class=\"keyword\">this</span>.name = name&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     The constructor below will casue a compile error because a final variable do not have a setter.</span></span><br><span class=\"line\"><span class=\"comment\">//     this.name = name;</span></span><br><span class=\"line\"><span class=\"comment\">//   Human(name,age)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     this.age = age;</span></span><br><span class=\"line\"><span class=\"comment\">//     this.name = name;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main ()&#123;</span><br><span class=\"line\">  Animal animal = <span class=\"keyword\">new</span> Animal(<span class=\"number\">4</span>);</span><br><span class=\"line\">  Plant plant = <span class=\"keyword\">new</span> Plant(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">  Human human = <span class=\"keyword\">new</span> Human(<span class=\"string\">\"Tom\"</span>, <span class=\"number\">14</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/4cfa1f2b78ccbff316c43a0c76fbd042\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n<p>特别地 final 实例成员变量必须进行初始化，并且无法被赋值（这要求该成员需要一个 setter 方法）。因此 final 成员必须使用 前三种方式进行初始化。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Dart-类成员的初始化\"><a href=\"#Dart-类成员的初始化\" class=\"headerlink\" title=\"Dart 类成员的初始化\"></a>Dart 类成员的初始化</h3><p>Dart 类成员的初始化有四种方式：</p>\n<ul>\n<li>声明时进行初始化；</li>\n<li>在构造函数为变量指定初始化的实例成员；</li>\n<li>使用初始化列表（初始化列表在进入构造函数之前进行）；</li>\n<li>非 final 成员可以使用在构造函数内部进行初始化（这会调用 setter 方法）；</li>\n</ul>","more":"<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//   1. initialize at the declaration</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> age = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//   2. assign variable in the constructor</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> leg;</span><br><span class=\"line\">  Animal(<span class=\"keyword\">this</span>.leg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Plant</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//   3. use the initialozer list</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> weight;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> height;</span><br><span class=\"line\">  Plant(weight,height):<span class=\"keyword\">this</span>.weight = weight,<span class=\"keyword\">this</span>.height = height; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//   4. no-final variable can be initialize in the constructor. </span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> age;</span><br><span class=\"line\">  Human(name,age):<span class=\"keyword\">this</span>.name = name&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     The constructor below will casue a compile error because a final variable do not have a setter.</span></span><br><span class=\"line\"><span class=\"comment\">//     this.name = name;</span></span><br><span class=\"line\"><span class=\"comment\">//   Human(name,age)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     this.age = age;</span></span><br><span class=\"line\"><span class=\"comment\">//     this.name = name;</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main ()&#123;</span><br><span class=\"line\">  Animal animal = <span class=\"keyword\">new</span> Animal(<span class=\"number\">4</span>);</span><br><span class=\"line\">  Plant plant = <span class=\"keyword\">new</span> Plant(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">  Human human = <span class=\"keyword\">new</span> Human(<span class=\"string\">\"Tom\"</span>, <span class=\"number\">14</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://dartpad.dartlang.org/4cfa1f2b78ccbff316c43a0c76fbd042\" target=\"_blank\" rel=\"noopener\">在 DartPad 运行此代码</a></p>\n<p>特别地 final 实例成员变量必须进行初始化，并且无法被赋值（这要求该成员需要一个 setter 方法）。因此 final 成员必须使用 前三种方式进行初始化。</p>"},{"title":"MATLAB 入门","date":"2018-03-01T19:40:04.000Z","_content":"\nMATLAB 是矩阵实验室（Matrix&Laboratory）的简称，由 Mathwork 公司开发，广泛应用于数据分析，无线通信，深度学习，量化金融，计算机视觉和信号处理等方面，同时对于大学生数学建模竞赛也是相当重要的工具。 \n\n\n\n---\n\n> 出于 MATLAB 自身库函数的完备性和易用性，本人主张将 MATLAB 作为一种数学工具而并非 C/C++一样的程序设计语言，也不需要过多的专研数据结构与算法，也不一一展示 MATLAB 数量众多的函数和工具包。所以本文档的目标旨在教会读者编写简洁高效的，合理地使用 MATLAB 的内置工具实现目的。   \n> 注：使用的版本为 MATLAB R2015b 版本。  \n\n---\n\n<!--more-->\n\n\n\n### **用户界面**  \n\n打开 MATLAB 软件后，默认的用户界面中有三个主要区域，包括文件区、命令行和工作区。分别具有以下作用：  \n\n- 文件区(Current Folder) 显示脚本文件、函数文件和资源文件\n\n- 命令行(Command Window) 输入命令和输出变量的区域\n\n- 工作区(Workspaces)     存放变量（创建或导入）  \n\n\n\n### **MATLAB 文件**\n\nMATLAB中所有文件都以 .m 作为后缀名，有两种文件：一种为脚本文件（调用仅运行），另一种为函数（可以传入指定参数，输出指定参数），以 m 文件第一行是否有保留字 function 区分。可以通过面板左上角的 new 新建一个文件，编写程序。  \n\n#### 脚本文件实例\n\n```\ntheta = [-0.5*pi : 0.02 * pi : 0.5 * pi ]; \ngain =abs(sin (4 .* theta)./(theta .* 4));\npolar(theta ,gain ,'r-');\ntitle('\\bfAtntenna Gain vs \\theta');\n```\n\n#### 函数文件实例（函数文件名为 distance，d 为输出变量，a 和 b 为输入变量）\n\n```\nfunction [ d ] = distance( a,b )\n%UNTITLED Summary of this function goes here\n%   Detailed explanation goes here\n\nc = a - b;\nd = c .^ 2;\nd = sqrt(sum(d));\nend\n```\n\n### **最简单的命令**  \n\n在 MATLAB 中，变量的基本形式为矩阵。不妨从创建一个变量开始。  \n如果已经创建 m 文件，键入以下命令，点击运行（run）；如果选择在命令行运行，只需在命令行中输入以下命令（无需提前声明变量）如果计算机自动创建一个1×1的矩阵，值为1，这时在工作区中可以找到变量名为a的矩阵。  \n\n命令行输入\n\n```\na = 1\n```\n\n命令行输出\n\n```\na \n\n    = 1\n```\n\n### **尝试执行更多命令**  \n\n1. 可以直接用赋值语句对相应的数学关系的变量赋值  \n\n命令行输入\n\n```\nb = 3\nc = a + b\n```\n\n命令行输出\n\n```\nb\n\n    = 3\nc\n\n    = 4\n```\n\n2. 百分号 % 可以作为单行注释，接在%后的语句不作为 MATLAB 命令输入，如果需要使用%，这时需要使用 %%； MATLAB 中没有多行注释，但是可以选中后使用快捷键 Ctrl + R 注释，Ctrl + T 取消注释。  \n\n\n\n命令行输入\n\n```\n% a = 2 单行注释，不执行\nc = a + b\n```\n\n命令行输出\n\n```\nc\n\n    = 4\n```\n\n3. 英文分号 ; 表示一句语句的结束，特别的对于变量，语句末加上会终止命令行对该变量的输出  \n\n\n\n命令行输入\n\n```\na = 2;\nc = a + b\n```\n\n命令行输出\n\n```\nc\n\n    = 5\n```\n\n4.  ... 表示语句未结束，接续到下一行（注意 ... 前留空格）\n\n\n\n命令行输入\n\n```\nd = 1 + 2 ...\n    + 3\n```\n\n命令行输出\n\n```\nd\n\n    = 6\n```\n\n\n\n5.  不指定变量名时，计算机默认赋值给一个通用变量 ans  \n\n\n\n命令行输入\n\n```\n1 + 2 + 3\n```\n\n命令行输出\n\n```\nans\n\n    = 6\n```\n\n\n\n6.  MATLAB 中计算的优先级和一般的数学理解一致，但无论多少层优先级都只使用小括号\n\n\n\n命令行输入\n\n```\n2*1^3+(4*5-6/(1+2))\n\n```\n\n命令行输出\n\n```\nans\n\n    = 20\n```\n\n\n\n#### 重要的命令行操作\n\n这一部分的命令都十分强大和重要，稍微掌握即可大大减少用户的时间，但是难以给出演示，希望读者能够多加尝试，至少掌握其中高光的条目。  \n\n1. clc 清空命令行\n2. clear 清空工作区\n3. clf 清空绘图\n4. close 关闭窗口\n5. **Ctrl + C 强制中断正在运行的程序（仅光标在命令行时按下 Ctrl + C 有效）**\n6. ! 调用操作系统命令行（如：!explorer.exe 调用系统资源管理器）\n7. diary xxx 创建记录文件，默认文件名为 diary（不输入 xxx 时）, （当你需要记录调试过程或者输出到文件的时候可以使用，用于记录命令行窗口的输入输出）\n8. diary on 打开记录文件（开始记录）\n9. diary off 关闭记录文件（停止记录）\n10. save xxx 创建数据文件，保存为 xxx.mat ，默认为 matlab.mat\n（当你需要保存某次数据而希望在之后恢复原有数据时，或者不得不暂时中断分多步运行时，可以使用save命令保存多个或者所有变量）\n11. load xxx  加载读取数据，save 的反操作，读取并恢复xxx.mat的数据\n12. who 查询workspace的变量\n13. whos x 返回变量 x 的数据类型，维度，占用字节数，默认为所有变量\n14. **help xxx 战略核武器，用于显示 MATLAB 内置函数 xxx 的详细帮助信息（优势：详细的使用说明；缺陷：慢，有时候在浏览器上看可能更舒服）**  \n15. **lookfor xxx 顾名思义，检索关键词为 xxx 的文件，检索的优先级满足**\n\t-  已存在的变量\n\t-  内置函数\n\t-  现有目录的文件\n\t-  所有目录的文件\n\n#### 小结\n\nMATLAB 是一种高级的解释性语言，在用于很多方面都有很大的用处，对用户十分友好。一般来说，用户可以依照 MATLAB 提示完成所有操作。当然个人也推荐遇事不决问度娘，搜索引擎能帮我们了解更多的解决途径。如有疑问，可以向我提出，我会尽可能解答。\n\n\n\n\n\n#### REF\n\n1. MATLAB Programming for Engineers - 4th Edition Ch\n\n","source":"_posts/MATLAB-入门.md","raw":"---\ntitle: MATLAB 入门\ndate: 2018-03-02 03:40:04\ntags: MATLAB\n---\n\nMATLAB 是矩阵实验室（Matrix&Laboratory）的简称，由 Mathwork 公司开发，广泛应用于数据分析，无线通信，深度学习，量化金融，计算机视觉和信号处理等方面，同时对于大学生数学建模竞赛也是相当重要的工具。 \n\n\n\n---\n\n> 出于 MATLAB 自身库函数的完备性和易用性，本人主张将 MATLAB 作为一种数学工具而并非 C/C++一样的程序设计语言，也不需要过多的专研数据结构与算法，也不一一展示 MATLAB 数量众多的函数和工具包。所以本文档的目标旨在教会读者编写简洁高效的，合理地使用 MATLAB 的内置工具实现目的。   \n> 注：使用的版本为 MATLAB R2015b 版本。  \n\n---\n\n<!--more-->\n\n\n\n### **用户界面**  \n\n打开 MATLAB 软件后，默认的用户界面中有三个主要区域，包括文件区、命令行和工作区。分别具有以下作用：  \n\n- 文件区(Current Folder) 显示脚本文件、函数文件和资源文件\n\n- 命令行(Command Window) 输入命令和输出变量的区域\n\n- 工作区(Workspaces)     存放变量（创建或导入）  \n\n\n\n### **MATLAB 文件**\n\nMATLAB中所有文件都以 .m 作为后缀名，有两种文件：一种为脚本文件（调用仅运行），另一种为函数（可以传入指定参数，输出指定参数），以 m 文件第一行是否有保留字 function 区分。可以通过面板左上角的 new 新建一个文件，编写程序。  \n\n#### 脚本文件实例\n\n```\ntheta = [-0.5*pi : 0.02 * pi : 0.5 * pi ]; \ngain =abs(sin (4 .* theta)./(theta .* 4));\npolar(theta ,gain ,'r-');\ntitle('\\bfAtntenna Gain vs \\theta');\n```\n\n#### 函数文件实例（函数文件名为 distance，d 为输出变量，a 和 b 为输入变量）\n\n```\nfunction [ d ] = distance( a,b )\n%UNTITLED Summary of this function goes here\n%   Detailed explanation goes here\n\nc = a - b;\nd = c .^ 2;\nd = sqrt(sum(d));\nend\n```\n\n### **最简单的命令**  \n\n在 MATLAB 中，变量的基本形式为矩阵。不妨从创建一个变量开始。  \n如果已经创建 m 文件，键入以下命令，点击运行（run）；如果选择在命令行运行，只需在命令行中输入以下命令（无需提前声明变量）如果计算机自动创建一个1×1的矩阵，值为1，这时在工作区中可以找到变量名为a的矩阵。  \n\n命令行输入\n\n```\na = 1\n```\n\n命令行输出\n\n```\na \n\n    = 1\n```\n\n### **尝试执行更多命令**  \n\n1. 可以直接用赋值语句对相应的数学关系的变量赋值  \n\n命令行输入\n\n```\nb = 3\nc = a + b\n```\n\n命令行输出\n\n```\nb\n\n    = 3\nc\n\n    = 4\n```\n\n2. 百分号 % 可以作为单行注释，接在%后的语句不作为 MATLAB 命令输入，如果需要使用%，这时需要使用 %%； MATLAB 中没有多行注释，但是可以选中后使用快捷键 Ctrl + R 注释，Ctrl + T 取消注释。  \n\n\n\n命令行输入\n\n```\n% a = 2 单行注释，不执行\nc = a + b\n```\n\n命令行输出\n\n```\nc\n\n    = 4\n```\n\n3. 英文分号 ; 表示一句语句的结束，特别的对于变量，语句末加上会终止命令行对该变量的输出  \n\n\n\n命令行输入\n\n```\na = 2;\nc = a + b\n```\n\n命令行输出\n\n```\nc\n\n    = 5\n```\n\n4.  ... 表示语句未结束，接续到下一行（注意 ... 前留空格）\n\n\n\n命令行输入\n\n```\nd = 1 + 2 ...\n    + 3\n```\n\n命令行输出\n\n```\nd\n\n    = 6\n```\n\n\n\n5.  不指定变量名时，计算机默认赋值给一个通用变量 ans  \n\n\n\n命令行输入\n\n```\n1 + 2 + 3\n```\n\n命令行输出\n\n```\nans\n\n    = 6\n```\n\n\n\n6.  MATLAB 中计算的优先级和一般的数学理解一致，但无论多少层优先级都只使用小括号\n\n\n\n命令行输入\n\n```\n2*1^3+(4*5-6/(1+2))\n\n```\n\n命令行输出\n\n```\nans\n\n    = 20\n```\n\n\n\n#### 重要的命令行操作\n\n这一部分的命令都十分强大和重要，稍微掌握即可大大减少用户的时间，但是难以给出演示，希望读者能够多加尝试，至少掌握其中高光的条目。  \n\n1. clc 清空命令行\n2. clear 清空工作区\n3. clf 清空绘图\n4. close 关闭窗口\n5. **Ctrl + C 强制中断正在运行的程序（仅光标在命令行时按下 Ctrl + C 有效）**\n6. ! 调用操作系统命令行（如：!explorer.exe 调用系统资源管理器）\n7. diary xxx 创建记录文件，默认文件名为 diary（不输入 xxx 时）, （当你需要记录调试过程或者输出到文件的时候可以使用，用于记录命令行窗口的输入输出）\n8. diary on 打开记录文件（开始记录）\n9. diary off 关闭记录文件（停止记录）\n10. save xxx 创建数据文件，保存为 xxx.mat ，默认为 matlab.mat\n（当你需要保存某次数据而希望在之后恢复原有数据时，或者不得不暂时中断分多步运行时，可以使用save命令保存多个或者所有变量）\n11. load xxx  加载读取数据，save 的反操作，读取并恢复xxx.mat的数据\n12. who 查询workspace的变量\n13. whos x 返回变量 x 的数据类型，维度，占用字节数，默认为所有变量\n14. **help xxx 战略核武器，用于显示 MATLAB 内置函数 xxx 的详细帮助信息（优势：详细的使用说明；缺陷：慢，有时候在浏览器上看可能更舒服）**  \n15. **lookfor xxx 顾名思义，检索关键词为 xxx 的文件，检索的优先级满足**\n\t-  已存在的变量\n\t-  内置函数\n\t-  现有目录的文件\n\t-  所有目录的文件\n\n#### 小结\n\nMATLAB 是一种高级的解释性语言，在用于很多方面都有很大的用处，对用户十分友好。一般来说，用户可以依照 MATLAB 提示完成所有操作。当然个人也推荐遇事不决问度娘，搜索引擎能帮我们了解更多的解决途径。如有疑问，可以向我提出，我会尽可能解答。\n\n\n\n\n\n#### REF\n\n1. MATLAB Programming for Engineers - 4th Edition Ch\n\n","slug":"MATLAB-入门","published":1,"updated":"2020-03-15T21:05:07.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wf000h29fy31wvct33","content":"<p>MATLAB 是矩阵实验室（Matrix&amp;Laboratory）的简称，由 Mathwork 公司开发，广泛应用于数据分析，无线通信，深度学习，量化金融，计算机视觉和信号处理等方面，同时对于大学生数学建模竞赛也是相当重要的工具。 </p>\n<hr>\n<blockquote>\n<p>出于 MATLAB 自身库函数的完备性和易用性，本人主张将 MATLAB 作为一种数学工具而并非 C/C++一样的程序设计语言，也不需要过多的专研数据结构与算法，也不一一展示 MATLAB 数量众多的函数和工具包。所以本文档的目标旨在教会读者编写简洁高效的，合理地使用 MATLAB 的内置工具实现目的。<br>注：使用的版本为 MATLAB R2015b 版本。  </p>\n</blockquote>\n<hr>\n<a id=\"more\"></a>\n\n\n\n<h3 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a><strong>用户界面</strong></h3><p>打开 MATLAB 软件后，默认的用户界面中有三个主要区域，包括文件区、命令行和工作区。分别具有以下作用：  </p>\n<ul>\n<li><p>文件区(Current Folder) 显示脚本文件、函数文件和资源文件</p>\n</li>\n<li><p>命令行(Command Window) 输入命令和输出变量的区域</p>\n</li>\n<li><p>工作区(Workspaces)     存放变量（创建或导入）  </p>\n</li>\n</ul>\n<h3 id=\"MATLAB-文件\"><a href=\"#MATLAB-文件\" class=\"headerlink\" title=\"MATLAB 文件\"></a><strong>MATLAB 文件</strong></h3><p>MATLAB中所有文件都以 .m 作为后缀名，有两种文件：一种为脚本文件（调用仅运行），另一种为函数（可以传入指定参数，输出指定参数），以 m 文件第一行是否有保留字 function 区分。可以通过面板左上角的 new 新建一个文件，编写程序。  </p>\n<h4 id=\"脚本文件实例\"><a href=\"#脚本文件实例\" class=\"headerlink\" title=\"脚本文件实例\"></a>脚本文件实例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theta = [-0.5*pi : 0.02 * pi : 0.5 * pi ]; </span><br><span class=\"line\">gain =abs(sin (4 .* theta)./(theta .* 4));</span><br><span class=\"line\">polar(theta ,gain ,&apos;r-&apos;);</span><br><span class=\"line\">title(&apos;\\bfAtntenna Gain vs \\theta&apos;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数文件实例（函数文件名为-distance，d-为输出变量，a-和-b-为输入变量）\"><a href=\"#函数文件实例（函数文件名为-distance，d-为输出变量，a-和-b-为输入变量）\" class=\"headerlink\" title=\"函数文件实例（函数文件名为 distance，d 为输出变量，a 和 b 为输入变量）\"></a>函数文件实例（函数文件名为 distance，d 为输出变量，a 和 b 为输入变量）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ d ] = distance( a,b )</span><br><span class=\"line\">%UNTITLED Summary of this function goes here</span><br><span class=\"line\">%   Detailed explanation goes here</span><br><span class=\"line\"></span><br><span class=\"line\">c = a - b;</span><br><span class=\"line\">d = c .^ 2;</span><br><span class=\"line\">d = sqrt(sum(d));</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最简单的命令\"><a href=\"#最简单的命令\" class=\"headerlink\" title=\"最简单的命令\"></a><strong>最简单的命令</strong></h3><p>在 MATLAB 中，变量的基本形式为矩阵。不妨从创建一个变量开始。<br>如果已经创建 m 文件，键入以下命令，点击运行（run）；如果选择在命令行运行，只需在命令行中输入以下命令（无需提前声明变量）如果计算机自动创建一个1×1的矩阵，值为1，这时在工作区中可以找到变量名为a的矩阵。  </p>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 1</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a </span><br><span class=\"line\"></span><br><span class=\"line\">    = 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"尝试执行更多命令\"><a href=\"#尝试执行更多命令\" class=\"headerlink\" title=\"尝试执行更多命令\"></a><strong>尝试执行更多命令</strong></h3><ol>\n<li>可以直接用赋值语句对相应的数学关系的变量赋值  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = 3</span><br><span class=\"line\">c = a + b</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b</span><br><span class=\"line\"></span><br><span class=\"line\">    = 3</span><br><span class=\"line\">c</span><br><span class=\"line\"></span><br><span class=\"line\">    = 4</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>百分号 % 可以作为单行注释，接在%后的语句不作为 MATLAB 命令输入，如果需要使用%，这时需要使用 %%； MATLAB 中没有多行注释，但是可以选中后使用快捷键 Ctrl + R 注释，Ctrl + T 取消注释。  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% a = 2 单行注释，不执行</span><br><span class=\"line\">c = a + b</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c</span><br><span class=\"line\"></span><br><span class=\"line\">    = 4</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>英文分号 ; 表示一句语句的结束，特别的对于变量，语句末加上会终止命令行对该变量的输出  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2;</span><br><span class=\"line\">c = a + b</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c</span><br><span class=\"line\"></span><br><span class=\"line\">    = 5</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>… 表示语句未结束，接续到下一行（注意 … 前留空格）</li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = 1 + 2 ...</span><br><span class=\"line\">    + 3</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d</span><br><span class=\"line\"></span><br><span class=\"line\">    = 6</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>不指定变量名时，计算机默认赋值给一个通用变量 ans  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 + 2 + 3</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans</span><br><span class=\"line\"></span><br><span class=\"line\">    = 6</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>MATLAB 中计算的优先级和一般的数学理解一致，但无论多少层优先级都只使用小括号</li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2*1^3+(4*5-6/(1+2))</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans</span><br><span class=\"line\"></span><br><span class=\"line\">    = 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重要的命令行操作\"><a href=\"#重要的命令行操作\" class=\"headerlink\" title=\"重要的命令行操作\"></a>重要的命令行操作</h4><p>这一部分的命令都十分强大和重要，稍微掌握即可大大减少用户的时间，但是难以给出演示，希望读者能够多加尝试，至少掌握其中高光的条目。  </p>\n<ol>\n<li>clc 清空命令行</li>\n<li>clear 清空工作区</li>\n<li>clf 清空绘图</li>\n<li>close 关闭窗口</li>\n<li><strong>Ctrl + C 强制中断正在运行的程序（仅光标在命令行时按下 Ctrl + C 有效）</strong></li>\n<li>! 调用操作系统命令行（如：!explorer.exe 调用系统资源管理器）</li>\n<li>diary xxx 创建记录文件，默认文件名为 diary（不输入 xxx 时）, （当你需要记录调试过程或者输出到文件的时候可以使用，用于记录命令行窗口的输入输出）</li>\n<li>diary on 打开记录文件（开始记录）</li>\n<li>diary off 关闭记录文件（停止记录）</li>\n<li>save xxx 创建数据文件，保存为 xxx.mat ，默认为 matlab.mat<br>（当你需要保存某次数据而希望在之后恢复原有数据时，或者不得不暂时中断分多步运行时，可以使用save命令保存多个或者所有变量）</li>\n<li>load xxx  加载读取数据，save 的反操作，读取并恢复xxx.mat的数据</li>\n<li>who 查询workspace的变量</li>\n<li>whos x 返回变量 x 的数据类型，维度，占用字节数，默认为所有变量</li>\n<li><strong>help xxx 战略核武器，用于显示 MATLAB 内置函数 xxx 的详细帮助信息（优势：详细的使用说明；缺陷：慢，有时候在浏览器上看可能更舒服）</strong>  </li>\n<li><strong>lookfor xxx 顾名思义，检索关键词为 xxx 的文件，检索的优先级满足</strong><ul>\n<li>已存在的变量</li>\n<li>内置函数</li>\n<li>现有目录的文件</li>\n<li>所有目录的文件</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>MATLAB 是一种高级的解释性语言，在用于很多方面都有很大的用处，对用户十分友好。一般来说，用户可以依照 MATLAB 提示完成所有操作。当然个人也推荐遇事不决问度娘，搜索引擎能帮我们了解更多的解决途径。如有疑问，可以向我提出，我会尽可能解答。</p>\n<h4 id=\"REF\"><a href=\"#REF\" class=\"headerlink\" title=\"REF\"></a>REF</h4><ol>\n<li>MATLAB Programming for Engineers - 4th Edition Ch</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>MATLAB 是矩阵实验室（Matrix&amp;Laboratory）的简称，由 Mathwork 公司开发，广泛应用于数据分析，无线通信，深度学习，量化金融，计算机视觉和信号处理等方面，同时对于大学生数学建模竞赛也是相当重要的工具。 </p>\n<hr>\n<blockquote>\n<p>出于 MATLAB 自身库函数的完备性和易用性，本人主张将 MATLAB 作为一种数学工具而并非 C/C++一样的程序设计语言，也不需要过多的专研数据结构与算法，也不一一展示 MATLAB 数量众多的函数和工具包。所以本文档的目标旨在教会读者编写简洁高效的，合理地使用 MATLAB 的内置工具实现目的。<br>注：使用的版本为 MATLAB R2015b 版本。  </p>\n</blockquote>\n<hr>","more":"<h3 id=\"用户界面\"><a href=\"#用户界面\" class=\"headerlink\" title=\"用户界面\"></a><strong>用户界面</strong></h3><p>打开 MATLAB 软件后，默认的用户界面中有三个主要区域，包括文件区、命令行和工作区。分别具有以下作用：  </p>\n<ul>\n<li><p>文件区(Current Folder) 显示脚本文件、函数文件和资源文件</p>\n</li>\n<li><p>命令行(Command Window) 输入命令和输出变量的区域</p>\n</li>\n<li><p>工作区(Workspaces)     存放变量（创建或导入）  </p>\n</li>\n</ul>\n<h3 id=\"MATLAB-文件\"><a href=\"#MATLAB-文件\" class=\"headerlink\" title=\"MATLAB 文件\"></a><strong>MATLAB 文件</strong></h3><p>MATLAB中所有文件都以 .m 作为后缀名，有两种文件：一种为脚本文件（调用仅运行），另一种为函数（可以传入指定参数，输出指定参数），以 m 文件第一行是否有保留字 function 区分。可以通过面板左上角的 new 新建一个文件，编写程序。  </p>\n<h4 id=\"脚本文件实例\"><a href=\"#脚本文件实例\" class=\"headerlink\" title=\"脚本文件实例\"></a>脚本文件实例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theta = [-0.5*pi : 0.02 * pi : 0.5 * pi ]; </span><br><span class=\"line\">gain =abs(sin (4 .* theta)./(theta .* 4));</span><br><span class=\"line\">polar(theta ,gain ,&apos;r-&apos;);</span><br><span class=\"line\">title(&apos;\\bfAtntenna Gain vs \\theta&apos;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数文件实例（函数文件名为-distance，d-为输出变量，a-和-b-为输入变量）\"><a href=\"#函数文件实例（函数文件名为-distance，d-为输出变量，a-和-b-为输入变量）\" class=\"headerlink\" title=\"函数文件实例（函数文件名为 distance，d 为输出变量，a 和 b 为输入变量）\"></a>函数文件实例（函数文件名为 distance，d 为输出变量，a 和 b 为输入变量）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function [ d ] = distance( a,b )</span><br><span class=\"line\">%UNTITLED Summary of this function goes here</span><br><span class=\"line\">%   Detailed explanation goes here</span><br><span class=\"line\"></span><br><span class=\"line\">c = a - b;</span><br><span class=\"line\">d = c .^ 2;</span><br><span class=\"line\">d = sqrt(sum(d));</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最简单的命令\"><a href=\"#最简单的命令\" class=\"headerlink\" title=\"最简单的命令\"></a><strong>最简单的命令</strong></h3><p>在 MATLAB 中，变量的基本形式为矩阵。不妨从创建一个变量开始。<br>如果已经创建 m 文件，键入以下命令，点击运行（run）；如果选择在命令行运行，只需在命令行中输入以下命令（无需提前声明变量）如果计算机自动创建一个1×1的矩阵，值为1，这时在工作区中可以找到变量名为a的矩阵。  </p>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 1</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a </span><br><span class=\"line\"></span><br><span class=\"line\">    = 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"尝试执行更多命令\"><a href=\"#尝试执行更多命令\" class=\"headerlink\" title=\"尝试执行更多命令\"></a><strong>尝试执行更多命令</strong></h3><ol>\n<li>可以直接用赋值语句对相应的数学关系的变量赋值  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = 3</span><br><span class=\"line\">c = a + b</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b</span><br><span class=\"line\"></span><br><span class=\"line\">    = 3</span><br><span class=\"line\">c</span><br><span class=\"line\"></span><br><span class=\"line\">    = 4</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>百分号 % 可以作为单行注释，接在%后的语句不作为 MATLAB 命令输入，如果需要使用%，这时需要使用 %%； MATLAB 中没有多行注释，但是可以选中后使用快捷键 Ctrl + R 注释，Ctrl + T 取消注释。  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% a = 2 单行注释，不执行</span><br><span class=\"line\">c = a + b</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c</span><br><span class=\"line\"></span><br><span class=\"line\">    = 4</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>英文分号 ; 表示一句语句的结束，特别的对于变量，语句末加上会终止命令行对该变量的输出  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2;</span><br><span class=\"line\">c = a + b</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c</span><br><span class=\"line\"></span><br><span class=\"line\">    = 5</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>… 表示语句未结束，接续到下一行（注意 … 前留空格）</li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = 1 + 2 ...</span><br><span class=\"line\">    + 3</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d</span><br><span class=\"line\"></span><br><span class=\"line\">    = 6</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>不指定变量名时，计算机默认赋值给一个通用变量 ans  </li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 + 2 + 3</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans</span><br><span class=\"line\"></span><br><span class=\"line\">    = 6</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>MATLAB 中计算的优先级和一般的数学理解一致，但无论多少层优先级都只使用小括号</li>\n</ol>\n<p>命令行输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2*1^3+(4*5-6/(1+2))</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans</span><br><span class=\"line\"></span><br><span class=\"line\">    = 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重要的命令行操作\"><a href=\"#重要的命令行操作\" class=\"headerlink\" title=\"重要的命令行操作\"></a>重要的命令行操作</h4><p>这一部分的命令都十分强大和重要，稍微掌握即可大大减少用户的时间，但是难以给出演示，希望读者能够多加尝试，至少掌握其中高光的条目。  </p>\n<ol>\n<li>clc 清空命令行</li>\n<li>clear 清空工作区</li>\n<li>clf 清空绘图</li>\n<li>close 关闭窗口</li>\n<li><strong>Ctrl + C 强制中断正在运行的程序（仅光标在命令行时按下 Ctrl + C 有效）</strong></li>\n<li>! 调用操作系统命令行（如：!explorer.exe 调用系统资源管理器）</li>\n<li>diary xxx 创建记录文件，默认文件名为 diary（不输入 xxx 时）, （当你需要记录调试过程或者输出到文件的时候可以使用，用于记录命令行窗口的输入输出）</li>\n<li>diary on 打开记录文件（开始记录）</li>\n<li>diary off 关闭记录文件（停止记录）</li>\n<li>save xxx 创建数据文件，保存为 xxx.mat ，默认为 matlab.mat<br>（当你需要保存某次数据而希望在之后恢复原有数据时，或者不得不暂时中断分多步运行时，可以使用save命令保存多个或者所有变量）</li>\n<li>load xxx  加载读取数据，save 的反操作，读取并恢复xxx.mat的数据</li>\n<li>who 查询workspace的变量</li>\n<li>whos x 返回变量 x 的数据类型，维度，占用字节数，默认为所有变量</li>\n<li><strong>help xxx 战略核武器，用于显示 MATLAB 内置函数 xxx 的详细帮助信息（优势：详细的使用说明；缺陷：慢，有时候在浏览器上看可能更舒服）</strong>  </li>\n<li><strong>lookfor xxx 顾名思义，检索关键词为 xxx 的文件，检索的优先级满足</strong><ul>\n<li>已存在的变量</li>\n<li>内置函数</li>\n<li>现有目录的文件</li>\n<li>所有目录的文件</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>MATLAB 是一种高级的解释性语言，在用于很多方面都有很大的用处，对用户十分友好。一般来说，用户可以依照 MATLAB 提示完成所有操作。当然个人也推荐遇事不决问度娘，搜索引擎能帮我们了解更多的解决途径。如有疑问，可以向我提出，我会尽可能解答。</p>\n<h4 id=\"REF\"><a href=\"#REF\" class=\"headerlink\" title=\"REF\"></a>REF</h4><ol>\n<li>MATLAB Programming for Engineers - 4th Edition Ch</li>\n</ol>"},{"title":"MATLAB 函数（一）","date":"2018-03-14T20:24:16.000Z","_content":"\n### **概述**    \n> 过了很久才更一次的 MATLAB 笔记。\n\n这次主要讲讲 MATALB 中的函数的基础部分。函数就是有封装的特定功能的代码实现，说白了就是一段可以实现自定义功能的代码。使用函数的好处在于简化了代码同时增加了代码的可读性。\n\n<!--more-->\n### **编写 MATLAB 函数**\n#### 方法一：使用 MATLAB 的自动生成\n点击工具栏标签 new 下拉菜单中的 function 按钮，系统自动创建一个未命名的函数 Untitled ，\n进入编辑状态，格式如下：\n```matlab\nfunction [ output_args ] = Untitled( input_args )\n%UNTITLED 此处显示有关此函数的摘要\n%   此处显示详细说明\n\nend\n```\n这里逐项来解释以上内容：\n- function 是 MATLAB 中的一个关键字（保留字，只允许作为语法结构使用），可以用于定义函数。\n- [ output_args ] 输出参数列表\n- = 赋值符号\n- Untitle 函数名，可以自定义只要与文件名字相同（检索的时候只根据文件名检索） \n- ( input_args ) 输入参数列表\n- 第二行的 % 及之后的内容 函数的摘要（可以被 lookfor 命令检索的内容）\n- 之后的% 及之后的内容 函数的帮助文档（可以简单介绍一下变量的含义，方便修改）\n- 接着就是函数的主体 \n- end 宣告函数已经写完\n#### 方法二：依照函数语法编写 m 文件\n依照 MATLAB 给出的标准函数格式，你也可以直接使用 edit 命令编写一个新的 m 文件，依照语法编写后，MATLAB 会自动保存为相应的函数文件。\n当你熟悉了 MATLAB 语法后，即可使用方法二定义自己需要的函数，在此之前，建议先使用方法一快速创建 MATLAB 函数。\n#### 自定义 MATLAB 函数\n既然已经各个组分的含义，不妨自己来修改它。\n1. 尝试将函数名改为 my_fun（一般取一些有意义且不要重名的函数名）。\n2. 输出参数设为 y (只有一个变量时可不加中括号)\n3. 输入参数设为 x\n4. 函数内容写上： y = x * x;\n5. Ctrl + S 保存文件名为 my_fun.m\n```matlab\nfunction [ y ] = my_fun(x)\n%UNTITLED 此处显示有关此函数的摘要 \n%   此处显示详细说明 \ny = x * x;\nend\n```\n恭喜你，第一个能够计算平方的 MATLAB 函数大功告成。\n### **调用 MATLAB 函数**\n在命令行或者脚本文件（同一个文件夹）中使用 my_fun(x) 可以调用该函数。\n```matlab\n>> y1 = my_fun(3)\ny1 =\n     9\n>> x2 = 4;\n>> y2 = my_fun(x2)\ny2 =\n    16\n```\n那么问题来了：函数可不可以调用另一个函数呢？可以！\n新建另一个 MATLAB 函数，保存到同一个文件夹，像命令行使用即可。\n```matlab\nfunction [ y ] = my_fun_2(x)\n%UNTITLED 此处显示有关此函数的摘要 \n%   y = x*(x+1)\ny = my_fun(x) + x;\nend\n```\n *大胆的想法*\n>函数可不可以调用他自己呢？\n>可以的！在函数主体中调用自身就可以了。为了不至于发生死循环（无穷无尽的调用下去），可以通过限制调用的次数并逐次返回函数结果。这种方法叫做递归，斐波那契数列就可以用这种方法解决。\n### **更多需求**\n#### 需求一：更多输出参数\n```matlab\n% 将多个输出参数在括号中用中逗号隔开即可\n% 这时中括号不可省略\nfunction [y1,y2] = my_mutiply(x1)\ny1 = x * x;\ny2 = x * x * x;\nend\n```\n#### 需求二：更多输入参数\n```matlab\n% 将多个输入参数在括号中用逗号隔开即可\nfunction y = my_add(x1,x2,x3)\ny = x1 + x2 + x3;\nend\n```\n#### 需求三：不需要输入参数\n```matlab\n% 这时加不加小括号都可以\n% function y = my_rand_100()\n% function y = my_rand_100\nfunction y = my_rand_100\n% 产生一个 1-100 的随机整数\ny = randperm(100,1);\nend\n```\n#### 需求四：不需要输出\n```matlab\n% function 后直接加函数名字即可\nfunction my_print(x1,x2)\ny2 = x1 + x2;\ndisp(y2);\nend\n```\n#### 需求五：不想写 end\n```matlab\nfunction my_say_hello\ndisp('hello');\n```\n#### 需求六：交互方式使用函数\n```matlab\nfunction a = my_square\n    a = input('enter your number');\n    a = a^2;\nend\n```\n#### 需求七：输入参数是矩阵\n```matlab\n% MATLAB 才不会管你输入的是什么\n% 传递的变量都可以在函数里操作\nfunction average = my_average(x)\naverage = sum(x)/length(x);\nend\n```\n### **设计 MATLAB 函数**\n我们该如何从头开始设计一个 MATLAB 函数？以计算存款的利息为例：\n有复利计算公式如下\n> 利息=本金*(1+利率)^存期-本金 \n#### 思路\n先确定需要的函数成分：输入参数、输出参数和中间变量\n1. 输入参数：三个\n   1. 本金（present_value）\n   2. 计息期数（number_of_periods）\n   3. 利率（interest_rate）\n2. 输出参数：利息（interest）\n3. 中间变量：终值（future_value）\n4. 函数名：interest_calculator\n#### 编写\n```matlab\nfunction interest = interest_calculator(present_value,number_of_periods,interest_rate)\n% interest calculator with present_value, number_of_periods and interest_rate\n% 原理：利息=本金*(1+利率)^计息期数-本金\nfuture_value = present_value * (1 + interest_rate)^number_of_periods;\ninterest = future_value - present_value;\nend\n```\n#### 调试\n~~这样一来函数就完成了。~~\n\n想得美，每段代码都应该经过重复重复再重复的调试。在脚本文件中键入以下内容并运行：\n\n```matlab\nmy_present_value = 10000;\nmy_number_of_periods = 2;\nmy_interest_rate = 0.02;\nmy_interest = interest_calculator(my_present_value,my_number_of_periods,my_interest_rate)\n```\n\n输出结果为\n\n```matlab\nmy_interest =\n   404\n```\n\n（多次）确认没有问题后就可以宣告结束了。\n\n### 小结\nMATLAB 函数部分的内容确实比较多，以我拙劣的水平只能多花些时间挑出来，尽可能无误地、简明地写完。","source":"_posts/MATLAB-函数（一）.md","raw":"---\ntitle: MATLAB 函数（一）\ndate: 2018-03-15 4:24:16\ntags: MATLAB\n---\n\n### **概述**    \n> 过了很久才更一次的 MATLAB 笔记。\n\n这次主要讲讲 MATALB 中的函数的基础部分。函数就是有封装的特定功能的代码实现，说白了就是一段可以实现自定义功能的代码。使用函数的好处在于简化了代码同时增加了代码的可读性。\n\n<!--more-->\n### **编写 MATLAB 函数**\n#### 方法一：使用 MATLAB 的自动生成\n点击工具栏标签 new 下拉菜单中的 function 按钮，系统自动创建一个未命名的函数 Untitled ，\n进入编辑状态，格式如下：\n```matlab\nfunction [ output_args ] = Untitled( input_args )\n%UNTITLED 此处显示有关此函数的摘要\n%   此处显示详细说明\n\nend\n```\n这里逐项来解释以上内容：\n- function 是 MATLAB 中的一个关键字（保留字，只允许作为语法结构使用），可以用于定义函数。\n- [ output_args ] 输出参数列表\n- = 赋值符号\n- Untitle 函数名，可以自定义只要与文件名字相同（检索的时候只根据文件名检索） \n- ( input_args ) 输入参数列表\n- 第二行的 % 及之后的内容 函数的摘要（可以被 lookfor 命令检索的内容）\n- 之后的% 及之后的内容 函数的帮助文档（可以简单介绍一下变量的含义，方便修改）\n- 接着就是函数的主体 \n- end 宣告函数已经写完\n#### 方法二：依照函数语法编写 m 文件\n依照 MATLAB 给出的标准函数格式，你也可以直接使用 edit 命令编写一个新的 m 文件，依照语法编写后，MATLAB 会自动保存为相应的函数文件。\n当你熟悉了 MATLAB 语法后，即可使用方法二定义自己需要的函数，在此之前，建议先使用方法一快速创建 MATLAB 函数。\n#### 自定义 MATLAB 函数\n既然已经各个组分的含义，不妨自己来修改它。\n1. 尝试将函数名改为 my_fun（一般取一些有意义且不要重名的函数名）。\n2. 输出参数设为 y (只有一个变量时可不加中括号)\n3. 输入参数设为 x\n4. 函数内容写上： y = x * x;\n5. Ctrl + S 保存文件名为 my_fun.m\n```matlab\nfunction [ y ] = my_fun(x)\n%UNTITLED 此处显示有关此函数的摘要 \n%   此处显示详细说明 \ny = x * x;\nend\n```\n恭喜你，第一个能够计算平方的 MATLAB 函数大功告成。\n### **调用 MATLAB 函数**\n在命令行或者脚本文件（同一个文件夹）中使用 my_fun(x) 可以调用该函数。\n```matlab\n>> y1 = my_fun(3)\ny1 =\n     9\n>> x2 = 4;\n>> y2 = my_fun(x2)\ny2 =\n    16\n```\n那么问题来了：函数可不可以调用另一个函数呢？可以！\n新建另一个 MATLAB 函数，保存到同一个文件夹，像命令行使用即可。\n```matlab\nfunction [ y ] = my_fun_2(x)\n%UNTITLED 此处显示有关此函数的摘要 \n%   y = x*(x+1)\ny = my_fun(x) + x;\nend\n```\n *大胆的想法*\n>函数可不可以调用他自己呢？\n>可以的！在函数主体中调用自身就可以了。为了不至于发生死循环（无穷无尽的调用下去），可以通过限制调用的次数并逐次返回函数结果。这种方法叫做递归，斐波那契数列就可以用这种方法解决。\n### **更多需求**\n#### 需求一：更多输出参数\n```matlab\n% 将多个输出参数在括号中用中逗号隔开即可\n% 这时中括号不可省略\nfunction [y1,y2] = my_mutiply(x1)\ny1 = x * x;\ny2 = x * x * x;\nend\n```\n#### 需求二：更多输入参数\n```matlab\n% 将多个输入参数在括号中用逗号隔开即可\nfunction y = my_add(x1,x2,x3)\ny = x1 + x2 + x3;\nend\n```\n#### 需求三：不需要输入参数\n```matlab\n% 这时加不加小括号都可以\n% function y = my_rand_100()\n% function y = my_rand_100\nfunction y = my_rand_100\n% 产生一个 1-100 的随机整数\ny = randperm(100,1);\nend\n```\n#### 需求四：不需要输出\n```matlab\n% function 后直接加函数名字即可\nfunction my_print(x1,x2)\ny2 = x1 + x2;\ndisp(y2);\nend\n```\n#### 需求五：不想写 end\n```matlab\nfunction my_say_hello\ndisp('hello');\n```\n#### 需求六：交互方式使用函数\n```matlab\nfunction a = my_square\n    a = input('enter your number');\n    a = a^2;\nend\n```\n#### 需求七：输入参数是矩阵\n```matlab\n% MATLAB 才不会管你输入的是什么\n% 传递的变量都可以在函数里操作\nfunction average = my_average(x)\naverage = sum(x)/length(x);\nend\n```\n### **设计 MATLAB 函数**\n我们该如何从头开始设计一个 MATLAB 函数？以计算存款的利息为例：\n有复利计算公式如下\n> 利息=本金*(1+利率)^存期-本金 \n#### 思路\n先确定需要的函数成分：输入参数、输出参数和中间变量\n1. 输入参数：三个\n   1. 本金（present_value）\n   2. 计息期数（number_of_periods）\n   3. 利率（interest_rate）\n2. 输出参数：利息（interest）\n3. 中间变量：终值（future_value）\n4. 函数名：interest_calculator\n#### 编写\n```matlab\nfunction interest = interest_calculator(present_value,number_of_periods,interest_rate)\n% interest calculator with present_value, number_of_periods and interest_rate\n% 原理：利息=本金*(1+利率)^计息期数-本金\nfuture_value = present_value * (1 + interest_rate)^number_of_periods;\ninterest = future_value - present_value;\nend\n```\n#### 调试\n~~这样一来函数就完成了。~~\n\n想得美，每段代码都应该经过重复重复再重复的调试。在脚本文件中键入以下内容并运行：\n\n```matlab\nmy_present_value = 10000;\nmy_number_of_periods = 2;\nmy_interest_rate = 0.02;\nmy_interest = interest_calculator(my_present_value,my_number_of_periods,my_interest_rate)\n```\n\n输出结果为\n\n```matlab\nmy_interest =\n   404\n```\n\n（多次）确认没有问题后就可以宣告结束了。\n\n### 小结\nMATLAB 函数部分的内容确实比较多，以我拙劣的水平只能多花些时间挑出来，尽可能无误地、简明地写完。","slug":"MATLAB-函数（一）","published":1,"updated":"2020-03-15T21:05:07.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wg000i29fypkb6uwq1","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><blockquote>\n<p>过了很久才更一次的 MATLAB 笔记。</p>\n</blockquote>\n<p>这次主要讲讲 MATALB 中的函数的基础部分。函数就是有封装的特定功能的代码实现，说白了就是一段可以实现自定义功能的代码。使用函数的好处在于简化了代码同时增加了代码的可读性。</p>\n<a id=\"more\"></a>\n<h3 id=\"编写-MATLAB-函数\"><a href=\"#编写-MATLAB-函数\" class=\"headerlink\" title=\"编写 MATLAB 函数\"></a><strong>编写 MATLAB 函数</strong></h3><h4 id=\"方法一：使用-MATLAB-的自动生成\"><a href=\"#方法一：使用-MATLAB-的自动生成\" class=\"headerlink\" title=\"方法一：使用 MATLAB 的自动生成\"></a>方法一：使用 MATLAB 的自动生成</h4><p>点击工具栏标签 new 下拉菜单中的 function 按钮，系统自动创建一个未命名的函数 Untitled ，<br>进入编辑状态，格式如下：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[ output_args ]</span> = <span class=\"title\">Untitled</span><span class=\"params\">( input_args )</span></span></span><br><span class=\"line\"><span class=\"comment\">%UNTITLED 此处显示有关此函数的摘要</span></span><br><span class=\"line\"><span class=\"comment\">%   此处显示详细说明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>这里逐项来解释以上内容：</p>\n<ul>\n<li>function 是 MATLAB 中的一个关键字（保留字，只允许作为语法结构使用），可以用于定义函数。</li>\n<li>[ output_args ] 输出参数列表</li>\n<li>= 赋值符号</li>\n<li>Untitle 函数名，可以自定义只要与文件名字相同（检索的时候只根据文件名检索） </li>\n<li>( input_args ) 输入参数列表</li>\n<li>第二行的 % 及之后的内容 函数的摘要（可以被 lookfor 命令检索的内容）</li>\n<li>之后的% 及之后的内容 函数的帮助文档（可以简单介绍一下变量的含义，方便修改）</li>\n<li>接着就是函数的主体 </li>\n<li>end 宣告函数已经写完<h4 id=\"方法二：依照函数语法编写-m-文件\"><a href=\"#方法二：依照函数语法编写-m-文件\" class=\"headerlink\" title=\"方法二：依照函数语法编写 m 文件\"></a>方法二：依照函数语法编写 m 文件</h4>依照 MATLAB 给出的标准函数格式，你也可以直接使用 edit 命令编写一个新的 m 文件，依照语法编写后，MATLAB 会自动保存为相应的函数文件。<br>当你熟悉了 MATLAB 语法后，即可使用方法二定义自己需要的函数，在此之前，建议先使用方法一快速创建 MATLAB 函数。<h4 id=\"自定义-MATLAB-函数\"><a href=\"#自定义-MATLAB-函数\" class=\"headerlink\" title=\"自定义 MATLAB 函数\"></a>自定义 MATLAB 函数</h4>既然已经各个组分的含义，不妨自己来修改它。</li>\n</ul>\n<ol>\n<li>尝试将函数名改为 my_fun（一般取一些有意义且不要重名的函数名）。</li>\n<li>输出参数设为 y (只有一个变量时可不加中括号)</li>\n<li>输入参数设为 x</li>\n<li>函数内容写上： y = x * x;</li>\n<li>Ctrl + S 保存文件名为 my_fun.m<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[ y ]</span> = <span class=\"title\">my_fun</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\"><span class=\"comment\">%UNTITLED 此处显示有关此函数的摘要 </span></span><br><span class=\"line\"><span class=\"comment\">%   此处显示详细说明 </span></span><br><span class=\"line\">y = x * x;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>恭喜你，第一个能够计算平方的 MATLAB 函数大功告成。</p>\n<h3 id=\"调用-MATLAB-函数\"><a href=\"#调用-MATLAB-函数\" class=\"headerlink\" title=\"调用 MATLAB 函数\"></a><strong>调用 MATLAB 函数</strong></h3><p>在命令行或者脚本文件（同一个文件夹）中使用 my_fun(x) 可以调用该函数。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt; y1 = my_fun(<span class=\"number\">3</span>)</span><br><span class=\"line\">y1 =</span><br><span class=\"line\">     <span class=\"number\">9</span></span><br><span class=\"line\">&gt;&gt; x2 = <span class=\"number\">4</span>;</span><br><span class=\"line\">&gt;&gt; y2 = my_fun(x2)</span><br><span class=\"line\">y2 =</span><br><span class=\"line\">    <span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>那么问题来了：函数可不可以调用另一个函数呢？可以！<br>新建另一个 MATLAB 函数，保存到同一个文件夹，像命令行使用即可。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[ y ]</span> = <span class=\"title\">my_fun_2</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\"><span class=\"comment\">%UNTITLED 此处显示有关此函数的摘要 </span></span><br><span class=\"line\"><span class=\"comment\">%   y = x*(x+1)</span></span><br><span class=\"line\">y = my_fun(x) + x;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p> <em>大胆的想法</em></p>\n<blockquote>\n<p>函数可不可以调用他自己呢？<br>可以的！在函数主体中调用自身就可以了。为了不至于发生死循环（无穷无尽的调用下去），可以通过限制调用的次数并逐次返回函数结果。这种方法叫做递归，斐波那契数列就可以用这种方法解决。</p>\n</blockquote>\n<h3 id=\"更多需求\"><a href=\"#更多需求\" class=\"headerlink\" title=\"更多需求\"></a><strong>更多需求</strong></h3><h4 id=\"需求一：更多输出参数\"><a href=\"#需求一：更多输出参数\" class=\"headerlink\" title=\"需求一：更多输出参数\"></a>需求一：更多输出参数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 将多个输出参数在括号中用中逗号隔开即可</span></span><br><span class=\"line\"><span class=\"comment\">% 这时中括号不可省略</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[y1,y2]</span> = <span class=\"title\">my_mutiply</span><span class=\"params\">(x1)</span></span></span><br><span class=\"line\">y1 = x * x;</span><br><span class=\"line\">y2 = x * x * x;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求二：更多输入参数\"><a href=\"#需求二：更多输入参数\" class=\"headerlink\" title=\"需求二：更多输入参数\"></a>需求二：更多输入参数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 将多个输入参数在括号中用逗号隔开即可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">y</span> = <span class=\"title\">my_add</span><span class=\"params\">(x1,x2,x3)</span></span></span><br><span class=\"line\">y = x1 + x2 + x3;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求三：不需要输入参数\"><a href=\"#需求三：不需要输入参数\" class=\"headerlink\" title=\"需求三：不需要输入参数\"></a>需求三：不需要输入参数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 这时加不加小括号都可以</span></span><br><span class=\"line\"><span class=\"comment\">% function y = my_rand_100()</span></span><br><span class=\"line\"><span class=\"comment\">% function y = my_rand_100</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">y</span> = <span class=\"title\">my_rand_100</span></span></span><br><span class=\"line\"><span class=\"comment\">% 产生一个 1-100 的随机整数</span></span><br><span class=\"line\">y = randperm(<span class=\"number\">100</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求四：不需要输出\"><a href=\"#需求四：不需要输出\" class=\"headerlink\" title=\"需求四：不需要输出\"></a>需求四：不需要输出</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% function 后直接加函数名字即可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">my_print</span><span class=\"params\">(x1,x2)</span></span></span><br><span class=\"line\">y2 = x1 + x2;</span><br><span class=\"line\"><span class=\"built_in\">disp</span>(y2);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求五：不想写-end\"><a href=\"#需求五：不想写-end\" class=\"headerlink\" title=\"需求五：不想写 end\"></a>需求五：不想写 end</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">my_say_hello</span></span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>(<span class=\"string\">'hello'</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求六：交互方式使用函数\"><a href=\"#需求六：交互方式使用函数\" class=\"headerlink\" title=\"需求六：交互方式使用函数\"></a>需求六：交互方式使用函数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> = <span class=\"title\">my_square</span></span></span><br><span class=\"line\">    a = input(<span class=\"string\">'enter your number'</span>);</span><br><span class=\"line\">    a = a^<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求七：输入参数是矩阵\"><a href=\"#需求七：输入参数是矩阵\" class=\"headerlink\" title=\"需求七：输入参数是矩阵\"></a>需求七：输入参数是矩阵</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% MATLAB 才不会管你输入的是什么</span></span><br><span class=\"line\"><span class=\"comment\">% 传递的变量都可以在函数里操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">average</span> = <span class=\"title\">my_average</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\">average = sum(x)/<span class=\"built_in\">length</span>(x);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设计-MATLAB-函数\"><a href=\"#设计-MATLAB-函数\" class=\"headerlink\" title=\"设计 MATLAB 函数\"></a><strong>设计 MATLAB 函数</strong></h3><p>我们该如何从头开始设计一个 MATLAB 函数？以计算存款的利息为例：<br>有复利计算公式如下</p>\n<blockquote>\n<p>利息=本金*(1+利率)^存期-本金 </p>\n</blockquote>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>先确定需要的函数成分：输入参数、输出参数和中间变量</p>\n<ol>\n<li>输入参数：三个<ol>\n<li>本金（present_value）</li>\n<li>计息期数（number_of_periods）</li>\n<li>利率（interest_rate）</li>\n</ol>\n</li>\n<li>输出参数：利息（interest）</li>\n<li>中间变量：终值（future_value）</li>\n<li>函数名：interest_calculator<h4 id=\"编写\"><a href=\"#编写\" class=\"headerlink\" title=\"编写\"></a>编写</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interest</span> = <span class=\"title\">interest_calculator</span><span class=\"params\">(present_value,number_of_periods,interest_rate)</span></span></span><br><span class=\"line\"><span class=\"comment\">% interest calculator with present_value, number_of_periods and interest_rate</span></span><br><span class=\"line\"><span class=\"comment\">% 原理：利息=本金*(1+利率)^计息期数-本金</span></span><br><span class=\"line\">future_value = present_value * (<span class=\"number\">1</span> + interest_rate)^number_of_periods;</span><br><span class=\"line\">interest = future_value - present_value;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h4><p><del>这样一来函数就完成了。</del></p>\n<p>想得美，每段代码都应该经过重复重复再重复的调试。在脚本文件中键入以下内容并运行：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_present_value = <span class=\"number\">10000</span>;</span><br><span class=\"line\">my_number_of_periods = <span class=\"number\">2</span>;</span><br><span class=\"line\">my_interest_rate = <span class=\"number\">0.02</span>;</span><br><span class=\"line\">my_interest = interest_calculator(my_present_value,my_number_of_periods,my_interest_rate)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_interest =</span><br><span class=\"line\">   <span class=\"number\">404</span></span><br></pre></td></tr></table></figure>\n\n<p>（多次）确认没有问题后就可以宣告结束了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>MATLAB 函数部分的内容确实比较多，以我拙劣的水平只能多花些时间挑出来，尽可能无误地、简明地写完。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><blockquote>\n<p>过了很久才更一次的 MATLAB 笔记。</p>\n</blockquote>\n<p>这次主要讲讲 MATALB 中的函数的基础部分。函数就是有封装的特定功能的代码实现，说白了就是一段可以实现自定义功能的代码。使用函数的好处在于简化了代码同时增加了代码的可读性。</p>","more":"<h3 id=\"编写-MATLAB-函数\"><a href=\"#编写-MATLAB-函数\" class=\"headerlink\" title=\"编写 MATLAB 函数\"></a><strong>编写 MATLAB 函数</strong></h3><h4 id=\"方法一：使用-MATLAB-的自动生成\"><a href=\"#方法一：使用-MATLAB-的自动生成\" class=\"headerlink\" title=\"方法一：使用 MATLAB 的自动生成\"></a>方法一：使用 MATLAB 的自动生成</h4><p>点击工具栏标签 new 下拉菜单中的 function 按钮，系统自动创建一个未命名的函数 Untitled ，<br>进入编辑状态，格式如下：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[ output_args ]</span> = <span class=\"title\">Untitled</span><span class=\"params\">( input_args )</span></span></span><br><span class=\"line\"><span class=\"comment\">%UNTITLED 此处显示有关此函数的摘要</span></span><br><span class=\"line\"><span class=\"comment\">%   此处显示详细说明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>这里逐项来解释以上内容：</p>\n<ul>\n<li>function 是 MATLAB 中的一个关键字（保留字，只允许作为语法结构使用），可以用于定义函数。</li>\n<li>[ output_args ] 输出参数列表</li>\n<li>= 赋值符号</li>\n<li>Untitle 函数名，可以自定义只要与文件名字相同（检索的时候只根据文件名检索） </li>\n<li>( input_args ) 输入参数列表</li>\n<li>第二行的 % 及之后的内容 函数的摘要（可以被 lookfor 命令检索的内容）</li>\n<li>之后的% 及之后的内容 函数的帮助文档（可以简单介绍一下变量的含义，方便修改）</li>\n<li>接着就是函数的主体 </li>\n<li>end 宣告函数已经写完<h4 id=\"方法二：依照函数语法编写-m-文件\"><a href=\"#方法二：依照函数语法编写-m-文件\" class=\"headerlink\" title=\"方法二：依照函数语法编写 m 文件\"></a>方法二：依照函数语法编写 m 文件</h4>依照 MATLAB 给出的标准函数格式，你也可以直接使用 edit 命令编写一个新的 m 文件，依照语法编写后，MATLAB 会自动保存为相应的函数文件。<br>当你熟悉了 MATLAB 语法后，即可使用方法二定义自己需要的函数，在此之前，建议先使用方法一快速创建 MATLAB 函数。<h4 id=\"自定义-MATLAB-函数\"><a href=\"#自定义-MATLAB-函数\" class=\"headerlink\" title=\"自定义 MATLAB 函数\"></a>自定义 MATLAB 函数</h4>既然已经各个组分的含义，不妨自己来修改它。</li>\n</ul>\n<ol>\n<li>尝试将函数名改为 my_fun（一般取一些有意义且不要重名的函数名）。</li>\n<li>输出参数设为 y (只有一个变量时可不加中括号)</li>\n<li>输入参数设为 x</li>\n<li>函数内容写上： y = x * x;</li>\n<li>Ctrl + S 保存文件名为 my_fun.m<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[ y ]</span> = <span class=\"title\">my_fun</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\"><span class=\"comment\">%UNTITLED 此处显示有关此函数的摘要 </span></span><br><span class=\"line\"><span class=\"comment\">%   此处显示详细说明 </span></span><br><span class=\"line\">y = x * x;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>恭喜你，第一个能够计算平方的 MATLAB 函数大功告成。</p>\n<h3 id=\"调用-MATLAB-函数\"><a href=\"#调用-MATLAB-函数\" class=\"headerlink\" title=\"调用 MATLAB 函数\"></a><strong>调用 MATLAB 函数</strong></h3><p>在命令行或者脚本文件（同一个文件夹）中使用 my_fun(x) 可以调用该函数。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt; y1 = my_fun(<span class=\"number\">3</span>)</span><br><span class=\"line\">y1 =</span><br><span class=\"line\">     <span class=\"number\">9</span></span><br><span class=\"line\">&gt;&gt; x2 = <span class=\"number\">4</span>;</span><br><span class=\"line\">&gt;&gt; y2 = my_fun(x2)</span><br><span class=\"line\">y2 =</span><br><span class=\"line\">    <span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>那么问题来了：函数可不可以调用另一个函数呢？可以！<br>新建另一个 MATLAB 函数，保存到同一个文件夹，像命令行使用即可。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[ y ]</span> = <span class=\"title\">my_fun_2</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\"><span class=\"comment\">%UNTITLED 此处显示有关此函数的摘要 </span></span><br><span class=\"line\"><span class=\"comment\">%   y = x*(x+1)</span></span><br><span class=\"line\">y = my_fun(x) + x;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p> <em>大胆的想法</em></p>\n<blockquote>\n<p>函数可不可以调用他自己呢？<br>可以的！在函数主体中调用自身就可以了。为了不至于发生死循环（无穷无尽的调用下去），可以通过限制调用的次数并逐次返回函数结果。这种方法叫做递归，斐波那契数列就可以用这种方法解决。</p>\n</blockquote>\n<h3 id=\"更多需求\"><a href=\"#更多需求\" class=\"headerlink\" title=\"更多需求\"></a><strong>更多需求</strong></h3><h4 id=\"需求一：更多输出参数\"><a href=\"#需求一：更多输出参数\" class=\"headerlink\" title=\"需求一：更多输出参数\"></a>需求一：更多输出参数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 将多个输出参数在括号中用中逗号隔开即可</span></span><br><span class=\"line\"><span class=\"comment\">% 这时中括号不可省略</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[y1,y2]</span> = <span class=\"title\">my_mutiply</span><span class=\"params\">(x1)</span></span></span><br><span class=\"line\">y1 = x * x;</span><br><span class=\"line\">y2 = x * x * x;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求二：更多输入参数\"><a href=\"#需求二：更多输入参数\" class=\"headerlink\" title=\"需求二：更多输入参数\"></a>需求二：更多输入参数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 将多个输入参数在括号中用逗号隔开即可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">y</span> = <span class=\"title\">my_add</span><span class=\"params\">(x1,x2,x3)</span></span></span><br><span class=\"line\">y = x1 + x2 + x3;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求三：不需要输入参数\"><a href=\"#需求三：不需要输入参数\" class=\"headerlink\" title=\"需求三：不需要输入参数\"></a>需求三：不需要输入参数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% 这时加不加小括号都可以</span></span><br><span class=\"line\"><span class=\"comment\">% function y = my_rand_100()</span></span><br><span class=\"line\"><span class=\"comment\">% function y = my_rand_100</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">y</span> = <span class=\"title\">my_rand_100</span></span></span><br><span class=\"line\"><span class=\"comment\">% 产生一个 1-100 的随机整数</span></span><br><span class=\"line\">y = randperm(<span class=\"number\">100</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求四：不需要输出\"><a href=\"#需求四：不需要输出\" class=\"headerlink\" title=\"需求四：不需要输出\"></a>需求四：不需要输出</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% function 后直接加函数名字即可</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">my_print</span><span class=\"params\">(x1,x2)</span></span></span><br><span class=\"line\">y2 = x1 + x2;</span><br><span class=\"line\"><span class=\"built_in\">disp</span>(y2);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求五：不想写-end\"><a href=\"#需求五：不想写-end\" class=\"headerlink\" title=\"需求五：不想写 end\"></a>需求五：不想写 end</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">my_say_hello</span></span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>(<span class=\"string\">'hello'</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求六：交互方式使用函数\"><a href=\"#需求六：交互方式使用函数\" class=\"headerlink\" title=\"需求六：交互方式使用函数\"></a>需求六：交互方式使用函数</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> = <span class=\"title\">my_square</span></span></span><br><span class=\"line\">    a = input(<span class=\"string\">'enter your number'</span>);</span><br><span class=\"line\">    a = a^<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"需求七：输入参数是矩阵\"><a href=\"#需求七：输入参数是矩阵\" class=\"headerlink\" title=\"需求七：输入参数是矩阵\"></a>需求七：输入参数是矩阵</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% MATLAB 才不会管你输入的是什么</span></span><br><span class=\"line\"><span class=\"comment\">% 传递的变量都可以在函数里操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">average</span> = <span class=\"title\">my_average</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\">average = sum(x)/<span class=\"built_in\">length</span>(x);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设计-MATLAB-函数\"><a href=\"#设计-MATLAB-函数\" class=\"headerlink\" title=\"设计 MATLAB 函数\"></a><strong>设计 MATLAB 函数</strong></h3><p>我们该如何从头开始设计一个 MATLAB 函数？以计算存款的利息为例：<br>有复利计算公式如下</p>\n<blockquote>\n<p>利息=本金*(1+利率)^存期-本金 </p>\n</blockquote>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>先确定需要的函数成分：输入参数、输出参数和中间变量</p>\n<ol>\n<li>输入参数：三个<ol>\n<li>本金（present_value）</li>\n<li>计息期数（number_of_periods）</li>\n<li>利率（interest_rate）</li>\n</ol>\n</li>\n<li>输出参数：利息（interest）</li>\n<li>中间变量：终值（future_value）</li>\n<li>函数名：interest_calculator<h4 id=\"编写\"><a href=\"#编写\" class=\"headerlink\" title=\"编写\"></a>编写</h4><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interest</span> = <span class=\"title\">interest_calculator</span><span class=\"params\">(present_value,number_of_periods,interest_rate)</span></span></span><br><span class=\"line\"><span class=\"comment\">% interest calculator with present_value, number_of_periods and interest_rate</span></span><br><span class=\"line\"><span class=\"comment\">% 原理：利息=本金*(1+利率)^计息期数-本金</span></span><br><span class=\"line\">future_value = present_value * (<span class=\"number\">1</span> + interest_rate)^number_of_periods;</span><br><span class=\"line\">interest = future_value - present_value;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h4><p><del>这样一来函数就完成了。</del></p>\n<p>想得美，每段代码都应该经过重复重复再重复的调试。在脚本文件中键入以下内容并运行：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_present_value = <span class=\"number\">10000</span>;</span><br><span class=\"line\">my_number_of_periods = <span class=\"number\">2</span>;</span><br><span class=\"line\">my_interest_rate = <span class=\"number\">0.02</span>;</span><br><span class=\"line\">my_interest = interest_calculator(my_present_value,my_number_of_periods,my_interest_rate)</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_interest =</span><br><span class=\"line\">   <span class=\"number\">404</span></span><br></pre></td></tr></table></figure>\n\n<p>（多次）确认没有问题后就可以宣告结束了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>MATLAB 函数部分的内容确实比较多，以我拙劣的水平只能多花些时间挑出来，尽可能无误地、简明地写完。</p>"},{"title":"MATLAB 函数（二）","date":"2018-03-18T11:59:36.000Z","_content":"\n### **概述**    \n> 尽可能趁有空更一次的 MATLAB 笔记。\n\n这次内容讲讲 MATALB 中的函数的高级部分。\n\n- MATLAB 函数的原理：使用函数的好处在于简化了代码同时增加了代码的可读性。但是在使用函数的时候可能会有一些有偏差的理解，因此需要从机器的尺度上取解释 MATLAB 函数的原理。\n- MATLAB 可选参数：同一个可能要求不同的使用方法，如果逐一编写单独的函数实现不仅浪费而且难以使用，因此调用函数的使用要能够自适应不同的输入参数和输出参数。\n- MATLAB 函数的其他类型：MATLAB 官方定义 MATLAB 函数有四种其他类型：匿名函数、局部函数、嵌套函数和私有函数。（私以为前两种可能更常用）\n\n<!--more-->\n\n### **MATLAB 函数的原理**\n对于某一个 MATLAB 函数而言，它就像一个黑盒子（Black Box），用户只需要知道函数的用途而不必知道函数内部是怎么实现的。在主程序调用函数时，计算机开辟另一块内存空间，进入函数内部，运行函数命令，函数运行结束后，系统自动将这块内存空间回收，除了输出参数以外的所有函数内容都不再存在。\n\n> **请务必记得：在函数内部做的一切不会对外部造成任何影响。**\n\n以下方这个函数为例\n\n```matlab\nfunction add_1(x)\n\tx = x + 1;\n\tdisp(['In function: x = ' num2str(x)]);\nend\n```\n\n运行如下命令\n\n```matlab\nx = 1;\nadd_1(x); % 在函数内部，x 的值被修改了\ndisp(['In main: x = ' num2str(x)]); % 主程序的 x 并没有被修改\n```\n\n结果得到\n\n```\nIn function: x = 2\nIn main: x = 1\n```\n\n这又是什么情况呢？事实上，两个 x 是不同的值（函数并不执行“手递手式”地传递参数，而是将原来的变量拷贝一份放进函数的内存空间中），因此修改了函数内部的 x 后，在函数结束时就被回收，而外部的 x 并没有受到任何影响。\n\n你可以将主程序的 x 替换成 a ，并在函数内部的“x = x + 1;”添加断点（只需单击每一行最左侧行号后的区域，即显示一个红色的断点；再次单击可以取消断点）。运行时，会在函数内部暂停，观察 Workspace 可以发现函数内部的 x = 1。点击工具栏中的 Continue 则可以继续运行看到主程序仍然是 a = 1。\n\n```matlab\na = 1;\nadd_1(a); % 在函数内部，x 的值被修改了\ndisp(['In main: a = ' num2str(a)]); % 主程序的 a 并没有被修改\n```\n\n由此可见，函数内部的变量在主程序中是“看不见”，函数内部无法使用主程序中的变量，同样地，主程序也无法使用函数内部的变量。因此，函数与主程序的“交流”就依赖于输入参数和输出参数。\n\n> 将函数需要使用的变量传入，将函数计算所得结果传出。\n\n### **MATLAB 可选参数**\n\nMATLAB 中的许多函数都有着各种灵活的输入方式，可以支持不同数量的输入参数和输出参数，比如常用的 zeros 函数就可以根据不同数量的输入参数创建不同维度的零矩阵。这种灵活性就基于 MATLAB 函数中的可选参数。\n\nMATLAB 提供的可选参数有如下：\n\n- nargin\t函数输入参数数目\n\t nargout\t函数输出参数数目\n\t  varargin\t可变长度输入参数列表\n\t  varargout\t可变长度的输出参数列表\n\t  narginchk\t验证输入参数数目\n\t  nargoutchk\t验证输出参数数目\n\t  validateattributes\t检查数组的有效性\n\t  validatestring\t检查文本的有效性\n\t  inputParser\t函数的输入解析器\n\t  inputname\t函数输入的变量名称\n\t  mfilename\t当前正在运行的代码的文件名\n\n#### 样例一：对于不同输入参数执行不同操作\n\n有时候对于一个函数希望有多种的调用方式时，使用可选参数 nargin。同理对于不同的输出参数采用不同的调用方式时，使用可选参数 nargout。\n\n```matlab\nfunction report_name_id(name,id)\n    switch nargin % 在函数中 nargin 就是调用函数时输入参数的数量\n        case 2\n            disp(['name: ' name ' id:' num2str(id)]); \n            % 两个输入参数时输出名字和 id\n        case 1\n            disp(['name: ' name ' without id information.']);\n            % 仅输入一个参数名字（就是第一个参数）时输出名字和 无 id 信息\n        otherwise\n            disp('null');\n            % 不给输入参数时，输出 null。\n    end\nend\n```\n\n执行以下命令\n\n```\nreport_name_id('Tom',153412); % 两个输入参数时输出名字和 id\nreport_name_id('Tom'); % 输出名字和 无 id 信息\nreport_name_id(); % 输出 null\n```\n\n\n\n#### 样例二：对于未知数量参数执行不同操作\n\n有时候调用函数甚至不知道有多少个输入参数时，又该如何处置呢？这时就可以使用 varargin 来接收任意个输入参数，通过 varargin{index)}来访问对应的输入参数。\n\n```matlab \nfunction information_items(name,varargin)\n\tdisp(name);\n    for index = 1:nargin-1\n    \tdisp(varargin{index});\n    end\nend\n```\n\n三种调用方式会导致不同的结果，可以看到 varargin 都可以将多余的任意数量个参数都取得，并且可以通过 varargin{index}来访问。（事实上，varargin 是一个 cell 型变量）\n\n```matlab\ninformation_items('Tom','height:180','weight:72kg','age:17');\ninformation_items('Jack','height:169','weight:74kg');\ninformation_items('Bill','height:171','weight:88kg','age:23','shcool:Stanford');\n```\n\n同理，也可以对应地向 varargout{index} 赋值，将任意数量个输出参数传出。\n\n#### 样例三：验证输入参数数目\n\nnarginchk 是基于给定的输入参数上下限来验证输入参数是否符合要求的命令。\n\n```matlab\nfunction two_or_three_inputs(varargin)\n\tnarginchk(2,3);\n\tdisp('There are two or three inputs');\nend\n```\n\n同样使用三种调用方式\n\n```matlab\ntwo_or_three_inputs(1); % 报错 error，输入参数不够\ntwo_or_three_inputs(1,1);\ntwo_or_three_inputs(1,1,1,1); % 报错 error，输入参数过多\n```\n\n同理也可以使用 nargoutchk 对输出参数验证，此外，不妨尝试自己使用 error 函数给出合适的调用函数提示信息。\n\n#### 样例四：函数输入的变量名称\n\n你可能会想函数输入的变量名称肯定是已知的，为什么还要特地设计这样一个函数呢？这个函数是有一定作用的。\n\n\n\n```matlab\nfunction y = data_to_string(varargin)\n\ty = [];\n\tfor index = 1:nargin\n\t\ty = [y inputname(index) ':' varargin{index} ';'];\n\tend\nend\n```\n\n这个函数可以将数据根据对应的变量类型串成一个数据包。\n\n```\nname = 'Tom';\nage = '18';\nheight = '180cm';\nweight = '70kg';\nstr = data_to_string(name,age,height,weight);\n```\n\n### **MATLAB 函数其他类型**\n\nMATLAB 官方确定的其他类型的函数包括四种：\n\n- 匿名函数\n- 局部函数\n- 嵌套函数\n- 私有函数\n\n#### 匿名函数\n\n匿名函数是仅包含一句 MATLAB 命令的函数。匿名函数的优点在于无需另外创建保存一个 m 文件，甚至可以在脚本文件和命令行中随时定义随时使用。形如下式的命令可以创建一个匿名函数：\n\n```matlab\nfun = @(x,y)x.^2+y.^2-2*x*y+4;\n```\n\n其中 fun 是函数句柄，@ 运算符则用于创建一个句柄。\n\n#### 局部函数\n\n局部函数也叫做子函数，相当于某个完整函数的附属函数。局部函数编写于某个函数最后一行之后，是该函数的附属函数。这意味着局部函数使用范围有限：仅能被同一个文件中的其他函数调用，对其他函数和命令行不可见。\n\n```matlab\nfunction [avg, med] = mystats(x)\n% 主函数 可以被外部检索调用\nn = length(x);\navg = mymean(x,n);\nmed = mymedian(x,n);\nend\n\nfunction a = mymean(v,n)\n% 子函数 1 \n% 只能被主函数和其他子函数调用\na = sum(v)/n;\nend\n\nfunction m = mymedian(v,n)\n% 子函数 2\n% 只能被主函数和其他子函数调用\nw = sort(v);\nif rem(n,2) == 1\n    m = w((n + 1)/2);\nelse\n    m = (w(n/2) + w(n/2 + 1))/2;\nend\nend\n```\n\n> 特别地，如果你习惯省略函数体结尾的 end，在同一个文件中应当保证子函数和主函数使用同一种格式。\n\n#### 嵌套函数\n\n嵌套函数是定义在函数中的函数，外层函数可以调用内层函数并且如果内层函数变量在外层函数中有定义，那么嵌套函数可以访问和修改在其父函数中定义的变量。\n\n```matlab\nfunction main1\nx = 5;\nnestfun1\n\n   function nestfun1 \n     x = x + 1;\n   end \n\nend\n```\n\n#### 私有函数\n\n假设当前工作路径为 “/xxx”，在文件夹 xxx 创建一个名为“private”子文件夹，可以指定一个函数为私有函数。这样一来，只有文件夹 xxx下的函数可以调用这个私有函数。\n\n### 小结\n\n到此函数的内容也告一段落，本文除了 MATLAB 函数的内容外，还有一个额外的点就是断点调试（快速地中断和保留中断时的变量，能够让你加快调试的步骤）。","source":"_posts/MATLAB-函数（二）.md","raw":"---\ntitle: MATLAB 函数（二）\ndate: 2018-03-18 19:59:36\ntags: MATLAB\n---\n\n### **概述**    \n> 尽可能趁有空更一次的 MATLAB 笔记。\n\n这次内容讲讲 MATALB 中的函数的高级部分。\n\n- MATLAB 函数的原理：使用函数的好处在于简化了代码同时增加了代码的可读性。但是在使用函数的时候可能会有一些有偏差的理解，因此需要从机器的尺度上取解释 MATLAB 函数的原理。\n- MATLAB 可选参数：同一个可能要求不同的使用方法，如果逐一编写单独的函数实现不仅浪费而且难以使用，因此调用函数的使用要能够自适应不同的输入参数和输出参数。\n- MATLAB 函数的其他类型：MATLAB 官方定义 MATLAB 函数有四种其他类型：匿名函数、局部函数、嵌套函数和私有函数。（私以为前两种可能更常用）\n\n<!--more-->\n\n### **MATLAB 函数的原理**\n对于某一个 MATLAB 函数而言，它就像一个黑盒子（Black Box），用户只需要知道函数的用途而不必知道函数内部是怎么实现的。在主程序调用函数时，计算机开辟另一块内存空间，进入函数内部，运行函数命令，函数运行结束后，系统自动将这块内存空间回收，除了输出参数以外的所有函数内容都不再存在。\n\n> **请务必记得：在函数内部做的一切不会对外部造成任何影响。**\n\n以下方这个函数为例\n\n```matlab\nfunction add_1(x)\n\tx = x + 1;\n\tdisp(['In function: x = ' num2str(x)]);\nend\n```\n\n运行如下命令\n\n```matlab\nx = 1;\nadd_1(x); % 在函数内部，x 的值被修改了\ndisp(['In main: x = ' num2str(x)]); % 主程序的 x 并没有被修改\n```\n\n结果得到\n\n```\nIn function: x = 2\nIn main: x = 1\n```\n\n这又是什么情况呢？事实上，两个 x 是不同的值（函数并不执行“手递手式”地传递参数，而是将原来的变量拷贝一份放进函数的内存空间中），因此修改了函数内部的 x 后，在函数结束时就被回收，而外部的 x 并没有受到任何影响。\n\n你可以将主程序的 x 替换成 a ，并在函数内部的“x = x + 1;”添加断点（只需单击每一行最左侧行号后的区域，即显示一个红色的断点；再次单击可以取消断点）。运行时，会在函数内部暂停，观察 Workspace 可以发现函数内部的 x = 1。点击工具栏中的 Continue 则可以继续运行看到主程序仍然是 a = 1。\n\n```matlab\na = 1;\nadd_1(a); % 在函数内部，x 的值被修改了\ndisp(['In main: a = ' num2str(a)]); % 主程序的 a 并没有被修改\n```\n\n由此可见，函数内部的变量在主程序中是“看不见”，函数内部无法使用主程序中的变量，同样地，主程序也无法使用函数内部的变量。因此，函数与主程序的“交流”就依赖于输入参数和输出参数。\n\n> 将函数需要使用的变量传入，将函数计算所得结果传出。\n\n### **MATLAB 可选参数**\n\nMATLAB 中的许多函数都有着各种灵活的输入方式，可以支持不同数量的输入参数和输出参数，比如常用的 zeros 函数就可以根据不同数量的输入参数创建不同维度的零矩阵。这种灵活性就基于 MATLAB 函数中的可选参数。\n\nMATLAB 提供的可选参数有如下：\n\n- nargin\t函数输入参数数目\n\t nargout\t函数输出参数数目\n\t  varargin\t可变长度输入参数列表\n\t  varargout\t可变长度的输出参数列表\n\t  narginchk\t验证输入参数数目\n\t  nargoutchk\t验证输出参数数目\n\t  validateattributes\t检查数组的有效性\n\t  validatestring\t检查文本的有效性\n\t  inputParser\t函数的输入解析器\n\t  inputname\t函数输入的变量名称\n\t  mfilename\t当前正在运行的代码的文件名\n\n#### 样例一：对于不同输入参数执行不同操作\n\n有时候对于一个函数希望有多种的调用方式时，使用可选参数 nargin。同理对于不同的输出参数采用不同的调用方式时，使用可选参数 nargout。\n\n```matlab\nfunction report_name_id(name,id)\n    switch nargin % 在函数中 nargin 就是调用函数时输入参数的数量\n        case 2\n            disp(['name: ' name ' id:' num2str(id)]); \n            % 两个输入参数时输出名字和 id\n        case 1\n            disp(['name: ' name ' without id information.']);\n            % 仅输入一个参数名字（就是第一个参数）时输出名字和 无 id 信息\n        otherwise\n            disp('null');\n            % 不给输入参数时，输出 null。\n    end\nend\n```\n\n执行以下命令\n\n```\nreport_name_id('Tom',153412); % 两个输入参数时输出名字和 id\nreport_name_id('Tom'); % 输出名字和 无 id 信息\nreport_name_id(); % 输出 null\n```\n\n\n\n#### 样例二：对于未知数量参数执行不同操作\n\n有时候调用函数甚至不知道有多少个输入参数时，又该如何处置呢？这时就可以使用 varargin 来接收任意个输入参数，通过 varargin{index)}来访问对应的输入参数。\n\n```matlab \nfunction information_items(name,varargin)\n\tdisp(name);\n    for index = 1:nargin-1\n    \tdisp(varargin{index});\n    end\nend\n```\n\n三种调用方式会导致不同的结果，可以看到 varargin 都可以将多余的任意数量个参数都取得，并且可以通过 varargin{index}来访问。（事实上，varargin 是一个 cell 型变量）\n\n```matlab\ninformation_items('Tom','height:180','weight:72kg','age:17');\ninformation_items('Jack','height:169','weight:74kg');\ninformation_items('Bill','height:171','weight:88kg','age:23','shcool:Stanford');\n```\n\n同理，也可以对应地向 varargout{index} 赋值，将任意数量个输出参数传出。\n\n#### 样例三：验证输入参数数目\n\nnarginchk 是基于给定的输入参数上下限来验证输入参数是否符合要求的命令。\n\n```matlab\nfunction two_or_three_inputs(varargin)\n\tnarginchk(2,3);\n\tdisp('There are two or three inputs');\nend\n```\n\n同样使用三种调用方式\n\n```matlab\ntwo_or_three_inputs(1); % 报错 error，输入参数不够\ntwo_or_three_inputs(1,1);\ntwo_or_three_inputs(1,1,1,1); % 报错 error，输入参数过多\n```\n\n同理也可以使用 nargoutchk 对输出参数验证，此外，不妨尝试自己使用 error 函数给出合适的调用函数提示信息。\n\n#### 样例四：函数输入的变量名称\n\n你可能会想函数输入的变量名称肯定是已知的，为什么还要特地设计这样一个函数呢？这个函数是有一定作用的。\n\n\n\n```matlab\nfunction y = data_to_string(varargin)\n\ty = [];\n\tfor index = 1:nargin\n\t\ty = [y inputname(index) ':' varargin{index} ';'];\n\tend\nend\n```\n\n这个函数可以将数据根据对应的变量类型串成一个数据包。\n\n```\nname = 'Tom';\nage = '18';\nheight = '180cm';\nweight = '70kg';\nstr = data_to_string(name,age,height,weight);\n```\n\n### **MATLAB 函数其他类型**\n\nMATLAB 官方确定的其他类型的函数包括四种：\n\n- 匿名函数\n- 局部函数\n- 嵌套函数\n- 私有函数\n\n#### 匿名函数\n\n匿名函数是仅包含一句 MATLAB 命令的函数。匿名函数的优点在于无需另外创建保存一个 m 文件，甚至可以在脚本文件和命令行中随时定义随时使用。形如下式的命令可以创建一个匿名函数：\n\n```matlab\nfun = @(x,y)x.^2+y.^2-2*x*y+4;\n```\n\n其中 fun 是函数句柄，@ 运算符则用于创建一个句柄。\n\n#### 局部函数\n\n局部函数也叫做子函数，相当于某个完整函数的附属函数。局部函数编写于某个函数最后一行之后，是该函数的附属函数。这意味着局部函数使用范围有限：仅能被同一个文件中的其他函数调用，对其他函数和命令行不可见。\n\n```matlab\nfunction [avg, med] = mystats(x)\n% 主函数 可以被外部检索调用\nn = length(x);\navg = mymean(x,n);\nmed = mymedian(x,n);\nend\n\nfunction a = mymean(v,n)\n% 子函数 1 \n% 只能被主函数和其他子函数调用\na = sum(v)/n;\nend\n\nfunction m = mymedian(v,n)\n% 子函数 2\n% 只能被主函数和其他子函数调用\nw = sort(v);\nif rem(n,2) == 1\n    m = w((n + 1)/2);\nelse\n    m = (w(n/2) + w(n/2 + 1))/2;\nend\nend\n```\n\n> 特别地，如果你习惯省略函数体结尾的 end，在同一个文件中应当保证子函数和主函数使用同一种格式。\n\n#### 嵌套函数\n\n嵌套函数是定义在函数中的函数，外层函数可以调用内层函数并且如果内层函数变量在外层函数中有定义，那么嵌套函数可以访问和修改在其父函数中定义的变量。\n\n```matlab\nfunction main1\nx = 5;\nnestfun1\n\n   function nestfun1 \n     x = x + 1;\n   end \n\nend\n```\n\n#### 私有函数\n\n假设当前工作路径为 “/xxx”，在文件夹 xxx 创建一个名为“private”子文件夹，可以指定一个函数为私有函数。这样一来，只有文件夹 xxx下的函数可以调用这个私有函数。\n\n### 小结\n\n到此函数的内容也告一段落，本文除了 MATLAB 函数的内容外，还有一个额外的点就是断点调试（快速地中断和保留中断时的变量，能够让你加快调试的步骤）。","slug":"MATLAB-函数（二）","published":1,"updated":"2020-03-15T21:05:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wh000j29fyf3mb9wjc","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><blockquote>\n<p>尽可能趁有空更一次的 MATLAB 笔记。</p>\n</blockquote>\n<p>这次内容讲讲 MATALB 中的函数的高级部分。</p>\n<ul>\n<li>MATLAB 函数的原理：使用函数的好处在于简化了代码同时增加了代码的可读性。但是在使用函数的时候可能会有一些有偏差的理解，因此需要从机器的尺度上取解释 MATLAB 函数的原理。</li>\n<li>MATLAB 可选参数：同一个可能要求不同的使用方法，如果逐一编写单独的函数实现不仅浪费而且难以使用，因此调用函数的使用要能够自适应不同的输入参数和输出参数。</li>\n<li>MATLAB 函数的其他类型：MATLAB 官方定义 MATLAB 函数有四种其他类型：匿名函数、局部函数、嵌套函数和私有函数。（私以为前两种可能更常用）</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"MATLAB-函数的原理\"><a href=\"#MATLAB-函数的原理\" class=\"headerlink\" title=\"MATLAB 函数的原理\"></a><strong>MATLAB 函数的原理</strong></h3><p>对于某一个 MATLAB 函数而言，它就像一个黑盒子（Black Box），用户只需要知道函数的用途而不必知道函数内部是怎么实现的。在主程序调用函数时，计算机开辟另一块内存空间，进入函数内部，运行函数命令，函数运行结束后，系统自动将这块内存空间回收，除了输出参数以外的所有函数内容都不再存在。</p>\n<blockquote>\n<p><strong>请务必记得：在函数内部做的一切不会对外部造成任何影响。</strong></p>\n</blockquote>\n<p>以下方这个函数为例</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add_1</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\">\tx = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">disp</span>([<span class=\"string\">'In function: x = '</span> num2str(x)]);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下命令</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">add_1(x); <span class=\"comment\">% 在函数内部，x 的值被修改了</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">'In main: x = '</span> num2str(x)]); <span class=\"comment\">% 主程序的 x 并没有被修改</span></span><br></pre></td></tr></table></figure>\n\n<p>结果得到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In function: x = 2</span><br><span class=\"line\">In main: x = 1</span><br></pre></td></tr></table></figure>\n\n<p>这又是什么情况呢？事实上，两个 x 是不同的值（函数并不执行“手递手式”地传递参数，而是将原来的变量拷贝一份放进函数的内存空间中），因此修改了函数内部的 x 后，在函数结束时就被回收，而外部的 x 并没有受到任何影响。</p>\n<p>你可以将主程序的 x 替换成 a ，并在函数内部的“x = x + 1;”添加断点（只需单击每一行最左侧行号后的区域，即显示一个红色的断点；再次单击可以取消断点）。运行时，会在函数内部暂停，观察 Workspace 可以发现函数内部的 x = 1。点击工具栏中的 Continue 则可以继续运行看到主程序仍然是 a = 1。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\">add_1(a); <span class=\"comment\">% 在函数内部，x 的值被修改了</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">'In main: a = '</span> num2str(a)]); <span class=\"comment\">% 主程序的 a 并没有被修改</span></span><br></pre></td></tr></table></figure>\n\n<p>由此可见，函数内部的变量在主程序中是“看不见”，函数内部无法使用主程序中的变量，同样地，主程序也无法使用函数内部的变量。因此，函数与主程序的“交流”就依赖于输入参数和输出参数。</p>\n<blockquote>\n<p>将函数需要使用的变量传入，将函数计算所得结果传出。</p>\n</blockquote>\n<h3 id=\"MATLAB-可选参数\"><a href=\"#MATLAB-可选参数\" class=\"headerlink\" title=\"MATLAB 可选参数\"></a><strong>MATLAB 可选参数</strong></h3><p>MATLAB 中的许多函数都有着各种灵活的输入方式，可以支持不同数量的输入参数和输出参数，比如常用的 zeros 函数就可以根据不同数量的输入参数创建不同维度的零矩阵。这种灵活性就基于 MATLAB 函数中的可选参数。</p>\n<p>MATLAB 提供的可选参数有如下：</p>\n<ul>\n<li>nargin    函数输入参数数目<br>   nargout    函数输出参数数目<pre><code>varargin    可变长度输入参数列表\nvarargout    可变长度的输出参数列表\nnarginchk    验证输入参数数目\nnargoutchk    验证输出参数数目\nvalidateattributes    检查数组的有效性\nvalidatestring    检查文本的有效性\ninputParser    函数的输入解析器\ninputname    函数输入的变量名称\nmfilename    当前正在运行的代码的文件名</code></pre></li>\n</ul>\n<h4 id=\"样例一：对于不同输入参数执行不同操作\"><a href=\"#样例一：对于不同输入参数执行不同操作\" class=\"headerlink\" title=\"样例一：对于不同输入参数执行不同操作\"></a>样例一：对于不同输入参数执行不同操作</h4><p>有时候对于一个函数希望有多种的调用方式时，使用可选参数 nargin。同理对于不同的输出参数采用不同的调用方式时，使用可选参数 nargout。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">report_name_id</span><span class=\"params\">(name,id)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> nargin <span class=\"comment\">% 在函数中 nargin 就是调用函数时输入参数的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"built_in\">disp</span>([<span class=\"string\">'name: '</span> name <span class=\"string\">' id:'</span> num2str(id)]); </span><br><span class=\"line\">            <span class=\"comment\">% 两个输入参数时输出名字和 id</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"built_in\">disp</span>([<span class=\"string\">'name: '</span> name <span class=\"string\">' without id information.'</span>]);</span><br><span class=\"line\">            <span class=\"comment\">% 仅输入一个参数名字（就是第一个参数）时输出名字和 无 id 信息</span></span><br><span class=\"line\">        <span class=\"keyword\">otherwise</span></span><br><span class=\"line\">            <span class=\"built_in\">disp</span>(<span class=\"string\">'null'</span>);</span><br><span class=\"line\">            <span class=\"comment\">% 不给输入参数时，输出 null。</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">report_name_id(&apos;Tom&apos;,153412); % 两个输入参数时输出名字和 id</span><br><span class=\"line\">report_name_id(&apos;Tom&apos;); % 输出名字和 无 id 信息</span><br><span class=\"line\">report_name_id(); % 输出 null</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"样例二：对于未知数量参数执行不同操作\"><a href=\"#样例二：对于未知数量参数执行不同操作\" class=\"headerlink\" title=\"样例二：对于未知数量参数执行不同操作\"></a>样例二：对于未知数量参数执行不同操作</h4><p>有时候调用函数甚至不知道有多少个输入参数时，又该如何处置呢？这时就可以使用 varargin 来接收任意个输入参数，通过 varargin{index)}来访问对应的输入参数。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">information_items</span><span class=\"params\">(name,varargin)</span></span></span><br><span class=\"line\">\t<span class=\"built_in\">disp</span>(name);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:nargin<span class=\"number\">-1</span></span><br><span class=\"line\">    \t<span class=\"built_in\">disp</span>(varargin&#123;index&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>三种调用方式会导致不同的结果，可以看到 varargin 都可以将多余的任意数量个参数都取得，并且可以通过 varargin{index}来访问。（事实上，varargin 是一个 cell 型变量）</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">information_items(<span class=\"string\">'Tom'</span>,<span class=\"string\">'height:180'</span>,<span class=\"string\">'weight:72kg'</span>,<span class=\"string\">'age:17'</span>);</span><br><span class=\"line\">information_items(<span class=\"string\">'Jack'</span>,<span class=\"string\">'height:169'</span>,<span class=\"string\">'weight:74kg'</span>);</span><br><span class=\"line\">information_items(<span class=\"string\">'Bill'</span>,<span class=\"string\">'height:171'</span>,<span class=\"string\">'weight:88kg'</span>,<span class=\"string\">'age:23'</span>,<span class=\"string\">'shcool:Stanford'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同理，也可以对应地向 varargout{index} 赋值，将任意数量个输出参数传出。</p>\n<h4 id=\"样例三：验证输入参数数目\"><a href=\"#样例三：验证输入参数数目\" class=\"headerlink\" title=\"样例三：验证输入参数数目\"></a>样例三：验证输入参数数目</h4><p>narginchk 是基于给定的输入参数上下限来验证输入参数是否符合要求的命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">two_or_three_inputs</span><span class=\"params\">(varargin)</span></span></span><br><span class=\"line\">\tnarginchk(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">disp</span>(<span class=\"string\">'There are two or three inputs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>同样使用三种调用方式</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">two_or_three_inputs(<span class=\"number\">1</span>); <span class=\"comment\">% 报错 error，输入参数不够</span></span><br><span class=\"line\">two_or_three_inputs(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">two_or_three_inputs(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>); <span class=\"comment\">% 报错 error，输入参数过多</span></span><br></pre></td></tr></table></figure>\n\n<p>同理也可以使用 nargoutchk 对输出参数验证，此外，不妨尝试自己使用 error 函数给出合适的调用函数提示信息。</p>\n<h4 id=\"样例四：函数输入的变量名称\"><a href=\"#样例四：函数输入的变量名称\" class=\"headerlink\" title=\"样例四：函数输入的变量名称\"></a>样例四：函数输入的变量名称</h4><p>你可能会想函数输入的变量名称肯定是已知的，为什么还要特地设计这样一个函数呢？这个函数是有一定作用的。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">y</span> = <span class=\"title\">data_to_string</span><span class=\"params\">(varargin)</span></span></span><br><span class=\"line\">\ty = [];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:nargin</span><br><span class=\"line\">\t\ty = [y inputname(index) <span class=\"string\">':'</span> varargin&#123;index&#125; <span class=\"string\">';'</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>这个函数可以将数据根据对应的变量类型串成一个数据包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &apos;Tom&apos;;</span><br><span class=\"line\">age = &apos;18&apos;;</span><br><span class=\"line\">height = &apos;180cm&apos;;</span><br><span class=\"line\">weight = &apos;70kg&apos;;</span><br><span class=\"line\">str = data_to_string(name,age,height,weight);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MATLAB-函数其他类型\"><a href=\"#MATLAB-函数其他类型\" class=\"headerlink\" title=\"MATLAB 函数其他类型\"></a><strong>MATLAB 函数其他类型</strong></h3><p>MATLAB 官方确定的其他类型的函数包括四种：</p>\n<ul>\n<li>匿名函数</li>\n<li>局部函数</li>\n<li>嵌套函数</li>\n<li>私有函数</li>\n</ul>\n<h4 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h4><p>匿名函数是仅包含一句 MATLAB 命令的函数。匿名函数的优点在于无需另外创建保存一个 m 文件，甚至可以在脚本文件和命令行中随时定义随时使用。形如下式的命令可以创建一个匿名函数：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun = @(x,y)x.^<span class=\"number\">2</span>+y.^<span class=\"number\">2</span><span class=\"number\">-2</span>*x*y+<span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>其中 fun 是函数句柄，@ 运算符则用于创建一个句柄。</p>\n<h4 id=\"局部函数\"><a href=\"#局部函数\" class=\"headerlink\" title=\"局部函数\"></a>局部函数</h4><p>局部函数也叫做子函数，相当于某个完整函数的附属函数。局部函数编写于某个函数最后一行之后，是该函数的附属函数。这意味着局部函数使用范围有限：仅能被同一个文件中的其他函数调用，对其他函数和命令行不可见。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[avg, med]</span> = <span class=\"title\">mystats</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\"><span class=\"comment\">% 主函数 可以被外部检索调用</span></span><br><span class=\"line\">n = <span class=\"built_in\">length</span>(x);</span><br><span class=\"line\">avg = mymean(x,n);</span><br><span class=\"line\">med = mymedian(x,n);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> = <span class=\"title\">mymean</span><span class=\"params\">(v,n)</span></span></span><br><span class=\"line\"><span class=\"comment\">% 子函数 1 </span></span><br><span class=\"line\"><span class=\"comment\">% 只能被主函数和其他子函数调用</span></span><br><span class=\"line\">a = sum(v)/n;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m</span> = <span class=\"title\">mymedian</span><span class=\"params\">(v,n)</span></span></span><br><span class=\"line\"><span class=\"comment\">% 子函数 2</span></span><br><span class=\"line\"><span class=\"comment\">% 只能被主函数和其他子函数调用</span></span><br><span class=\"line\">w = sort(v);</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">rem</span>(n,<span class=\"number\">2</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">    m = w((n + <span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    m = (w(n/<span class=\"number\">2</span>) + w(n/<span class=\"number\">2</span> + <span class=\"number\">1</span>))/<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别地，如果你习惯省略函数体结尾的 end，在同一个文件中应当保证子函数和主函数使用同一种格式。</p>\n</blockquote>\n<h4 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h4><p>嵌套函数是定义在函数中的函数，外层函数可以调用内层函数并且如果内层函数变量在外层函数中有定义，那么嵌套函数可以访问和修改在其父函数中定义的变量。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main1</span></span></span><br><span class=\"line\">x = <span class=\"number\">5</span>;</span><br><span class=\"line\">nestfun1</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nestfun1</span> </span></span><br><span class=\"line\">     x = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">end</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"私有函数\"><a href=\"#私有函数\" class=\"headerlink\" title=\"私有函数\"></a>私有函数</h4><p>假设当前工作路径为 “/xxx”，在文件夹 xxx 创建一个名为“private”子文件夹，可以指定一个函数为私有函数。这样一来，只有文件夹 xxx下的函数可以调用这个私有函数。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>到此函数的内容也告一段落，本文除了 MATLAB 函数的内容外，还有一个额外的点就是断点调试（快速地中断和保留中断时的变量，能够让你加快调试的步骤）。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><blockquote>\n<p>尽可能趁有空更一次的 MATLAB 笔记。</p>\n</blockquote>\n<p>这次内容讲讲 MATALB 中的函数的高级部分。</p>\n<ul>\n<li>MATLAB 函数的原理：使用函数的好处在于简化了代码同时增加了代码的可读性。但是在使用函数的时候可能会有一些有偏差的理解，因此需要从机器的尺度上取解释 MATLAB 函数的原理。</li>\n<li>MATLAB 可选参数：同一个可能要求不同的使用方法，如果逐一编写单独的函数实现不仅浪费而且难以使用，因此调用函数的使用要能够自适应不同的输入参数和输出参数。</li>\n<li>MATLAB 函数的其他类型：MATLAB 官方定义 MATLAB 函数有四种其他类型：匿名函数、局部函数、嵌套函数和私有函数。（私以为前两种可能更常用）</li>\n</ul>","more":"<h3 id=\"MATLAB-函数的原理\"><a href=\"#MATLAB-函数的原理\" class=\"headerlink\" title=\"MATLAB 函数的原理\"></a><strong>MATLAB 函数的原理</strong></h3><p>对于某一个 MATLAB 函数而言，它就像一个黑盒子（Black Box），用户只需要知道函数的用途而不必知道函数内部是怎么实现的。在主程序调用函数时，计算机开辟另一块内存空间，进入函数内部，运行函数命令，函数运行结束后，系统自动将这块内存空间回收，除了输出参数以外的所有函数内容都不再存在。</p>\n<blockquote>\n<p><strong>请务必记得：在函数内部做的一切不会对外部造成任何影响。</strong></p>\n</blockquote>\n<p>以下方这个函数为例</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add_1</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\">\tx = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">disp</span>([<span class=\"string\">'In function: x = '</span> num2str(x)]);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行如下命令</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">1</span>;</span><br><span class=\"line\">add_1(x); <span class=\"comment\">% 在函数内部，x 的值被修改了</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">'In main: x = '</span> num2str(x)]); <span class=\"comment\">% 主程序的 x 并没有被修改</span></span><br></pre></td></tr></table></figure>\n\n<p>结果得到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In function: x = 2</span><br><span class=\"line\">In main: x = 1</span><br></pre></td></tr></table></figure>\n\n<p>这又是什么情况呢？事实上，两个 x 是不同的值（函数并不执行“手递手式”地传递参数，而是将原来的变量拷贝一份放进函数的内存空间中），因此修改了函数内部的 x 后，在函数结束时就被回收，而外部的 x 并没有受到任何影响。</p>\n<p>你可以将主程序的 x 替换成 a ，并在函数内部的“x = x + 1;”添加断点（只需单击每一行最左侧行号后的区域，即显示一个红色的断点；再次单击可以取消断点）。运行时，会在函数内部暂停，观察 Workspace 可以发现函数内部的 x = 1。点击工具栏中的 Continue 则可以继续运行看到主程序仍然是 a = 1。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\">add_1(a); <span class=\"comment\">% 在函数内部，x 的值被修改了</span></span><br><span class=\"line\"><span class=\"built_in\">disp</span>([<span class=\"string\">'In main: a = '</span> num2str(a)]); <span class=\"comment\">% 主程序的 a 并没有被修改</span></span><br></pre></td></tr></table></figure>\n\n<p>由此可见，函数内部的变量在主程序中是“看不见”，函数内部无法使用主程序中的变量，同样地，主程序也无法使用函数内部的变量。因此，函数与主程序的“交流”就依赖于输入参数和输出参数。</p>\n<blockquote>\n<p>将函数需要使用的变量传入，将函数计算所得结果传出。</p>\n</blockquote>\n<h3 id=\"MATLAB-可选参数\"><a href=\"#MATLAB-可选参数\" class=\"headerlink\" title=\"MATLAB 可选参数\"></a><strong>MATLAB 可选参数</strong></h3><p>MATLAB 中的许多函数都有着各种灵活的输入方式，可以支持不同数量的输入参数和输出参数，比如常用的 zeros 函数就可以根据不同数量的输入参数创建不同维度的零矩阵。这种灵活性就基于 MATLAB 函数中的可选参数。</p>\n<p>MATLAB 提供的可选参数有如下：</p>\n<ul>\n<li>nargin    函数输入参数数目<br>   nargout    函数输出参数数目<pre><code>varargin    可变长度输入参数列表\nvarargout    可变长度的输出参数列表\nnarginchk    验证输入参数数目\nnargoutchk    验证输出参数数目\nvalidateattributes    检查数组的有效性\nvalidatestring    检查文本的有效性\ninputParser    函数的输入解析器\ninputname    函数输入的变量名称\nmfilename    当前正在运行的代码的文件名</code></pre></li>\n</ul>\n<h4 id=\"样例一：对于不同输入参数执行不同操作\"><a href=\"#样例一：对于不同输入参数执行不同操作\" class=\"headerlink\" title=\"样例一：对于不同输入参数执行不同操作\"></a>样例一：对于不同输入参数执行不同操作</h4><p>有时候对于一个函数希望有多种的调用方式时，使用可选参数 nargin。同理对于不同的输出参数采用不同的调用方式时，使用可选参数 nargout。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">report_name_id</span><span class=\"params\">(name,id)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> nargin <span class=\"comment\">% 在函数中 nargin 就是调用函数时输入参数的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"built_in\">disp</span>([<span class=\"string\">'name: '</span> name <span class=\"string\">' id:'</span> num2str(id)]); </span><br><span class=\"line\">            <span class=\"comment\">% 两个输入参数时输出名字和 id</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"built_in\">disp</span>([<span class=\"string\">'name: '</span> name <span class=\"string\">' without id information.'</span>]);</span><br><span class=\"line\">            <span class=\"comment\">% 仅输入一个参数名字（就是第一个参数）时输出名字和 无 id 信息</span></span><br><span class=\"line\">        <span class=\"keyword\">otherwise</span></span><br><span class=\"line\">            <span class=\"built_in\">disp</span>(<span class=\"string\">'null'</span>);</span><br><span class=\"line\">            <span class=\"comment\">% 不给输入参数时，输出 null。</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">report_name_id(&apos;Tom&apos;,153412); % 两个输入参数时输出名字和 id</span><br><span class=\"line\">report_name_id(&apos;Tom&apos;); % 输出名字和 无 id 信息</span><br><span class=\"line\">report_name_id(); % 输出 null</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"样例二：对于未知数量参数执行不同操作\"><a href=\"#样例二：对于未知数量参数执行不同操作\" class=\"headerlink\" title=\"样例二：对于未知数量参数执行不同操作\"></a>样例二：对于未知数量参数执行不同操作</h4><p>有时候调用函数甚至不知道有多少个输入参数时，又该如何处置呢？这时就可以使用 varargin 来接收任意个输入参数，通过 varargin{index)}来访问对应的输入参数。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">information_items</span><span class=\"params\">(name,varargin)</span></span></span><br><span class=\"line\">\t<span class=\"built_in\">disp</span>(name);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:nargin<span class=\"number\">-1</span></span><br><span class=\"line\">    \t<span class=\"built_in\">disp</span>(varargin&#123;index&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>三种调用方式会导致不同的结果，可以看到 varargin 都可以将多余的任意数量个参数都取得，并且可以通过 varargin{index}来访问。（事实上，varargin 是一个 cell 型变量）</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">information_items(<span class=\"string\">'Tom'</span>,<span class=\"string\">'height:180'</span>,<span class=\"string\">'weight:72kg'</span>,<span class=\"string\">'age:17'</span>);</span><br><span class=\"line\">information_items(<span class=\"string\">'Jack'</span>,<span class=\"string\">'height:169'</span>,<span class=\"string\">'weight:74kg'</span>);</span><br><span class=\"line\">information_items(<span class=\"string\">'Bill'</span>,<span class=\"string\">'height:171'</span>,<span class=\"string\">'weight:88kg'</span>,<span class=\"string\">'age:23'</span>,<span class=\"string\">'shcool:Stanford'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同理，也可以对应地向 varargout{index} 赋值，将任意数量个输出参数传出。</p>\n<h4 id=\"样例三：验证输入参数数目\"><a href=\"#样例三：验证输入参数数目\" class=\"headerlink\" title=\"样例三：验证输入参数数目\"></a>样例三：验证输入参数数目</h4><p>narginchk 是基于给定的输入参数上下限来验证输入参数是否符合要求的命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">two_or_three_inputs</span><span class=\"params\">(varargin)</span></span></span><br><span class=\"line\">\tnarginchk(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">disp</span>(<span class=\"string\">'There are two or three inputs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>同样使用三种调用方式</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">two_or_three_inputs(<span class=\"number\">1</span>); <span class=\"comment\">% 报错 error，输入参数不够</span></span><br><span class=\"line\">two_or_three_inputs(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">two_or_three_inputs(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>); <span class=\"comment\">% 报错 error，输入参数过多</span></span><br></pre></td></tr></table></figure>\n\n<p>同理也可以使用 nargoutchk 对输出参数验证，此外，不妨尝试自己使用 error 函数给出合适的调用函数提示信息。</p>\n<h4 id=\"样例四：函数输入的变量名称\"><a href=\"#样例四：函数输入的变量名称\" class=\"headerlink\" title=\"样例四：函数输入的变量名称\"></a>样例四：函数输入的变量名称</h4><p>你可能会想函数输入的变量名称肯定是已知的，为什么还要特地设计这样一个函数呢？这个函数是有一定作用的。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">y</span> = <span class=\"title\">data_to_string</span><span class=\"params\">(varargin)</span></span></span><br><span class=\"line\">\ty = [];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:nargin</span><br><span class=\"line\">\t\ty = [y inputname(index) <span class=\"string\">':'</span> varargin&#123;index&#125; <span class=\"string\">';'</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>这个函数可以将数据根据对应的变量类型串成一个数据包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &apos;Tom&apos;;</span><br><span class=\"line\">age = &apos;18&apos;;</span><br><span class=\"line\">height = &apos;180cm&apos;;</span><br><span class=\"line\">weight = &apos;70kg&apos;;</span><br><span class=\"line\">str = data_to_string(name,age,height,weight);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MATLAB-函数其他类型\"><a href=\"#MATLAB-函数其他类型\" class=\"headerlink\" title=\"MATLAB 函数其他类型\"></a><strong>MATLAB 函数其他类型</strong></h3><p>MATLAB 官方确定的其他类型的函数包括四种：</p>\n<ul>\n<li>匿名函数</li>\n<li>局部函数</li>\n<li>嵌套函数</li>\n<li>私有函数</li>\n</ul>\n<h4 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h4><p>匿名函数是仅包含一句 MATLAB 命令的函数。匿名函数的优点在于无需另外创建保存一个 m 文件，甚至可以在脚本文件和命令行中随时定义随时使用。形如下式的命令可以创建一个匿名函数：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun = @(x,y)x.^<span class=\"number\">2</span>+y.^<span class=\"number\">2</span><span class=\"number\">-2</span>*x*y+<span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>其中 fun 是函数句柄，@ 运算符则用于创建一个句柄。</p>\n<h4 id=\"局部函数\"><a href=\"#局部函数\" class=\"headerlink\" title=\"局部函数\"></a>局部函数</h4><p>局部函数也叫做子函数，相当于某个完整函数的附属函数。局部函数编写于某个函数最后一行之后，是该函数的附属函数。这意味着局部函数使用范围有限：仅能被同一个文件中的其他函数调用，对其他函数和命令行不可见。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">[avg, med]</span> = <span class=\"title\">mystats</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\"><span class=\"comment\">% 主函数 可以被外部检索调用</span></span><br><span class=\"line\">n = <span class=\"built_in\">length</span>(x);</span><br><span class=\"line\">avg = mymean(x,n);</span><br><span class=\"line\">med = mymedian(x,n);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> = <span class=\"title\">mymean</span><span class=\"params\">(v,n)</span></span></span><br><span class=\"line\"><span class=\"comment\">% 子函数 1 </span></span><br><span class=\"line\"><span class=\"comment\">% 只能被主函数和其他子函数调用</span></span><br><span class=\"line\">a = sum(v)/n;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m</span> = <span class=\"title\">mymedian</span><span class=\"params\">(v,n)</span></span></span><br><span class=\"line\"><span class=\"comment\">% 子函数 2</span></span><br><span class=\"line\"><span class=\"comment\">% 只能被主函数和其他子函数调用</span></span><br><span class=\"line\">w = sort(v);</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">rem</span>(n,<span class=\"number\">2</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">    m = w((n + <span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    m = (w(n/<span class=\"number\">2</span>) + w(n/<span class=\"number\">2</span> + <span class=\"number\">1</span>))/<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别地，如果你习惯省略函数体结尾的 end，在同一个文件中应当保证子函数和主函数使用同一种格式。</p>\n</blockquote>\n<h4 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h4><p>嵌套函数是定义在函数中的函数，外层函数可以调用内层函数并且如果内层函数变量在外层函数中有定义，那么嵌套函数可以访问和修改在其父函数中定义的变量。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main1</span></span></span><br><span class=\"line\">x = <span class=\"number\">5</span>;</span><br><span class=\"line\">nestfun1</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nestfun1</span> </span></span><br><span class=\"line\">     x = x + <span class=\"number\">1</span>;</span><br><span class=\"line\">   <span class=\"keyword\">end</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"私有函数\"><a href=\"#私有函数\" class=\"headerlink\" title=\"私有函数\"></a>私有函数</h4><p>假设当前工作路径为 “/xxx”，在文件夹 xxx 创建一个名为“private”子文件夹，可以指定一个函数为私有函数。这样一来，只有文件夹 xxx下的函数可以调用这个私有函数。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>到此函数的内容也告一段落，本文除了 MATLAB 函数的内容外，还有一个额外的点就是断点调试（快速地中断和保留中断时的变量，能够让你加快调试的步骤）。</p>"},{"title":"MATLAB 矩阵（一）","date":"2018-03-02T19:46:31.000Z","_content":"\n----------\n\n### **概述**\n本次内容涉及 MATLAB 中的矩阵，这是我们使用 MATLAB 处理数据的基本元素，学习本节的内容可以掌握基本的如何处理矩阵。  \n> 本次的内容几乎都可以凭借线性代数的了解来学习，代码块中的代码可以 复制粘贴到 MATLAB 中运行，或者将一个代码块复制到一个新文件选择单步运行（step run），在该命令下每次只执行一个语句，逐个观察输出即可。部分函数的用法很多不能穷举，举出来的函数一般来说足够使用，读者在使用之前也可以先调用 help 命令查看该函数的其他用法。  \n\n<!--more-->\n----------\n\n\n### **创建矩阵**\n在上一节中，我们认识了 MATLAB 的基本操作，其中一种定义变量的方法为直接赋值如：a=1，事实上，这种操作的本质上就是定义了一个最简单的 1×1 的矩阵（这一现象可以在 workspace 中观察到）。\n一个矩阵的基本形式可以表达为以下形式 \n\n```\n% 两种形式是完全等价的，但是更推荐使用第一种形式。\n[1,2,3,4;-5,6,7,8] \n[1 2 3 4;-5 6 7 8]  \n% 个人推荐第一种表达形式的原因：\n[1,2,3,4;-5,-6,-7,8] % 正确\n[1 2 3 4;-5 -6 -7 8] % 正确\n[1 2 3 4;- 5 -6 -7 8] % 正确\n% [1 2 3 4;- 5 - 6 -7 8] % 错误，这样的表示会让计算机误判为（-5-6）是一个变量\n```\n\n其中，上述矩阵为行数为 2，列数为 4 的矩阵，一个 MATLAB 矩阵遵循以下原则；\n\n - 矩阵的元素以方括号包含；\n - 同一行不同列以逗号分隔；\n - 同一列不同行以分号分隔； \n - 每行（或者每列）必须有相同数量的元素；\n - 矩阵元素可以是数值（不区分整数，浮点数和复数）或者字符串之一。    \n\n#### 1.直接创建\n一般来说可以使用直接赋值的思路直接创建，如下所示：\n```\n% 创建一维行向量（行矩阵）;\na = [1,2,3,4];\n% 创建一维列向量（列矩阵）;\nb = [1;2;3;4];\n% 创建二维矩阵;\nc = [4,6,-6;2,-3,0;-9,5,7];\n% 矩阵元素可以是表达式\nd = [1+2,3 * 4,5];\n% 矩阵可以为字符矩阵(不是字符串矩阵)\nstr = ['hello world']; % 单行字符矩阵\nstr1 = ['hello',' ','world']; % 单行字符矩阵\n% str2 = ['hello'; ' ';'world'];% 报错！每一行字符数量不等长。\n%矩阵的一些特殊值\ne = [eps,inf,-inf,nan,pi,i,j];\n% eps 绝对值最小的浮点数（机器所能表示的最小分度）；\n% inf 正无穷大 1/0；\n% -inf 负无穷大 -1/0；\n% nan(或者 NaN) 无意义的数（Not a Number）0/0；\n% pi 圆周率 π 的值\n% i 虚数单位\n% j 还是虚数单位（EE 工程师专用版本）\n% 绝对不要用以上的名字作为变量名！\n% 绝对不要用以上的名字作为变量名！\n% 绝对不要用以上的名字作为变量名！\n```\n事实上，这种直接赋值的方法实在过于费时费力，我们通常还会使用另一种方法：用冒号运算符创建等差数列(a:b:c)\n```\n1:2:10 % (a:b:c)中 a 为等差数列首项的值，b 为公差，c 为区间限，数列储存为行向量；\n1:10 % b = 1时，b 可以省略；\n10:-2:1 % 公差也可以是负数；\n1:-2:10 % 等差数列找不到区间限 c 时（或者 b=0），会返回空矩阵；\n2.^(1:5) % 加上指数操作就成了等比数列\n```\n#### 2.调用函数\nMATLAB 的库函数中含有很多快速创建矩阵的函数，常见的有：ones，zeros，eye，rand，magic，true，false，这里逐项给出说明：  \n\nones 函数\n```\nones(n); % 创建 n×n 的方阵，每个元素的值都为 1；\nones(m,n); % 创建 m×n 的矩阵，每个元素的值都为 1；\nones(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 1；\n```\nzeros 函数\n```\nzeros(n); % 创建 n×n 的方阵，每个元素的值都为 0；\nzeros(m,n); % 创建 m×n 的矩阵，每个元素的值都为 0；\nzeros(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 0；\n```\neye 函数\n```\neye(n); % 创建 n×n 的单位阵，即正对角线上的每个元素的值都为 1；\n```\nrand 函数\n```\nrand(n); % 创建 n×n 的方阵，元素的值服从区间 0-1 的均匀随机分布；\nrand(m,n); % 创建 m×n 的矩阵，元素的值服从区间 0-1 的均匀随机分布；\nrand(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从区间 0-1 的均匀随机分布；\n```\nrandn 函数\n```\n% randn函数只是 rand 的变体，元素服从标准正态分布。\nrandn(n); % 创建 n×n 的方阵，元素的值服从标准正态分布；\nrandn(m,n); % 创建 m×n 的矩阵，元素的值服从标准正态分布；\nrandn(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从标准正态分布；\n```\nmagic 函数\n```\nmagic(n); % 创建 n×n 的方阵，该方阵满足每行每列对角线和相等；\n```\ntrue 函数\n```\ntrue(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；\n```\nfalse 函数\n```\nfalse(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；\n```\n这里还有另一类生成函数，能快速生成一维矩阵：linspace，logspace 等。\nlinspace 函数\n```\nlinspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个线性等分的点，返回间隔点向量；\nlinspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个线性等分的点，返回间隔点向量；\n% 这里补充一点，你可能觉得之前的基于冒号操作符（:）创建等差数列的方法也可以产生一样的结果\n% 但是二者是有本质区别的。\n% linspace 产生的结果是必然以 x2 作为最后一个变量，它实现的是区间的等分，并且 x1,x2 都可以是复数\n% 冒号操作符仅能从一端以公差检索，不能确保包含 x2；此外，x1 和 x2 都必须是实数。\n% 你也可以处于好奇尝试一下：n = 1;n <= 0;n 不是整数的情况，看看 linspace 的返回值。\n```\nlogspace 函数  \n```\nlogspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个对数间隔的点，返回间隔点向量；\nlogspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个对数间隔的点，返回间隔点向量；\n% 感觉吧，就是linspace的兄弟函数，x1 和 x2 都可以是复数\n% 你也可以处于好奇尝试一下：n = 1;n <= 0;n 不是整数的情况\n```\n\n----------\n\n\n### **运算符**  \n比较走运的是，MATLAB 中运算符的优先级和一般的数理知识并不冲突，运算符和变量不要求强制的空格，「我加空格纯粹为了美观，当然取负号时最好不要加空格」，因此只需要认识 MATLAB 的一些运算符，就可以比较容易的上手矩阵运算。矩阵的运算这一部分的内容与线性代数的内容一致，已经有线性代数基础的应该容易理解，没有线性代数的基础的同学建议单步执行以下命令，仔细观察结果的变化，熟悉这些运算符的作用。  \n运算符操作总体上分为两类：数组运算符和矩阵运算符。 \n\n#### 1.数组运算符  \n数组运算符可以理解为针对矩阵元素的运算，与矩阵本身的性质无关，也是逐个的运算。\n```\n%% 数组运算符\n% 测试样例\na = [2,3,-4;6,7,8] % 2×3 的矩阵\nb = [1,2,-1;2,1,1] % 2×3 的矩阵\n\n% 一元加运算符（+）相当于数学上的正号\n+a % 相当于数学上的正号，鸡肋无疑，实际上并没有什么作用。\n\n% 一元减运算符（-）相当于数学上的正号\n-a % 相当于数学上的取负号，返回相反数。\n\n% 二元加运算符（+）和减运算符（-）的规则与线性代数一致;\n% 这一类的二元运算符存在三种情况：标量 + 标量，矩阵 + 标量，矩阵 + 矩阵\na + 1 % 矩阵 + 标量的结果，矩阵中每个值都加上该标量；\na + b % 矩阵 + 矩阵的结果，矩阵中每个值都加上该标量；\n% a + [1,0;0,1] % 此时语句报错，矩阵 + 矩阵运算时，必须要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素乘运算符（.*）是逐元素操作的，也就是对应矩阵元素位置的相乘\na .* 2 % 矩阵 .* 标量的结果，矩阵中每个值都加上该标量；\na .* b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素乘方运算符（.^）是逐元素操作的，也就是对应矩阵元素位置的乘方\na .^ 2 % 矩阵 .^ 标量的结果，矩阵中每个值都为对应位置元素的标量次幂；\n2 .^ a % 标量 .^ 矩阵的结果，矩阵中每个值都为以该标量为底，以对应位置元素为指数的值；\na .^ b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素右除运算符（./）是逐元素操作的，也就是对应矩阵元素位置的右除\na ./ 2 % 矩阵 ./ 标量返回一个商矩阵，矩阵元素为被除数，该标量为除数；\n2 ./ a % 标量 ./ 矩阵返回一个商矩阵，该标量为被除数，矩阵元素为除数；\na ./ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为被除数，右矩阵元素为除数\n% 这时要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素左除运算符（.\\）是逐元素操作的，也就是对应矩阵元素位置的左除\na .\\ 2 % 矩阵 .\\ 标量返回一个商矩阵，矩阵元素为除数，该标量为被除数；\n2 .\\ a % 矩阵 .\\ 标量返回一个商矩阵，该标量为除数，矩阵元素为被除数；\na .\\ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为除数，右矩阵元素为被除数\n% 这时要求矩阵的维度匹配（行列数量一致）；\n\n% 提醒：左除右除运算符的区别只要记住斜杠上的是分子，斜杠下的为分母即可。\n\n% 数组转置（.'），行列交换得到转置矩阵\na.' % 返回矩阵的数组转置，相当于矩阵的行和列互换，得到新的矩阵；\n```\n#### 2.矩阵运算符  \n```\n%% 矩阵运算符\n% 测试样例\na = [2,3,-4;6,7,8] % 2×3的矩阵\nb = [0,1,-5,3;2,-3,5,5;-1,4,2,3] % 3×4的矩阵\nc = [1;2]\n\n% 矩阵乘法运算符（*） 矩阵相乘得到线性代数上的矩阵乘积，\na * 2 % 矩阵 * 标量的结果，矩阵中每个值都加上该标量；\na * b % 满足矩阵相乘的规则，要求矩阵的维度匹配（左矩阵列 = 右矩阵行）；\n\n% 矩阵乘方运算符（^）矩阵必须为方阵(或者标量)，\n[0,1;2,0] ^ 2  % 矩阵 .^ 标量，方阵的标量次幂；\n2 .* [0,1;2,0] % 标量 .^ 矩阵基于特征值和特征向量求解，线性代数内容（个人目前还没用过）；\n\n% 矩阵左除运算符（\\）矩阵左除（线性代数没有这玩意）\n% 注解：线性方程组如果可以表示为 A*x=B，那么解方程组时就应该在两式用 A 的逆阵（暂且叫做 Ai）左乘，这时式子化为 x=Ai*B，矩阵左除运算结果 A\\B=Ai*B。同理可以推演右除\na \\ c % 矩阵\\矩阵相当于解线性方程组 a*x=c\n\n% 矩阵右除运算符（/）矩阵右除\na \\ c % 矩阵\\矩阵相当于解线性方程组x*a=c\n\n% 共轭转置（'），针对与矩阵而言，行列交换并求共轭得到共轭转置矩阵\na' % 返回矩阵的共轭转置，相当于矩阵的行和列互换再求共轭，得到新的矩阵;\n% 但是由于一般都是操作实数，取共轭不会有影响，平时更常用（'）而不使用（.'）；\n```\n\n----------\n\n\n### **小结**\n本次的内容几乎都只要复制粘贴到 MATLAB 中执行即可，几乎只需要观察即可。生成函数很多不需要死记，函数名几乎可以直译，开始用几次就可以无压力记住（即使记错了某个字母，MATLAB 也会提示正确的名字）。\n\n\n\n\n","source":"_posts/MATLAB-矩阵（一）.md","raw":"---\ntitle: MATLAB 矩阵（一）\ndate: 2018-03-03 03:46:31\ntags: MATLAB\n---\n\n----------\n\n### **概述**\n本次内容涉及 MATLAB 中的矩阵，这是我们使用 MATLAB 处理数据的基本元素，学习本节的内容可以掌握基本的如何处理矩阵。  \n> 本次的内容几乎都可以凭借线性代数的了解来学习，代码块中的代码可以 复制粘贴到 MATLAB 中运行，或者将一个代码块复制到一个新文件选择单步运行（step run），在该命令下每次只执行一个语句，逐个观察输出即可。部分函数的用法很多不能穷举，举出来的函数一般来说足够使用，读者在使用之前也可以先调用 help 命令查看该函数的其他用法。  \n\n<!--more-->\n----------\n\n\n### **创建矩阵**\n在上一节中，我们认识了 MATLAB 的基本操作，其中一种定义变量的方法为直接赋值如：a=1，事实上，这种操作的本质上就是定义了一个最简单的 1×1 的矩阵（这一现象可以在 workspace 中观察到）。\n一个矩阵的基本形式可以表达为以下形式 \n\n```\n% 两种形式是完全等价的，但是更推荐使用第一种形式。\n[1,2,3,4;-5,6,7,8] \n[1 2 3 4;-5 6 7 8]  \n% 个人推荐第一种表达形式的原因：\n[1,2,3,4;-5,-6,-7,8] % 正确\n[1 2 3 4;-5 -6 -7 8] % 正确\n[1 2 3 4;- 5 -6 -7 8] % 正确\n% [1 2 3 4;- 5 - 6 -7 8] % 错误，这样的表示会让计算机误判为（-5-6）是一个变量\n```\n\n其中，上述矩阵为行数为 2，列数为 4 的矩阵，一个 MATLAB 矩阵遵循以下原则；\n\n - 矩阵的元素以方括号包含；\n - 同一行不同列以逗号分隔；\n - 同一列不同行以分号分隔； \n - 每行（或者每列）必须有相同数量的元素；\n - 矩阵元素可以是数值（不区分整数，浮点数和复数）或者字符串之一。    \n\n#### 1.直接创建\n一般来说可以使用直接赋值的思路直接创建，如下所示：\n```\n% 创建一维行向量（行矩阵）;\na = [1,2,3,4];\n% 创建一维列向量（列矩阵）;\nb = [1;2;3;4];\n% 创建二维矩阵;\nc = [4,6,-6;2,-3,0;-9,5,7];\n% 矩阵元素可以是表达式\nd = [1+2,3 * 4,5];\n% 矩阵可以为字符矩阵(不是字符串矩阵)\nstr = ['hello world']; % 单行字符矩阵\nstr1 = ['hello',' ','world']; % 单行字符矩阵\n% str2 = ['hello'; ' ';'world'];% 报错！每一行字符数量不等长。\n%矩阵的一些特殊值\ne = [eps,inf,-inf,nan,pi,i,j];\n% eps 绝对值最小的浮点数（机器所能表示的最小分度）；\n% inf 正无穷大 1/0；\n% -inf 负无穷大 -1/0；\n% nan(或者 NaN) 无意义的数（Not a Number）0/0；\n% pi 圆周率 π 的值\n% i 虚数单位\n% j 还是虚数单位（EE 工程师专用版本）\n% 绝对不要用以上的名字作为变量名！\n% 绝对不要用以上的名字作为变量名！\n% 绝对不要用以上的名字作为变量名！\n```\n事实上，这种直接赋值的方法实在过于费时费力，我们通常还会使用另一种方法：用冒号运算符创建等差数列(a:b:c)\n```\n1:2:10 % (a:b:c)中 a 为等差数列首项的值，b 为公差，c 为区间限，数列储存为行向量；\n1:10 % b = 1时，b 可以省略；\n10:-2:1 % 公差也可以是负数；\n1:-2:10 % 等差数列找不到区间限 c 时（或者 b=0），会返回空矩阵；\n2.^(1:5) % 加上指数操作就成了等比数列\n```\n#### 2.调用函数\nMATLAB 的库函数中含有很多快速创建矩阵的函数，常见的有：ones，zeros，eye，rand，magic，true，false，这里逐项给出说明：  \n\nones 函数\n```\nones(n); % 创建 n×n 的方阵，每个元素的值都为 1；\nones(m,n); % 创建 m×n 的矩阵，每个元素的值都为 1；\nones(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 1；\n```\nzeros 函数\n```\nzeros(n); % 创建 n×n 的方阵，每个元素的值都为 0；\nzeros(m,n); % 创建 m×n 的矩阵，每个元素的值都为 0；\nzeros(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 0；\n```\neye 函数\n```\neye(n); % 创建 n×n 的单位阵，即正对角线上的每个元素的值都为 1；\n```\nrand 函数\n```\nrand(n); % 创建 n×n 的方阵，元素的值服从区间 0-1 的均匀随机分布；\nrand(m,n); % 创建 m×n 的矩阵，元素的值服从区间 0-1 的均匀随机分布；\nrand(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从区间 0-1 的均匀随机分布；\n```\nrandn 函数\n```\n% randn函数只是 rand 的变体，元素服从标准正态分布。\nrandn(n); % 创建 n×n 的方阵，元素的值服从标准正态分布；\nrandn(m,n); % 创建 m×n 的矩阵，元素的值服从标准正态分布；\nrandn(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从标准正态分布；\n```\nmagic 函数\n```\nmagic(n); % 创建 n×n 的方阵，该方阵满足每行每列对角线和相等；\n```\ntrue 函数\n```\ntrue(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；\n```\nfalse 函数\n```\nfalse(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；\n```\n这里还有另一类生成函数，能快速生成一维矩阵：linspace，logspace 等。\nlinspace 函数\n```\nlinspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个线性等分的点，返回间隔点向量；\nlinspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个线性等分的点，返回间隔点向量；\n% 这里补充一点，你可能觉得之前的基于冒号操作符（:）创建等差数列的方法也可以产生一样的结果\n% 但是二者是有本质区别的。\n% linspace 产生的结果是必然以 x2 作为最后一个变量，它实现的是区间的等分，并且 x1,x2 都可以是复数\n% 冒号操作符仅能从一端以公差检索，不能确保包含 x2；此外，x1 和 x2 都必须是实数。\n% 你也可以处于好奇尝试一下：n = 1;n <= 0;n 不是整数的情况，看看 linspace 的返回值。\n```\nlogspace 函数  \n```\nlogspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个对数间隔的点，返回间隔点向量；\nlogspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个对数间隔的点，返回间隔点向量；\n% 感觉吧，就是linspace的兄弟函数，x1 和 x2 都可以是复数\n% 你也可以处于好奇尝试一下：n = 1;n <= 0;n 不是整数的情况\n```\n\n----------\n\n\n### **运算符**  \n比较走运的是，MATLAB 中运算符的优先级和一般的数理知识并不冲突，运算符和变量不要求强制的空格，「我加空格纯粹为了美观，当然取负号时最好不要加空格」，因此只需要认识 MATLAB 的一些运算符，就可以比较容易的上手矩阵运算。矩阵的运算这一部分的内容与线性代数的内容一致，已经有线性代数基础的应该容易理解，没有线性代数的基础的同学建议单步执行以下命令，仔细观察结果的变化，熟悉这些运算符的作用。  \n运算符操作总体上分为两类：数组运算符和矩阵运算符。 \n\n#### 1.数组运算符  \n数组运算符可以理解为针对矩阵元素的运算，与矩阵本身的性质无关，也是逐个的运算。\n```\n%% 数组运算符\n% 测试样例\na = [2,3,-4;6,7,8] % 2×3 的矩阵\nb = [1,2,-1;2,1,1] % 2×3 的矩阵\n\n% 一元加运算符（+）相当于数学上的正号\n+a % 相当于数学上的正号，鸡肋无疑，实际上并没有什么作用。\n\n% 一元减运算符（-）相当于数学上的正号\n-a % 相当于数学上的取负号，返回相反数。\n\n% 二元加运算符（+）和减运算符（-）的规则与线性代数一致;\n% 这一类的二元运算符存在三种情况：标量 + 标量，矩阵 + 标量，矩阵 + 矩阵\na + 1 % 矩阵 + 标量的结果，矩阵中每个值都加上该标量；\na + b % 矩阵 + 矩阵的结果，矩阵中每个值都加上该标量；\n% a + [1,0;0,1] % 此时语句报错，矩阵 + 矩阵运算时，必须要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素乘运算符（.*）是逐元素操作的，也就是对应矩阵元素位置的相乘\na .* 2 % 矩阵 .* 标量的结果，矩阵中每个值都加上该标量；\na .* b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素乘方运算符（.^）是逐元素操作的，也就是对应矩阵元素位置的乘方\na .^ 2 % 矩阵 .^ 标量的结果，矩阵中每个值都为对应位置元素的标量次幂；\n2 .^ a % 标量 .^ 矩阵的结果，矩阵中每个值都为以该标量为底，以对应位置元素为指数的值；\na .^ b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素右除运算符（./）是逐元素操作的，也就是对应矩阵元素位置的右除\na ./ 2 % 矩阵 ./ 标量返回一个商矩阵，矩阵元素为被除数，该标量为除数；\n2 ./ a % 标量 ./ 矩阵返回一个商矩阵，该标量为被除数，矩阵元素为除数；\na ./ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为被除数，右矩阵元素为除数\n% 这时要求矩阵的维度匹配（行列数量一致）；\n\n% 逐元素左除运算符（.\\）是逐元素操作的，也就是对应矩阵元素位置的左除\na .\\ 2 % 矩阵 .\\ 标量返回一个商矩阵，矩阵元素为除数，该标量为被除数；\n2 .\\ a % 矩阵 .\\ 标量返回一个商矩阵，该标量为除数，矩阵元素为被除数；\na .\\ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为除数，右矩阵元素为被除数\n% 这时要求矩阵的维度匹配（行列数量一致）；\n\n% 提醒：左除右除运算符的区别只要记住斜杠上的是分子，斜杠下的为分母即可。\n\n% 数组转置（.'），行列交换得到转置矩阵\na.' % 返回矩阵的数组转置，相当于矩阵的行和列互换，得到新的矩阵；\n```\n#### 2.矩阵运算符  \n```\n%% 矩阵运算符\n% 测试样例\na = [2,3,-4;6,7,8] % 2×3的矩阵\nb = [0,1,-5,3;2,-3,5,5;-1,4,2,3] % 3×4的矩阵\nc = [1;2]\n\n% 矩阵乘法运算符（*） 矩阵相乘得到线性代数上的矩阵乘积，\na * 2 % 矩阵 * 标量的结果，矩阵中每个值都加上该标量；\na * b % 满足矩阵相乘的规则，要求矩阵的维度匹配（左矩阵列 = 右矩阵行）；\n\n% 矩阵乘方运算符（^）矩阵必须为方阵(或者标量)，\n[0,1;2,0] ^ 2  % 矩阵 .^ 标量，方阵的标量次幂；\n2 .* [0,1;2,0] % 标量 .^ 矩阵基于特征值和特征向量求解，线性代数内容（个人目前还没用过）；\n\n% 矩阵左除运算符（\\）矩阵左除（线性代数没有这玩意）\n% 注解：线性方程组如果可以表示为 A*x=B，那么解方程组时就应该在两式用 A 的逆阵（暂且叫做 Ai）左乘，这时式子化为 x=Ai*B，矩阵左除运算结果 A\\B=Ai*B。同理可以推演右除\na \\ c % 矩阵\\矩阵相当于解线性方程组 a*x=c\n\n% 矩阵右除运算符（/）矩阵右除\na \\ c % 矩阵\\矩阵相当于解线性方程组x*a=c\n\n% 共轭转置（'），针对与矩阵而言，行列交换并求共轭得到共轭转置矩阵\na' % 返回矩阵的共轭转置，相当于矩阵的行和列互换再求共轭，得到新的矩阵;\n% 但是由于一般都是操作实数，取共轭不会有影响，平时更常用（'）而不使用（.'）；\n```\n\n----------\n\n\n### **小结**\n本次的内容几乎都只要复制粘贴到 MATLAB 中执行即可，几乎只需要观察即可。生成函数很多不需要死记，函数名几乎可以直译，开始用几次就可以无压力记住（即使记错了某个字母，MATLAB 也会提示正确的名字）。\n\n\n\n\n","slug":"MATLAB-矩阵（一）","published":1,"updated":"2020-03-15T21:05:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wh000k29fyxnqlxwsy","content":"<hr>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>本次内容涉及 MATLAB 中的矩阵，这是我们使用 MATLAB 处理数据的基本元素，学习本节的内容可以掌握基本的如何处理矩阵。  </p>\n<blockquote>\n<p>本次的内容几乎都可以凭借线性代数的了解来学习，代码块中的代码可以 复制粘贴到 MATLAB 中运行，或者将一个代码块复制到一个新文件选择单步运行（step run），在该命令下每次只执行一个语句，逐个观察输出即可。部分函数的用法很多不能穷举，举出来的函数一般来说足够使用，读者在使用之前也可以先调用 help 命令查看该函数的其他用法。  </p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"创建矩阵\"><a href=\"#创建矩阵\" class=\"headerlink\" title=\"创建矩阵\"></a><strong>创建矩阵</strong></h3><p>在上一节中，我们认识了 MATLAB 的基本操作，其中一种定义变量的方法为直接赋值如：a=1，事实上，这种操作的本质上就是定义了一个最简单的 1×1 的矩阵（这一现象可以在 workspace 中观察到）。<br>一个矩阵的基本形式可以表达为以下形式 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 两种形式是完全等价的，但是更推荐使用第一种形式。</span><br><span class=\"line\">[1,2,3,4;-5,6,7,8] </span><br><span class=\"line\">[1 2 3 4;-5 6 7 8]  </span><br><span class=\"line\">% 个人推荐第一种表达形式的原因：</span><br><span class=\"line\">[1,2,3,4;-5,-6,-7,8] % 正确</span><br><span class=\"line\">[1 2 3 4;-5 -6 -7 8] % 正确</span><br><span class=\"line\">[1 2 3 4;- 5 -6 -7 8] % 正确</span><br><span class=\"line\">% [1 2 3 4;- 5 - 6 -7 8] % 错误，这样的表示会让计算机误判为（-5-6）是一个变量</span><br></pre></td></tr></table></figure>\n\n<p>其中，上述矩阵为行数为 2，列数为 4 的矩阵，一个 MATLAB 矩阵遵循以下原则；</p>\n<ul>\n<li>矩阵的元素以方括号包含；</li>\n<li>同一行不同列以逗号分隔；</li>\n<li>同一列不同行以分号分隔； </li>\n<li>每行（或者每列）必须有相同数量的元素；</li>\n<li>矩阵元素可以是数值（不区分整数，浮点数和复数）或者字符串之一。    </li>\n</ul>\n<h4 id=\"1-直接创建\"><a href=\"#1-直接创建\" class=\"headerlink\" title=\"1.直接创建\"></a>1.直接创建</h4><p>一般来说可以使用直接赋值的思路直接创建，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 创建一维行向量（行矩阵）;</span><br><span class=\"line\">a = [1,2,3,4];</span><br><span class=\"line\">% 创建一维列向量（列矩阵）;</span><br><span class=\"line\">b = [1;2;3;4];</span><br><span class=\"line\">% 创建二维矩阵;</span><br><span class=\"line\">c = [4,6,-6;2,-3,0;-9,5,7];</span><br><span class=\"line\">% 矩阵元素可以是表达式</span><br><span class=\"line\">d = [1+2,3 * 4,5];</span><br><span class=\"line\">% 矩阵可以为字符矩阵(不是字符串矩阵)</span><br><span class=\"line\">str = [&apos;hello world&apos;]; % 单行字符矩阵</span><br><span class=\"line\">str1 = [&apos;hello&apos;,&apos; &apos;,&apos;world&apos;]; % 单行字符矩阵</span><br><span class=\"line\">% str2 = [&apos;hello&apos;; &apos; &apos;;&apos;world&apos;];% 报错！每一行字符数量不等长。</span><br><span class=\"line\">%矩阵的一些特殊值</span><br><span class=\"line\">e = [eps,inf,-inf,nan,pi,i,j];</span><br><span class=\"line\">% eps 绝对值最小的浮点数（机器所能表示的最小分度）；</span><br><span class=\"line\">% inf 正无穷大 1/0；</span><br><span class=\"line\">% -inf 负无穷大 -1/0；</span><br><span class=\"line\">% nan(或者 NaN) 无意义的数（Not a Number）0/0；</span><br><span class=\"line\">% pi 圆周率 π 的值</span><br><span class=\"line\">% i 虚数单位</span><br><span class=\"line\">% j 还是虚数单位（EE 工程师专用版本）</span><br><span class=\"line\">% 绝对不要用以上的名字作为变量名！</span><br><span class=\"line\">% 绝对不要用以上的名字作为变量名！</span><br><span class=\"line\">% 绝对不要用以上的名字作为变量名！</span><br></pre></td></tr></table></figure>\n\n<p>事实上，这种直接赋值的方法实在过于费时费力，我们通常还会使用另一种方法：用冒号运算符创建等差数列(a:b:c)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1:2:10 % (a:b:c)中 a 为等差数列首项的值，b 为公差，c 为区间限，数列储存为行向量；</span><br><span class=\"line\">1:10 % b = 1时，b 可以省略；</span><br><span class=\"line\">10:-2:1 % 公差也可以是负数；</span><br><span class=\"line\">1:-2:10 % 等差数列找不到区间限 c 时（或者 b=0），会返回空矩阵；</span><br><span class=\"line\">2.^(1:5) % 加上指数操作就成了等比数列</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-调用函数\"><a href=\"#2-调用函数\" class=\"headerlink\" title=\"2.调用函数\"></a>2.调用函数</h4><p>MATLAB 的库函数中含有很多快速创建矩阵的函数，常见的有：ones，zeros，eye，rand，magic，true，false，这里逐项给出说明：  </p>\n<p>ones 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ones(n); % 创建 n×n 的方阵，每个元素的值都为 1；</span><br><span class=\"line\">ones(m,n); % 创建 m×n 的矩阵，每个元素的值都为 1；</span><br><span class=\"line\">ones(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 1；</span><br></pre></td></tr></table></figure>\n\n<p>zeros 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zeros(n); % 创建 n×n 的方阵，每个元素的值都为 0；</span><br><span class=\"line\">zeros(m,n); % 创建 m×n 的矩阵，每个元素的值都为 0；</span><br><span class=\"line\">zeros(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 0；</span><br></pre></td></tr></table></figure>\n\n<p>eye 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eye(n); % 创建 n×n 的单位阵，即正对角线上的每个元素的值都为 1；</span><br></pre></td></tr></table></figure>\n\n<p>rand 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rand(n); % 创建 n×n 的方阵，元素的值服从区间 0-1 的均匀随机分布；</span><br><span class=\"line\">rand(m,n); % 创建 m×n 的矩阵，元素的值服从区间 0-1 的均匀随机分布；</span><br><span class=\"line\">rand(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从区间 0-1 的均匀随机分布；</span><br></pre></td></tr></table></figure>\n\n<p>randn 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% randn函数只是 rand 的变体，元素服从标准正态分布。</span><br><span class=\"line\">randn(n); % 创建 n×n 的方阵，元素的值服从标准正态分布；</span><br><span class=\"line\">randn(m,n); % 创建 m×n 的矩阵，元素的值服从标准正态分布；</span><br><span class=\"line\">randn(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从标准正态分布；</span><br></pre></td></tr></table></figure>\n\n<p>magic 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">magic(n); % 创建 n×n 的方阵，该方阵满足每行每列对角线和相等；</span><br></pre></td></tr></table></figure>\n\n<p>true 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">true(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；</span><br></pre></td></tr></table></figure>\n\n<p>false 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；</span><br></pre></td></tr></table></figure>\n\n<p>这里还有另一类生成函数，能快速生成一维矩阵：linspace，logspace 等。<br>linspace 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个线性等分的点，返回间隔点向量；</span><br><span class=\"line\">linspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个线性等分的点，返回间隔点向量；</span><br><span class=\"line\">% 这里补充一点，你可能觉得之前的基于冒号操作符（:）创建等差数列的方法也可以产生一样的结果</span><br><span class=\"line\">% 但是二者是有本质区别的。</span><br><span class=\"line\">% linspace 产生的结果是必然以 x2 作为最后一个变量，它实现的是区间的等分，并且 x1,x2 都可以是复数</span><br><span class=\"line\">% 冒号操作符仅能从一端以公差检索，不能确保包含 x2；此外，x1 和 x2 都必须是实数。</span><br><span class=\"line\">% 你也可以处于好奇尝试一下：n = 1;n &lt;= 0;n 不是整数的情况，看看 linspace 的返回值。</span><br></pre></td></tr></table></figure>\n\n<p>logspace 函数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个对数间隔的点，返回间隔点向量；</span><br><span class=\"line\">logspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个对数间隔的点，返回间隔点向量；</span><br><span class=\"line\">% 感觉吧，就是linspace的兄弟函数，x1 和 x2 都可以是复数</span><br><span class=\"line\">% 你也可以处于好奇尝试一下：n = 1;n &lt;= 0;n 不是整数的情况</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a><strong>运算符</strong></h3><p>比较走运的是，MATLAB 中运算符的优先级和一般的数理知识并不冲突，运算符和变量不要求强制的空格，「我加空格纯粹为了美观，当然取负号时最好不要加空格」，因此只需要认识 MATLAB 的一些运算符，就可以比较容易的上手矩阵运算。矩阵的运算这一部分的内容与线性代数的内容一致，已经有线性代数基础的应该容易理解，没有线性代数的基础的同学建议单步执行以下命令，仔细观察结果的变化，熟悉这些运算符的作用。<br>运算符操作总体上分为两类：数组运算符和矩阵运算符。 </p>\n<h4 id=\"1-数组运算符\"><a href=\"#1-数组运算符\" class=\"headerlink\" title=\"1.数组运算符\"></a>1.数组运算符</h4><p>数组运算符可以理解为针对矩阵元素的运算，与矩阵本身的性质无关，也是逐个的运算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 数组运算符</span><br><span class=\"line\">% 测试样例</span><br><span class=\"line\">a = [2,3,-4;6,7,8] % 2×3 的矩阵</span><br><span class=\"line\">b = [1,2,-1;2,1,1] % 2×3 的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">% 一元加运算符（+）相当于数学上的正号</span><br><span class=\"line\">+a % 相当于数学上的正号，鸡肋无疑，实际上并没有什么作用。</span><br><span class=\"line\"></span><br><span class=\"line\">% 一元减运算符（-）相当于数学上的正号</span><br><span class=\"line\">-a % 相当于数学上的取负号，返回相反数。</span><br><span class=\"line\"></span><br><span class=\"line\">% 二元加运算符（+）和减运算符（-）的规则与线性代数一致;</span><br><span class=\"line\">% 这一类的二元运算符存在三种情况：标量 + 标量，矩阵 + 标量，矩阵 + 矩阵</span><br><span class=\"line\">a + 1 % 矩阵 + 标量的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">a + b % 矩阵 + 矩阵的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">% a + [1,0;0,1] % 此时语句报错，矩阵 + 矩阵运算时，必须要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素乘运算符（.*）是逐元素操作的，也就是对应矩阵元素位置的相乘</span><br><span class=\"line\">a .* 2 % 矩阵 .* 标量的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">a .* b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素乘方运算符（.^）是逐元素操作的，也就是对应矩阵元素位置的乘方</span><br><span class=\"line\">a .^ 2 % 矩阵 .^ 标量的结果，矩阵中每个值都为对应位置元素的标量次幂；</span><br><span class=\"line\">2 .^ a % 标量 .^ 矩阵的结果，矩阵中每个值都为以该标量为底，以对应位置元素为指数的值；</span><br><span class=\"line\">a .^ b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素右除运算符（./）是逐元素操作的，也就是对应矩阵元素位置的右除</span><br><span class=\"line\">a ./ 2 % 矩阵 ./ 标量返回一个商矩阵，矩阵元素为被除数，该标量为除数；</span><br><span class=\"line\">2 ./ a % 标量 ./ 矩阵返回一个商矩阵，该标量为被除数，矩阵元素为除数；</span><br><span class=\"line\">a ./ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为被除数，右矩阵元素为除数</span><br><span class=\"line\">% 这时要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素左除运算符（.\\）是逐元素操作的，也就是对应矩阵元素位置的左除</span><br><span class=\"line\">a .\\ 2 % 矩阵 .\\ 标量返回一个商矩阵，矩阵元素为除数，该标量为被除数；</span><br><span class=\"line\">2 .\\ a % 矩阵 .\\ 标量返回一个商矩阵，该标量为除数，矩阵元素为被除数；</span><br><span class=\"line\">a .\\ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为除数，右矩阵元素为被除数</span><br><span class=\"line\">% 这时要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 提醒：左除右除运算符的区别只要记住斜杠上的是分子，斜杠下的为分母即可。</span><br><span class=\"line\"></span><br><span class=\"line\">% 数组转置（.&apos;），行列交换得到转置矩阵</span><br><span class=\"line\">a.&apos; % 返回矩阵的数组转置，相当于矩阵的行和列互换，得到新的矩阵；</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-矩阵运算符\"><a href=\"#2-矩阵运算符\" class=\"headerlink\" title=\"2.矩阵运算符\"></a>2.矩阵运算符</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 矩阵运算符</span><br><span class=\"line\">% 测试样例</span><br><span class=\"line\">a = [2,3,-4;6,7,8] % 2×3的矩阵</span><br><span class=\"line\">b = [0,1,-5,3;2,-3,5,5;-1,4,2,3] % 3×4的矩阵</span><br><span class=\"line\">c = [1;2]</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵乘法运算符（*） 矩阵相乘得到线性代数上的矩阵乘积，</span><br><span class=\"line\">a * 2 % 矩阵 * 标量的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">a * b % 满足矩阵相乘的规则，要求矩阵的维度匹配（左矩阵列 = 右矩阵行）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵乘方运算符（^）矩阵必须为方阵(或者标量)，</span><br><span class=\"line\">[0,1;2,0] ^ 2  % 矩阵 .^ 标量，方阵的标量次幂；</span><br><span class=\"line\">2 .* [0,1;2,0] % 标量 .^ 矩阵基于特征值和特征向量求解，线性代数内容（个人目前还没用过）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵左除运算符（\\）矩阵左除（线性代数没有这玩意）</span><br><span class=\"line\">% 注解：线性方程组如果可以表示为 A*x=B，那么解方程组时就应该在两式用 A 的逆阵（暂且叫做 Ai）左乘，这时式子化为 x=Ai*B，矩阵左除运算结果 A\\B=Ai*B。同理可以推演右除</span><br><span class=\"line\">a \\ c % 矩阵\\矩阵相当于解线性方程组 a*x=c</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵右除运算符（/）矩阵右除</span><br><span class=\"line\">a \\ c % 矩阵\\矩阵相当于解线性方程组x*a=c</span><br><span class=\"line\"></span><br><span class=\"line\">% 共轭转置（&apos;），针对与矩阵而言，行列交换并求共轭得到共轭转置矩阵</span><br><span class=\"line\">a&apos; % 返回矩阵的共轭转置，相当于矩阵的行和列互换再求共轭，得到新的矩阵;</span><br><span class=\"line\">% 但是由于一般都是操作实数，取共轭不会有影响，平时更常用（&apos;）而不使用（.&apos;）；</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>本次的内容几乎都只要复制粘贴到 MATLAB 中执行即可，几乎只需要观察即可。生成函数很多不需要死记，函数名几乎可以直译，开始用几次就可以无压力记住（即使记错了某个字母，MATLAB 也会提示正确的名字）。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>本次内容涉及 MATLAB 中的矩阵，这是我们使用 MATLAB 处理数据的基本元素，学习本节的内容可以掌握基本的如何处理矩阵。  </p>\n<blockquote>\n<p>本次的内容几乎都可以凭借线性代数的了解来学习，代码块中的代码可以 复制粘贴到 MATLAB 中运行，或者将一个代码块复制到一个新文件选择单步运行（step run），在该命令下每次只执行一个语句，逐个观察输出即可。部分函数的用法很多不能穷举，举出来的函数一般来说足够使用，读者在使用之前也可以先调用 help 命令查看该函数的其他用法。  </p>\n</blockquote>","more":"<hr>\n<h3 id=\"创建矩阵\"><a href=\"#创建矩阵\" class=\"headerlink\" title=\"创建矩阵\"></a><strong>创建矩阵</strong></h3><p>在上一节中，我们认识了 MATLAB 的基本操作，其中一种定义变量的方法为直接赋值如：a=1，事实上，这种操作的本质上就是定义了一个最简单的 1×1 的矩阵（这一现象可以在 workspace 中观察到）。<br>一个矩阵的基本形式可以表达为以下形式 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 两种形式是完全等价的，但是更推荐使用第一种形式。</span><br><span class=\"line\">[1,2,3,4;-5,6,7,8] </span><br><span class=\"line\">[1 2 3 4;-5 6 7 8]  </span><br><span class=\"line\">% 个人推荐第一种表达形式的原因：</span><br><span class=\"line\">[1,2,3,4;-5,-6,-7,8] % 正确</span><br><span class=\"line\">[1 2 3 4;-5 -6 -7 8] % 正确</span><br><span class=\"line\">[1 2 3 4;- 5 -6 -7 8] % 正确</span><br><span class=\"line\">% [1 2 3 4;- 5 - 6 -7 8] % 错误，这样的表示会让计算机误判为（-5-6）是一个变量</span><br></pre></td></tr></table></figure>\n\n<p>其中，上述矩阵为行数为 2，列数为 4 的矩阵，一个 MATLAB 矩阵遵循以下原则；</p>\n<ul>\n<li>矩阵的元素以方括号包含；</li>\n<li>同一行不同列以逗号分隔；</li>\n<li>同一列不同行以分号分隔； </li>\n<li>每行（或者每列）必须有相同数量的元素；</li>\n<li>矩阵元素可以是数值（不区分整数，浮点数和复数）或者字符串之一。    </li>\n</ul>\n<h4 id=\"1-直接创建\"><a href=\"#1-直接创建\" class=\"headerlink\" title=\"1.直接创建\"></a>1.直接创建</h4><p>一般来说可以使用直接赋值的思路直接创建，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 创建一维行向量（行矩阵）;</span><br><span class=\"line\">a = [1,2,3,4];</span><br><span class=\"line\">% 创建一维列向量（列矩阵）;</span><br><span class=\"line\">b = [1;2;3;4];</span><br><span class=\"line\">% 创建二维矩阵;</span><br><span class=\"line\">c = [4,6,-6;2,-3,0;-9,5,7];</span><br><span class=\"line\">% 矩阵元素可以是表达式</span><br><span class=\"line\">d = [1+2,3 * 4,5];</span><br><span class=\"line\">% 矩阵可以为字符矩阵(不是字符串矩阵)</span><br><span class=\"line\">str = [&apos;hello world&apos;]; % 单行字符矩阵</span><br><span class=\"line\">str1 = [&apos;hello&apos;,&apos; &apos;,&apos;world&apos;]; % 单行字符矩阵</span><br><span class=\"line\">% str2 = [&apos;hello&apos;; &apos; &apos;;&apos;world&apos;];% 报错！每一行字符数量不等长。</span><br><span class=\"line\">%矩阵的一些特殊值</span><br><span class=\"line\">e = [eps,inf,-inf,nan,pi,i,j];</span><br><span class=\"line\">% eps 绝对值最小的浮点数（机器所能表示的最小分度）；</span><br><span class=\"line\">% inf 正无穷大 1/0；</span><br><span class=\"line\">% -inf 负无穷大 -1/0；</span><br><span class=\"line\">% nan(或者 NaN) 无意义的数（Not a Number）0/0；</span><br><span class=\"line\">% pi 圆周率 π 的值</span><br><span class=\"line\">% i 虚数单位</span><br><span class=\"line\">% j 还是虚数单位（EE 工程师专用版本）</span><br><span class=\"line\">% 绝对不要用以上的名字作为变量名！</span><br><span class=\"line\">% 绝对不要用以上的名字作为变量名！</span><br><span class=\"line\">% 绝对不要用以上的名字作为变量名！</span><br></pre></td></tr></table></figure>\n\n<p>事实上，这种直接赋值的方法实在过于费时费力，我们通常还会使用另一种方法：用冒号运算符创建等差数列(a:b:c)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1:2:10 % (a:b:c)中 a 为等差数列首项的值，b 为公差，c 为区间限，数列储存为行向量；</span><br><span class=\"line\">1:10 % b = 1时，b 可以省略；</span><br><span class=\"line\">10:-2:1 % 公差也可以是负数；</span><br><span class=\"line\">1:-2:10 % 等差数列找不到区间限 c 时（或者 b=0），会返回空矩阵；</span><br><span class=\"line\">2.^(1:5) % 加上指数操作就成了等比数列</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-调用函数\"><a href=\"#2-调用函数\" class=\"headerlink\" title=\"2.调用函数\"></a>2.调用函数</h4><p>MATLAB 的库函数中含有很多快速创建矩阵的函数，常见的有：ones，zeros，eye，rand，magic，true，false，这里逐项给出说明：  </p>\n<p>ones 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ones(n); % 创建 n×n 的方阵，每个元素的值都为 1；</span><br><span class=\"line\">ones(m,n); % 创建 m×n 的矩阵，每个元素的值都为 1；</span><br><span class=\"line\">ones(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 1；</span><br></pre></td></tr></table></figure>\n\n<p>zeros 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zeros(n); % 创建 n×n 的方阵，每个元素的值都为 0；</span><br><span class=\"line\">zeros(m,n); % 创建 m×n 的矩阵，每个元素的值都为 0；</span><br><span class=\"line\">zeros(k,m,n); % 创建 k×m×n 的三维矩阵，每个元素的值都为 0；</span><br></pre></td></tr></table></figure>\n\n<p>eye 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eye(n); % 创建 n×n 的单位阵，即正对角线上的每个元素的值都为 1；</span><br></pre></td></tr></table></figure>\n\n<p>rand 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rand(n); % 创建 n×n 的方阵，元素的值服从区间 0-1 的均匀随机分布；</span><br><span class=\"line\">rand(m,n); % 创建 m×n 的矩阵，元素的值服从区间 0-1 的均匀随机分布；</span><br><span class=\"line\">rand(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从区间 0-1 的均匀随机分布；</span><br></pre></td></tr></table></figure>\n\n<p>randn 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% randn函数只是 rand 的变体，元素服从标准正态分布。</span><br><span class=\"line\">randn(n); % 创建 n×n 的方阵，元素的值服从标准正态分布；</span><br><span class=\"line\">randn(m,n); % 创建 m×n 的矩阵，元素的值服从标准正态分布；</span><br><span class=\"line\">randn(k,m,n); % 创建 k×m×n 的三维矩阵，元素的值服从标准正态分布；</span><br></pre></td></tr></table></figure>\n\n<p>magic 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">magic(n); % 创建 n×n 的方阵，该方阵满足每行每列对角线和相等；</span><br></pre></td></tr></table></figure>\n\n<p>true 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">true(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；</span><br></pre></td></tr></table></figure>\n\n<p>false 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false(n); % 创建 n×n 的逻辑方阵，该方阵所有元素都是 true；</span><br></pre></td></tr></table></figure>\n\n<p>这里还有另一类生成函数，能快速生成一维矩阵：linspace，logspace 等。<br>linspace 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">linspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个线性等分的点，返回间隔点向量；</span><br><span class=\"line\">linspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个线性等分的点，返回间隔点向量；</span><br><span class=\"line\">% 这里补充一点，你可能觉得之前的基于冒号操作符（:）创建等差数列的方法也可以产生一样的结果</span><br><span class=\"line\">% 但是二者是有本质区别的。</span><br><span class=\"line\">% linspace 产生的结果是必然以 x2 作为最后一个变量，它实现的是区间的等分，并且 x1,x2 都可以是复数</span><br><span class=\"line\">% 冒号操作符仅能从一端以公差检索，不能确保包含 x2；此外，x1 和 x2 都必须是实数。</span><br><span class=\"line\">% 你也可以处于好奇尝试一下：n = 1;n &lt;= 0;n 不是整数的情况，看看 linspace 的返回值。</span><br></pre></td></tr></table></figure>\n\n<p>logspace 函数  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logspace(x1,x2); % 直接将区间 x1-x2 划分为 100 个对数间隔的点，返回间隔点向量；</span><br><span class=\"line\">logspace(x1,x2,n); % 直接将区间 x1-x2 划分为 n 个对数间隔的点，返回间隔点向量；</span><br><span class=\"line\">% 感觉吧，就是linspace的兄弟函数，x1 和 x2 都可以是复数</span><br><span class=\"line\">% 你也可以处于好奇尝试一下：n = 1;n &lt;= 0;n 不是整数的情况</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a><strong>运算符</strong></h3><p>比较走运的是，MATLAB 中运算符的优先级和一般的数理知识并不冲突，运算符和变量不要求强制的空格，「我加空格纯粹为了美观，当然取负号时最好不要加空格」，因此只需要认识 MATLAB 的一些运算符，就可以比较容易的上手矩阵运算。矩阵的运算这一部分的内容与线性代数的内容一致，已经有线性代数基础的应该容易理解，没有线性代数的基础的同学建议单步执行以下命令，仔细观察结果的变化，熟悉这些运算符的作用。<br>运算符操作总体上分为两类：数组运算符和矩阵运算符。 </p>\n<h4 id=\"1-数组运算符\"><a href=\"#1-数组运算符\" class=\"headerlink\" title=\"1.数组运算符\"></a>1.数组运算符</h4><p>数组运算符可以理解为针对矩阵元素的运算，与矩阵本身的性质无关，也是逐个的运算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 数组运算符</span><br><span class=\"line\">% 测试样例</span><br><span class=\"line\">a = [2,3,-4;6,7,8] % 2×3 的矩阵</span><br><span class=\"line\">b = [1,2,-1;2,1,1] % 2×3 的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">% 一元加运算符（+）相当于数学上的正号</span><br><span class=\"line\">+a % 相当于数学上的正号，鸡肋无疑，实际上并没有什么作用。</span><br><span class=\"line\"></span><br><span class=\"line\">% 一元减运算符（-）相当于数学上的正号</span><br><span class=\"line\">-a % 相当于数学上的取负号，返回相反数。</span><br><span class=\"line\"></span><br><span class=\"line\">% 二元加运算符（+）和减运算符（-）的规则与线性代数一致;</span><br><span class=\"line\">% 这一类的二元运算符存在三种情况：标量 + 标量，矩阵 + 标量，矩阵 + 矩阵</span><br><span class=\"line\">a + 1 % 矩阵 + 标量的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">a + b % 矩阵 + 矩阵的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">% a + [1,0;0,1] % 此时语句报错，矩阵 + 矩阵运算时，必须要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素乘运算符（.*）是逐元素操作的，也就是对应矩阵元素位置的相乘</span><br><span class=\"line\">a .* 2 % 矩阵 .* 标量的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">a .* b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素乘方运算符（.^）是逐元素操作的，也就是对应矩阵元素位置的乘方</span><br><span class=\"line\">a .^ 2 % 矩阵 .^ 标量的结果，矩阵中每个值都为对应位置元素的标量次幂；</span><br><span class=\"line\">2 .^ a % 标量 .^ 矩阵的结果，矩阵中每个值都为以该标量为底，以对应位置元素为指数的值；</span><br><span class=\"line\">a .^ b % 两个矩阵对应位置的元素相乘，要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素右除运算符（./）是逐元素操作的，也就是对应矩阵元素位置的右除</span><br><span class=\"line\">a ./ 2 % 矩阵 ./ 标量返回一个商矩阵，矩阵元素为被除数，该标量为除数；</span><br><span class=\"line\">2 ./ a % 标量 ./ 矩阵返回一个商矩阵，该标量为被除数，矩阵元素为除数；</span><br><span class=\"line\">a ./ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为被除数，右矩阵元素为除数</span><br><span class=\"line\">% 这时要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 逐元素左除运算符（.\\）是逐元素操作的，也就是对应矩阵元素位置的左除</span><br><span class=\"line\">a .\\ 2 % 矩阵 .\\ 标量返回一个商矩阵，矩阵元素为除数，该标量为被除数；</span><br><span class=\"line\">2 .\\ a % 矩阵 .\\ 标量返回一个商矩阵，该标量为除数，矩阵元素为被除数；</span><br><span class=\"line\">a .\\ b % 矩阵 .\\ 矩阵返回一个商矩阵，左矩阵元素为除数，右矩阵元素为被除数</span><br><span class=\"line\">% 这时要求矩阵的维度匹配（行列数量一致）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 提醒：左除右除运算符的区别只要记住斜杠上的是分子，斜杠下的为分母即可。</span><br><span class=\"line\"></span><br><span class=\"line\">% 数组转置（.&apos;），行列交换得到转置矩阵</span><br><span class=\"line\">a.&apos; % 返回矩阵的数组转置，相当于矩阵的行和列互换，得到新的矩阵；</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-矩阵运算符\"><a href=\"#2-矩阵运算符\" class=\"headerlink\" title=\"2.矩阵运算符\"></a>2.矩阵运算符</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 矩阵运算符</span><br><span class=\"line\">% 测试样例</span><br><span class=\"line\">a = [2,3,-4;6,7,8] % 2×3的矩阵</span><br><span class=\"line\">b = [0,1,-5,3;2,-3,5,5;-1,4,2,3] % 3×4的矩阵</span><br><span class=\"line\">c = [1;2]</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵乘法运算符（*） 矩阵相乘得到线性代数上的矩阵乘积，</span><br><span class=\"line\">a * 2 % 矩阵 * 标量的结果，矩阵中每个值都加上该标量；</span><br><span class=\"line\">a * b % 满足矩阵相乘的规则，要求矩阵的维度匹配（左矩阵列 = 右矩阵行）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵乘方运算符（^）矩阵必须为方阵(或者标量)，</span><br><span class=\"line\">[0,1;2,0] ^ 2  % 矩阵 .^ 标量，方阵的标量次幂；</span><br><span class=\"line\">2 .* [0,1;2,0] % 标量 .^ 矩阵基于特征值和特征向量求解，线性代数内容（个人目前还没用过）；</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵左除运算符（\\）矩阵左除（线性代数没有这玩意）</span><br><span class=\"line\">% 注解：线性方程组如果可以表示为 A*x=B，那么解方程组时就应该在两式用 A 的逆阵（暂且叫做 Ai）左乘，这时式子化为 x=Ai*B，矩阵左除运算结果 A\\B=Ai*B。同理可以推演右除</span><br><span class=\"line\">a \\ c % 矩阵\\矩阵相当于解线性方程组 a*x=c</span><br><span class=\"line\"></span><br><span class=\"line\">% 矩阵右除运算符（/）矩阵右除</span><br><span class=\"line\">a \\ c % 矩阵\\矩阵相当于解线性方程组x*a=c</span><br><span class=\"line\"></span><br><span class=\"line\">% 共轭转置（&apos;），针对与矩阵而言，行列交换并求共轭得到共轭转置矩阵</span><br><span class=\"line\">a&apos; % 返回矩阵的共轭转置，相当于矩阵的行和列互换再求共轭，得到新的矩阵;</span><br><span class=\"line\">% 但是由于一般都是操作实数，取共轭不会有影响，平时更常用（&apos;）而不使用（.&apos;）；</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>本次的内容几乎都只要复制粘贴到 MATLAB 中执行即可，几乎只需要观察即可。生成函数很多不需要死记，函数名几乎可以直译，开始用几次就可以无压力记住（即使记错了某个字母，MATLAB 也会提示正确的名字）。</p>"},{"title":"MATLAB 绘图（一）","date":"2018-04-03T01:07:24.000Z","_content":"\n\n\n\n\n\n### 概述\n\nMATLAB 经常用于科学研究中的科学计算，因此 MATLAB 也支持完善的绘图功能，本次主要介绍 MATLAB 中的曲线图的绘制。尽管 MATLAB 中的绘图可以用鼠标交互式操作在本次内容中也会开始使用一些相应的绘图函数。本章的内容可以用于绘制论文中一些相关的图。\n\n<!--more-->\n\n\n### plot 函数：线性二维曲线图\n\nplot 函数是我们最常使用的函数之一，可以根据传入的点坐标对应描点连线。\n\n#### 一条简单的曲线\n\n传入两个序列：横坐标序列，纵坐标序列（很自然地，横坐标的总数和纵坐标的总数应该一样，这两个序列理应等长）。函数将打开绘图窗口，依次将对应的点以连续的直线连接。\n\n```matlab\nx = -10:0.1:10; \ny = sin(x);\nplot(x,y);\n```\n\n上述代码将绘制正弦函数的一部分。\n![1.png](https://upload-images.jianshu.io/upload_images/8078350-fb436e01fe98365d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 直线还是曲线？\n\n我们有这样一个疑问：刚才不是说依次将对应的点用直线连接吗？为什么刚才出现的不是折线。这个现象的秘密在于散点的密度：只要点的密度足够到，在视觉效果上就能还原连续平滑的曲线效果。\n\n> 线由无限的点组成，计算机处理的点的数量却是有限的，因此 plot 函数做的事是连点成线，只要点足够密集，就可以当作曲线看待，至少绘图效果上没有什么区别。\n\n不妨尝试把点的密度降低，运行以下代码。\n\n```matlab\nx = -10:1:10; \ny = sin(x);\nplot(x,y);\n```\n\n![2.png](https://upload-images.jianshu.io/upload_images/8078350-94cc942c9e5a0c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上述代码也绘制正弦函数的一部分，原则上它也是正弦函数（尽管不怎么像）这种现象就是采样点间距过大引起的图形失真。**因此有一点建议：在算力足够的情况下，可以适当提高绘图的精度达到比较好的视觉效果**\n\n#### 用 plot 绘制多条曲线\n\n在已经掌握了使用 MATLAB 绘制一条曲线的方法之后，正准备用于研究函数曲线的伸缩变换，希望有一种方法可以一次性绘制多条曲线。不妨看一下 plot 函数的帮助信息，直接依次传入对应的横纵坐标即可（x1,y1,x2,y2,x3,y3, ...），同时系统还会自动使用不同的颜色绘制不同的曲线。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,x2,y2,x3,y3);\n% plot(x1,y1);plot(x2,y2);plot(x3,y3);\n% 你可能会好奇被注释的三条命令能否实现同样的效果\n% 答案是做不到，绘图结果永远只有最后一个曲线。\n% 你可以使用稍后提到的 hold on 命令来实现。\n```\n![3.png](https://upload-images.jianshu.io/upload_images/8078350-340dde90305ce8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n额，看起来这个显示效果有点差。虽说不同曲线的颜色不同，但是即使你能勉强分辨出三条线的轨迹，也看不出哪条曲线对应哪个函数。更重要的是这样：\n\n> 你查看了打印版的绘图结果，不同颜色的曲线经过黑白打印后几乎没有区别。这时，你迫切需要一个额外的区分曲线的方法。\n\n### plot 参数：线型，颜色和标记\n\n为了区分不同的曲线，MATLAB 提供三种参数：为曲线指定不同的线型，颜色和标记。\n\n指定这三种信息的跟随在对应的横坐标和纵坐标之后，以字符串形式传入（也就是使用单引号包含）\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\n% 函数一：颜色为红色（r），标记为实心圆点（.），线型为实线(-)；\n% 函数二：颜色为绿色（g），标记为空心圆点（o），线型为无线\n%（尽管默认使用实线，使用标记而不指定线型时为无线）；\n% 函数三：颜色为蓝色（b），标记为星号（*），线型为虚线(--)；\n```\n![4.png](https://upload-images.jianshu.io/upload_images/8078350-45c090319eac946a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 请不要刻意记住以下这几个表格，与其花时间记住，还不如直接使用 help plot 命令查看帮助来得更快。\n\n\n\n\n| 线型   | 说明         |\n| ------ | ------------ |\n| -      | 实线（默认） |\n| --     | 虚线         |\n| :      | 点线         |\n| -.     | 点划线       |\n| (none) | 无曲线       |\n\n\n\n| 标记 | 说明   |\n| ---- | ------ |\n| o    | 圆圈   |\n| +    | 加号   |\n| *    | 星号   |\n| .    | 点     |\n| x    | 叉号   |\n| s    | 方形   |\n| d    | 菱形   |\n| ^    | 上三角 |\n| v    | 下三角 |\n| >    | 右三角 |\n| <    | 左三角 |\n| p    | 五角形 |\n| h    | 六角形 |\n\n\n\n\n\n| 颜色 | 说明   |\n| ---- | ------ |\n| y    | 黄色   |\n| m    | 品红色 |\n| c    | 青蓝色 |\n| r    | 红色   |\n| g    | 绿色   |\n| b    | 蓝色   |\n| w    | 白色   |\n| k    | 黑色   |\n\n\n\n现在的视觉效果挺不错的，但是你仍然会注意到这个图的一个致命缺陷——没有绘图描述。\n\n### 绘图窗口的控制命令\n\n\n\n#### 使用 figure 命令\n\n打开新的一个绘图窗口（指示当前时刻应当执行绘制曲线的窗口）。\n\n用法：在 plot 命令之前使用 plot 命令。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nfigure(1); % 指定窗口一用于绘图\nplot(x1,y1,'r.-'); \nfigure(2); % 指定窗口二用于绘图\nplot(x2,y2,'go'); \nfigure(); % 指定一个新窗口用于绘图 \nfigure; % 等同于 figure();\nplot(x3,y3,'b*--'); \nfigure(1); % 重新指定窗口一用于绘图\nplot(x2,y2,'go'); % 曲线一除去，绘制曲线二\n\n```\n\n\n\n#### 使用 legend 命令\n\n允许用字符串来对曲线进行注解。\n\n用法：在 plot 命令之后加上 legend 命令。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\nlegend('函数一','函数二','函数三');\n```\n\n![5.png](https://upload-images.jianshu.io/upload_images/8078350-ed31bd5e8a4a587b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相比之前的绘图结果，legend 命令的作用就是将曲线的注释在绘图窗口标记出来，这回就可以根据注释找到对应的曲线了。\n\n#### 使用 title 命令\n\n嗯，这时正弦函数的变换关系就确定了。为了应用到论文中取，这个图还需要一个标题（title）。在 plot 命令之后加上 title 命令。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\nlegend('函数一','函数二','函数三');\ntitle('正弦函数伸缩变换关系图');\n```\n![6.png](https://upload-images.jianshu.io/upload_images/8078350-4b60e808347b8715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 使用 label 命令\n\nlabel 命令指的是 xlabel 和 ylabel 两个命令。其作用就是在坐标轴上加上想要的字符串描述。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\nlegend('函数一','函数二','函数三');\ntitle('正弦函数伸缩变换关系图');\nxlabel('自变量');\nylabel('因变量');\n```\n\n![7.png](https://upload-images.jianshu.io/upload_images/8078350-dcc9591ccfe219e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看上去效果不错，这个图已经有了基本的可视化效果。\n\n#### 其他控制命令\n\n为了实现更好的视觉效果，还有一些“无关紧要”的命令可以用来控制绘图窗口。\n\n- grid on 命令可以在图中加上刻度网格。\n- grid off 命令可以取消 grid on 命令的效果。 \n- hold on 命令可以让绘图窗口中的曲线保留，从而实现一个绘图窗口绘制多个曲线。\n- hold off 命令可以取消 hold on 的效果。\n- axis([xmin xmax ymin ymax])  用于限制两个坐标轴的范围也就是绘图范围。\n\n\n\n#### 拓展绘图控制命令（了解即可）\n\n这一部分只是为了告诉你曲线的线宽，标记的大小，颜色都可以通过特定的命令来控制。使用时在搜索引擎中搜索即可。\n\n```matlab\nx = -pi:pi/10:pi;\ny = tan(sin(x)) - sin(tan(x));\n\nfigure\np = plot(x,y,'--gs',...\n    'LineWidth',2,...\n    'MarkerSize',10,...\n    'MarkerEdgeColor','b',...\n    'MarkerFaceColor',[0.5,0.5,0.5]);\np.LineWidth = 5;\np.Marker = '*';\n```\n\n![8.png](https://upload-images.jianshu.io/upload_images/8078350-fb3205054f2a2cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n甚至更完全的控制命令可以使用 set 命令，但这不属于应当熟练掌握的范围，这里就不多赘述。\n\n### 对数（非线性）绘图函数\n\n使用 plot 函数可以将图像画在一个 XY 平面坐标系中，美中不足的是：往往数据点分布的不均匀性并不能让我们如愿地绘制足够连续的图案。（如果仍然使用 plot 函数绘制指数分布型的变量，结果将是绝大部分数据点集中于绘图窗口的一侧）\n\n三种非线性绘图函数：\n\n- semilogx 函数：在 X 轴上使用对数坐标轴绘制曲线；\n- semilogy 函数：在 X 轴上使用对数坐标轴绘制曲线；\n- loglog 函数：在 X 轴和 Y 轴上使用对数坐标轴绘制曲线；\n\nsemilogx 函数\n\n```matlab\nx1 = 2.^(0.1:0.2:20); % 自变量呈指数分布\ny1 = ones(size(x1));\nsemilogx(x1,y1,'r.-');\ntitle('x 轴上分布的指数分布型数据变得均匀');\n```\n\n\n![9.png](https://upload-images.jianshu.io/upload_images/8078350-0f2142a37d6853ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nsemilogy 函数\n\n```matlab\nx2 = 0.1:0.2:20;\ny2 = exp(x2);  % 因变量呈指数分布\nsemilogy(x2,y2,'r.-');\ntitle('y 轴上分布的指数分布数据变得均匀');\n```\n\n\n![10.png](https://upload-images.jianshu.io/upload_images/8078350-f5e9ede0d3c6beb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nloglog 函数\n\n```matlab\nx3 = 2.^(0.1:0.2:20); % 自变量呈指数分布\ny3 = 5.^(0.1:0.2:20); % 因变量呈指数分布\nloglog(x3,y3,'r.-');\ntitle('xy 两轴上分布的指数分布数据都变得均匀');\n```\n\n![11.png](https://upload-images.jianshu.io/upload_images/8078350-3ababe1551402eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注：以上三个函数的用法无异于 plot 函数，同样可以使用标记、颜色和线型等特性。\n\n### plot3 函数：三维曲线图\n\nplot3 函数用于绘制三维曲线图，是 plot 函数的变体。\n\n```matlab\n% plot3 函数仍然沿用 plot3(x,y,z,...)的调用方式\nt = 0:pi/50:10*pi;\nst = sin(t);\nct = cos(t);\nplot3(st,ct,t);\n```\n\n![12.png](https://upload-images.jianshu.io/upload_images/8078350-be2ae5836120a135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可以看到一条螺旋上升的曲线，也更加印证了 plot 函数是一个遵循描点连线的函数，即使是 plot3 函数也只是绘制三维曲线图 ，而不是三维曲面图。\n\n> 具体的三维曲面图会在下一节中介绍（曲面图参考实例：在命令行输入 peaks ）。\n\n### 小结\n\nplot 函数是本节内容的核心知识，所有内容都从这里展开，也是使用频率最高的绘图。另一方面，尽管 MATLAB 也支持使用鼠标的交互式绘图，读者可以尝试绘图窗口的各个选项。","source":"_posts/MATLAB-绘图（一）.md","raw":"---\ntitle: MATLAB 绘图（一）\ndate: 2018-04-03 09:07:24\ntags: MATLAB\n---\n\n\n\n\n\n\n### 概述\n\nMATLAB 经常用于科学研究中的科学计算，因此 MATLAB 也支持完善的绘图功能，本次主要介绍 MATLAB 中的曲线图的绘制。尽管 MATLAB 中的绘图可以用鼠标交互式操作在本次内容中也会开始使用一些相应的绘图函数。本章的内容可以用于绘制论文中一些相关的图。\n\n<!--more-->\n\n\n### plot 函数：线性二维曲线图\n\nplot 函数是我们最常使用的函数之一，可以根据传入的点坐标对应描点连线。\n\n#### 一条简单的曲线\n\n传入两个序列：横坐标序列，纵坐标序列（很自然地，横坐标的总数和纵坐标的总数应该一样，这两个序列理应等长）。函数将打开绘图窗口，依次将对应的点以连续的直线连接。\n\n```matlab\nx = -10:0.1:10; \ny = sin(x);\nplot(x,y);\n```\n\n上述代码将绘制正弦函数的一部分。\n![1.png](https://upload-images.jianshu.io/upload_images/8078350-fb436e01fe98365d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 直线还是曲线？\n\n我们有这样一个疑问：刚才不是说依次将对应的点用直线连接吗？为什么刚才出现的不是折线。这个现象的秘密在于散点的密度：只要点的密度足够到，在视觉效果上就能还原连续平滑的曲线效果。\n\n> 线由无限的点组成，计算机处理的点的数量却是有限的，因此 plot 函数做的事是连点成线，只要点足够密集，就可以当作曲线看待，至少绘图效果上没有什么区别。\n\n不妨尝试把点的密度降低，运行以下代码。\n\n```matlab\nx = -10:1:10; \ny = sin(x);\nplot(x,y);\n```\n\n![2.png](https://upload-images.jianshu.io/upload_images/8078350-94cc942c9e5a0c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上述代码也绘制正弦函数的一部分，原则上它也是正弦函数（尽管不怎么像）这种现象就是采样点间距过大引起的图形失真。**因此有一点建议：在算力足够的情况下，可以适当提高绘图的精度达到比较好的视觉效果**\n\n#### 用 plot 绘制多条曲线\n\n在已经掌握了使用 MATLAB 绘制一条曲线的方法之后，正准备用于研究函数曲线的伸缩变换，希望有一种方法可以一次性绘制多条曲线。不妨看一下 plot 函数的帮助信息，直接依次传入对应的横纵坐标即可（x1,y1,x2,y2,x3,y3, ...），同时系统还会自动使用不同的颜色绘制不同的曲线。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,x2,y2,x3,y3);\n% plot(x1,y1);plot(x2,y2);plot(x3,y3);\n% 你可能会好奇被注释的三条命令能否实现同样的效果\n% 答案是做不到，绘图结果永远只有最后一个曲线。\n% 你可以使用稍后提到的 hold on 命令来实现。\n```\n![3.png](https://upload-images.jianshu.io/upload_images/8078350-340dde90305ce8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n额，看起来这个显示效果有点差。虽说不同曲线的颜色不同，但是即使你能勉强分辨出三条线的轨迹，也看不出哪条曲线对应哪个函数。更重要的是这样：\n\n> 你查看了打印版的绘图结果，不同颜色的曲线经过黑白打印后几乎没有区别。这时，你迫切需要一个额外的区分曲线的方法。\n\n### plot 参数：线型，颜色和标记\n\n为了区分不同的曲线，MATLAB 提供三种参数：为曲线指定不同的线型，颜色和标记。\n\n指定这三种信息的跟随在对应的横坐标和纵坐标之后，以字符串形式传入（也就是使用单引号包含）\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\n% 函数一：颜色为红色（r），标记为实心圆点（.），线型为实线(-)；\n% 函数二：颜色为绿色（g），标记为空心圆点（o），线型为无线\n%（尽管默认使用实线，使用标记而不指定线型时为无线）；\n% 函数三：颜色为蓝色（b），标记为星号（*），线型为虚线(--)；\n```\n![4.png](https://upload-images.jianshu.io/upload_images/8078350-45c090319eac946a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 请不要刻意记住以下这几个表格，与其花时间记住，还不如直接使用 help plot 命令查看帮助来得更快。\n\n\n\n\n| 线型   | 说明         |\n| ------ | ------------ |\n| -      | 实线（默认） |\n| --     | 虚线         |\n| :      | 点线         |\n| -.     | 点划线       |\n| (none) | 无曲线       |\n\n\n\n| 标记 | 说明   |\n| ---- | ------ |\n| o    | 圆圈   |\n| +    | 加号   |\n| *    | 星号   |\n| .    | 点     |\n| x    | 叉号   |\n| s    | 方形   |\n| d    | 菱形   |\n| ^    | 上三角 |\n| v    | 下三角 |\n| >    | 右三角 |\n| <    | 左三角 |\n| p    | 五角形 |\n| h    | 六角形 |\n\n\n\n\n\n| 颜色 | 说明   |\n| ---- | ------ |\n| y    | 黄色   |\n| m    | 品红色 |\n| c    | 青蓝色 |\n| r    | 红色   |\n| g    | 绿色   |\n| b    | 蓝色   |\n| w    | 白色   |\n| k    | 黑色   |\n\n\n\n现在的视觉效果挺不错的，但是你仍然会注意到这个图的一个致命缺陷——没有绘图描述。\n\n### 绘图窗口的控制命令\n\n\n\n#### 使用 figure 命令\n\n打开新的一个绘图窗口（指示当前时刻应当执行绘制曲线的窗口）。\n\n用法：在 plot 命令之前使用 plot 命令。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nfigure(1); % 指定窗口一用于绘图\nplot(x1,y1,'r.-'); \nfigure(2); % 指定窗口二用于绘图\nplot(x2,y2,'go'); \nfigure(); % 指定一个新窗口用于绘图 \nfigure; % 等同于 figure();\nplot(x3,y3,'b*--'); \nfigure(1); % 重新指定窗口一用于绘图\nplot(x2,y2,'go'); % 曲线一除去，绘制曲线二\n\n```\n\n\n\n#### 使用 legend 命令\n\n允许用字符串来对曲线进行注解。\n\n用法：在 plot 命令之后加上 legend 命令。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\nlegend('函数一','函数二','函数三');\n```\n\n![5.png](https://upload-images.jianshu.io/upload_images/8078350-ed31bd5e8a4a587b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相比之前的绘图结果，legend 命令的作用就是将曲线的注释在绘图窗口标记出来，这回就可以根据注释找到对应的曲线了。\n\n#### 使用 title 命令\n\n嗯，这时正弦函数的变换关系就确定了。为了应用到论文中取，这个图还需要一个标题（title）。在 plot 命令之后加上 title 命令。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\nlegend('函数一','函数二','函数三');\ntitle('正弦函数伸缩变换关系图');\n```\n![6.png](https://upload-images.jianshu.io/upload_images/8078350-4b60e808347b8715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 使用 label 命令\n\nlabel 命令指的是 xlabel 和 ylabel 两个命令。其作用就是在坐标轴上加上想要的字符串描述。\n\n```matlab\nx1 = -10:0.1:10; \ny1 = sin(x1);\nx2 = -5:0.05:5;\ny2 = sin(2*x2);\nx3 = -10:0.1:10;\ny3 = 2*sin(x3);\nplot(x1,y1,'r.-',x2,y2,'go',x3,y3,'b*--');\nlegend('函数一','函数二','函数三');\ntitle('正弦函数伸缩变换关系图');\nxlabel('自变量');\nylabel('因变量');\n```\n\n![7.png](https://upload-images.jianshu.io/upload_images/8078350-dcc9591ccfe219e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看上去效果不错，这个图已经有了基本的可视化效果。\n\n#### 其他控制命令\n\n为了实现更好的视觉效果，还有一些“无关紧要”的命令可以用来控制绘图窗口。\n\n- grid on 命令可以在图中加上刻度网格。\n- grid off 命令可以取消 grid on 命令的效果。 \n- hold on 命令可以让绘图窗口中的曲线保留，从而实现一个绘图窗口绘制多个曲线。\n- hold off 命令可以取消 hold on 的效果。\n- axis([xmin xmax ymin ymax])  用于限制两个坐标轴的范围也就是绘图范围。\n\n\n\n#### 拓展绘图控制命令（了解即可）\n\n这一部分只是为了告诉你曲线的线宽，标记的大小，颜色都可以通过特定的命令来控制。使用时在搜索引擎中搜索即可。\n\n```matlab\nx = -pi:pi/10:pi;\ny = tan(sin(x)) - sin(tan(x));\n\nfigure\np = plot(x,y,'--gs',...\n    'LineWidth',2,...\n    'MarkerSize',10,...\n    'MarkerEdgeColor','b',...\n    'MarkerFaceColor',[0.5,0.5,0.5]);\np.LineWidth = 5;\np.Marker = '*';\n```\n\n![8.png](https://upload-images.jianshu.io/upload_images/8078350-fb3205054f2a2cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n甚至更完全的控制命令可以使用 set 命令，但这不属于应当熟练掌握的范围，这里就不多赘述。\n\n### 对数（非线性）绘图函数\n\n使用 plot 函数可以将图像画在一个 XY 平面坐标系中，美中不足的是：往往数据点分布的不均匀性并不能让我们如愿地绘制足够连续的图案。（如果仍然使用 plot 函数绘制指数分布型的变量，结果将是绝大部分数据点集中于绘图窗口的一侧）\n\n三种非线性绘图函数：\n\n- semilogx 函数：在 X 轴上使用对数坐标轴绘制曲线；\n- semilogy 函数：在 X 轴上使用对数坐标轴绘制曲线；\n- loglog 函数：在 X 轴和 Y 轴上使用对数坐标轴绘制曲线；\n\nsemilogx 函数\n\n```matlab\nx1 = 2.^(0.1:0.2:20); % 自变量呈指数分布\ny1 = ones(size(x1));\nsemilogx(x1,y1,'r.-');\ntitle('x 轴上分布的指数分布型数据变得均匀');\n```\n\n\n![9.png](https://upload-images.jianshu.io/upload_images/8078350-0f2142a37d6853ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nsemilogy 函数\n\n```matlab\nx2 = 0.1:0.2:20;\ny2 = exp(x2);  % 因变量呈指数分布\nsemilogy(x2,y2,'r.-');\ntitle('y 轴上分布的指数分布数据变得均匀');\n```\n\n\n![10.png](https://upload-images.jianshu.io/upload_images/8078350-f5e9ede0d3c6beb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nloglog 函数\n\n```matlab\nx3 = 2.^(0.1:0.2:20); % 自变量呈指数分布\ny3 = 5.^(0.1:0.2:20); % 因变量呈指数分布\nloglog(x3,y3,'r.-');\ntitle('xy 两轴上分布的指数分布数据都变得均匀');\n```\n\n![11.png](https://upload-images.jianshu.io/upload_images/8078350-3ababe1551402eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注：以上三个函数的用法无异于 plot 函数，同样可以使用标记、颜色和线型等特性。\n\n### plot3 函数：三维曲线图\n\nplot3 函数用于绘制三维曲线图，是 plot 函数的变体。\n\n```matlab\n% plot3 函数仍然沿用 plot3(x,y,z,...)的调用方式\nt = 0:pi/50:10*pi;\nst = sin(t);\nct = cos(t);\nplot3(st,ct,t);\n```\n\n![12.png](https://upload-images.jianshu.io/upload_images/8078350-be2ae5836120a135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可以看到一条螺旋上升的曲线，也更加印证了 plot 函数是一个遵循描点连线的函数，即使是 plot3 函数也只是绘制三维曲线图 ，而不是三维曲面图。\n\n> 具体的三维曲面图会在下一节中介绍（曲面图参考实例：在命令行输入 peaks ）。\n\n### 小结\n\nplot 函数是本节内容的核心知识，所有内容都从这里展开，也是使用频率最高的绘图。另一方面，尽管 MATLAB 也支持使用鼠标的交互式绘图，读者可以尝试绘图窗口的各个选项。","slug":"MATLAB-绘图（一）","published":1,"updated":"2020-03-15T21:05:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wi000l29fyz1vg2hjr","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>MATLAB 经常用于科学研究中的科学计算，因此 MATLAB 也支持完善的绘图功能，本次主要介绍 MATLAB 中的曲线图的绘制。尽管 MATLAB 中的绘图可以用鼠标交互式操作在本次内容中也会开始使用一些相应的绘图函数。本章的内容可以用于绘制论文中一些相关的图。</p>\n<a id=\"more\"></a>\n\n\n<h3 id=\"plot-函数：线性二维曲线图\"><a href=\"#plot-函数：线性二维曲线图\" class=\"headerlink\" title=\"plot 函数：线性二维曲线图\"></a>plot 函数：线性二维曲线图</h3><p>plot 函数是我们最常使用的函数之一，可以根据传入的点坐标对应描点连线。</p>\n<h4 id=\"一条简单的曲线\"><a href=\"#一条简单的曲线\" class=\"headerlink\" title=\"一条简单的曲线\"></a>一条简单的曲线</h4><p>传入两个序列：横坐标序列，纵坐标序列（很自然地，横坐标的总数和纵坐标的总数应该一样，这两个序列理应等长）。函数将打开绘图窗口，依次将对应的点以连续的直线连接。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y = <span class=\"built_in\">sin</span>(x);</span><br><span class=\"line\">plot(x,y);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码将绘制正弦函数的一部分。<br><img src=\"https://upload-images.jianshu.io/upload_images/8078350-fb436e01fe98365d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.png\"></p>\n<h4 id=\"直线还是曲线？\"><a href=\"#直线还是曲线？\" class=\"headerlink\" title=\"直线还是曲线？\"></a>直线还是曲线？</h4><p>我们有这样一个疑问：刚才不是说依次将对应的点用直线连接吗？为什么刚才出现的不是折线。这个现象的秘密在于散点的密度：只要点的密度足够到，在视觉效果上就能还原连续平滑的曲线效果。</p>\n<blockquote>\n<p>线由无限的点组成，计算机处理的点的数量却是有限的，因此 plot 函数做的事是连点成线，只要点足够密集，就可以当作曲线看待，至少绘图效果上没有什么区别。</p>\n</blockquote>\n<p>不妨尝试把点的密度降低，运行以下代码。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">-10</span>:<span class=\"number\">1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y = <span class=\"built_in\">sin</span>(x);</span><br><span class=\"line\">plot(x,y);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-94cc942c9e5a0c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.png\"></p>\n<p>上述代码也绘制正弦函数的一部分，原则上它也是正弦函数（尽管不怎么像）这种现象就是采样点间距过大引起的图形失真。<strong>因此有一点建议：在算力足够的情况下，可以适当提高绘图的精度达到比较好的视觉效果</strong></p>\n<h4 id=\"用-plot-绘制多条曲线\"><a href=\"#用-plot-绘制多条曲线\" class=\"headerlink\" title=\"用 plot 绘制多条曲线\"></a>用 plot 绘制多条曲线</h4><p>在已经掌握了使用 MATLAB 绘制一条曲线的方法之后，正准备用于研究函数曲线的伸缩变换，希望有一种方法可以一次性绘制多条曲线。不妨看一下 plot 函数的帮助信息，直接依次传入对应的横纵坐标即可（x1,y1,x2,y2,x3,y3, …），同时系统还会自动使用不同的颜色绘制不同的曲线。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,x2,y2,x3,y3);</span><br><span class=\"line\"><span class=\"comment\">% plot(x1,y1);plot(x2,y2);plot(x3,y3);</span></span><br><span class=\"line\"><span class=\"comment\">% 你可能会好奇被注释的三条命令能否实现同样的效果</span></span><br><span class=\"line\"><span class=\"comment\">% 答案是做不到，绘图结果永远只有最后一个曲线。</span></span><br><span class=\"line\"><span class=\"comment\">% 你可以使用稍后提到的 hold on 命令来实现。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-340dde90305ce8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.png\"><br>额，看起来这个显示效果有点差。虽说不同曲线的颜色不同，但是即使你能勉强分辨出三条线的轨迹，也看不出哪条曲线对应哪个函数。更重要的是这样：</p>\n<blockquote>\n<p>你查看了打印版的绘图结果，不同颜色的曲线经过黑白打印后几乎没有区别。这时，你迫切需要一个额外的区分曲线的方法。</p>\n</blockquote>\n<h3 id=\"plot-参数：线型，颜色和标记\"><a href=\"#plot-参数：线型，颜色和标记\" class=\"headerlink\" title=\"plot 参数：线型，颜色和标记\"></a>plot 参数：线型，颜色和标记</h3><p>为了区分不同的曲线，MATLAB 提供三种参数：为曲线指定不同的线型，颜色和标记。</p>\n<p>指定这三种信息的跟随在对应的横坐标和纵坐标之后，以字符串形式传入（也就是使用单引号包含）</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\"><span class=\"comment\">% 函数一：颜色为红色（r），标记为实心圆点（.），线型为实线(-)；</span></span><br><span class=\"line\"><span class=\"comment\">% 函数二：颜色为绿色（g），标记为空心圆点（o），线型为无线</span></span><br><span class=\"line\"><span class=\"comment\">%（尽管默认使用实线，使用标记而不指定线型时为无线）；</span></span><br><span class=\"line\"><span class=\"comment\">% 函数三：颜色为蓝色（b），标记为星号（*），线型为虚线(--)；</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-45c090319eac946a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"4.png\"></p>\n<blockquote>\n<p>请不要刻意记住以下这几个表格，与其花时间记住，还不如直接使用 help plot 命令查看帮助来得更快。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>线型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-</td>\n<td>实线（默认）</td>\n</tr>\n<tr>\n<td>–</td>\n<td>虚线</td>\n</tr>\n<tr>\n<td>:</td>\n<td>点线</td>\n</tr>\n<tr>\n<td>-.</td>\n<td>点划线</td>\n</tr>\n<tr>\n<td>(none)</td>\n<td>无曲线</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>o</td>\n<td>圆圈</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加号</td>\n</tr>\n<tr>\n<td>*</td>\n<td>星号</td>\n</tr>\n<tr>\n<td>.</td>\n<td>点</td>\n</tr>\n<tr>\n<td>x</td>\n<td>叉号</td>\n</tr>\n<tr>\n<td>s</td>\n<td>方形</td>\n</tr>\n<tr>\n<td>d</td>\n<td>菱形</td>\n</tr>\n<tr>\n<td>^</td>\n<td>上三角</td>\n</tr>\n<tr>\n<td>v</td>\n<td>下三角</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>右三角</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>左三角</td>\n</tr>\n<tr>\n<td>p</td>\n<td>五角形</td>\n</tr>\n<tr>\n<td>h</td>\n<td>六角形</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>颜色</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>黄色</td>\n</tr>\n<tr>\n<td>m</td>\n<td>品红色</td>\n</tr>\n<tr>\n<td>c</td>\n<td>青蓝色</td>\n</tr>\n<tr>\n<td>r</td>\n<td>红色</td>\n</tr>\n<tr>\n<td>g</td>\n<td>绿色</td>\n</tr>\n<tr>\n<td>b</td>\n<td>蓝色</td>\n</tr>\n<tr>\n<td>w</td>\n<td>白色</td>\n</tr>\n<tr>\n<td>k</td>\n<td>黑色</td>\n</tr>\n</tbody></table>\n<p>现在的视觉效果挺不错的，但是你仍然会注意到这个图的一个致命缺陷——没有绘图描述。</p>\n<h3 id=\"绘图窗口的控制命令\"><a href=\"#绘图窗口的控制命令\" class=\"headerlink\" title=\"绘图窗口的控制命令\"></a>绘图窗口的控制命令</h3><h4 id=\"使用-figure-命令\"><a href=\"#使用-figure-命令\" class=\"headerlink\" title=\"使用 figure 命令\"></a>使用 figure 命令</h4><p>打开新的一个绘图窗口（指示当前时刻应当执行绘制曲线的窗口）。</p>\n<p>用法：在 plot 命令之前使用 plot 命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">figure(<span class=\"number\">1</span>); <span class=\"comment\">% 指定窗口一用于绘图</span></span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>); </span><br><span class=\"line\">figure(<span class=\"number\">2</span>); <span class=\"comment\">% 指定窗口二用于绘图</span></span><br><span class=\"line\">plot(x2,y2,<span class=\"string\">'go'</span>); </span><br><span class=\"line\">figure(); <span class=\"comment\">% 指定一个新窗口用于绘图 </span></span><br><span class=\"line\">figure; <span class=\"comment\">% 等同于 figure();</span></span><br><span class=\"line\">plot(x3,y3,<span class=\"string\">'b*--'</span>); </span><br><span class=\"line\">figure(<span class=\"number\">1</span>); <span class=\"comment\">% 重新指定窗口一用于绘图</span></span><br><span class=\"line\">plot(x2,y2,<span class=\"string\">'go'</span>); <span class=\"comment\">% 曲线一除去，绘制曲线二</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-legend-命令\"><a href=\"#使用-legend-命令\" class=\"headerlink\" title=\"使用 legend 命令\"></a>使用 legend 命令</h4><p>允许用字符串来对曲线进行注解。</p>\n<p>用法：在 plot 命令之后加上 legend 命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'函数一'</span>,<span class=\"string\">'函数二'</span>,<span class=\"string\">'函数三'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-ed31bd5e8a4a587b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"5.png\"></p>\n<p>相比之前的绘图结果，legend 命令的作用就是将曲线的注释在绘图窗口标记出来，这回就可以根据注释找到对应的曲线了。</p>\n<h4 id=\"使用-title-命令\"><a href=\"#使用-title-命令\" class=\"headerlink\" title=\"使用 title 命令\"></a>使用 title 命令</h4><p>嗯，这时正弦函数的变换关系就确定了。为了应用到论文中取，这个图还需要一个标题（title）。在 plot 命令之后加上 title 命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'函数一'</span>,<span class=\"string\">'函数二'</span>,<span class=\"string\">'函数三'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'正弦函数伸缩变换关系图'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-4b60e808347b8715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6.png\"></p>\n<h4 id=\"使用-label-命令\"><a href=\"#使用-label-命令\" class=\"headerlink\" title=\"使用 label 命令\"></a>使用 label 命令</h4><p>label 命令指的是 xlabel 和 ylabel 两个命令。其作用就是在坐标轴上加上想要的字符串描述。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'函数一'</span>,<span class=\"string\">'函数二'</span>,<span class=\"string\">'函数三'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'正弦函数伸缩变换关系图'</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">'自变量'</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">'因变量'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-dcc9591ccfe219e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"7.png\"></p>\n<p>看上去效果不错，这个图已经有了基本的可视化效果。</p>\n<h4 id=\"其他控制命令\"><a href=\"#其他控制命令\" class=\"headerlink\" title=\"其他控制命令\"></a>其他控制命令</h4><p>为了实现更好的视觉效果，还有一些“无关紧要”的命令可以用来控制绘图窗口。</p>\n<ul>\n<li>grid on 命令可以在图中加上刻度网格。</li>\n<li>grid off 命令可以取消 grid on 命令的效果。 </li>\n<li>hold on 命令可以让绘图窗口中的曲线保留，从而实现一个绘图窗口绘制多个曲线。</li>\n<li>hold off 命令可以取消 hold on 的效果。</li>\n<li>axis([xmin xmax ymin ymax])  用于限制两个坐标轴的范围也就是绘图范围。</li>\n</ul>\n<h4 id=\"拓展绘图控制命令（了解即可）\"><a href=\"#拓展绘图控制命令（了解即可）\" class=\"headerlink\" title=\"拓展绘图控制命令（了解即可）\"></a>拓展绘图控制命令（了解即可）</h4><p>这一部分只是为了告诉你曲线的线宽，标记的大小，颜色都可以通过特定的命令来控制。使用时在搜索引擎中搜索即可。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = -<span class=\"built_in\">pi</span>:<span class=\"built_in\">pi</span>/<span class=\"number\">10</span>:<span class=\"built_in\">pi</span>;</span><br><span class=\"line\">y = <span class=\"built_in\">tan</span>(<span class=\"built_in\">sin</span>(x)) - <span class=\"built_in\">sin</span>(<span class=\"built_in\">tan</span>(x));</span><br><span class=\"line\"></span><br><span class=\"line\">figure</span><br><span class=\"line\">p = plot(x,y,<span class=\"string\">'--gs'</span>,...</span><br><span class=\"line\">    <span class=\"string\">'LineWidth'</span>,<span class=\"number\">2</span>,...</span><br><span class=\"line\">    <span class=\"string\">'MarkerSize'</span>,<span class=\"number\">10</span>,...</span><br><span class=\"line\">    <span class=\"string\">'MarkerEdgeColor'</span>,<span class=\"string\">'b'</span>,...</span><br><span class=\"line\">    <span class=\"string\">'MarkerFaceColor'</span>,[<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>]);</span><br><span class=\"line\">p.LineWidth = <span class=\"number\">5</span>;</span><br><span class=\"line\">p.Marker = <span class=\"string\">'*'</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-fb3205054f2a2cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"8.png\"></p>\n<p>甚至更完全的控制命令可以使用 set 命令，但这不属于应当熟练掌握的范围，这里就不多赘述。</p>\n<h3 id=\"对数（非线性）绘图函数\"><a href=\"#对数（非线性）绘图函数\" class=\"headerlink\" title=\"对数（非线性）绘图函数\"></a>对数（非线性）绘图函数</h3><p>使用 plot 函数可以将图像画在一个 XY 平面坐标系中，美中不足的是：往往数据点分布的不均匀性并不能让我们如愿地绘制足够连续的图案。（如果仍然使用 plot 函数绘制指数分布型的变量，结果将是绝大部分数据点集中于绘图窗口的一侧）</p>\n<p>三种非线性绘图函数：</p>\n<ul>\n<li>semilogx 函数：在 X 轴上使用对数坐标轴绘制曲线；</li>\n<li>semilogy 函数：在 X 轴上使用对数坐标轴绘制曲线；</li>\n<li>loglog 函数：在 X 轴和 Y 轴上使用对数坐标轴绘制曲线；</li>\n</ul>\n<p>semilogx 函数</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">2.</span>^(<span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>); <span class=\"comment\">% 自变量呈指数分布</span></span><br><span class=\"line\">y1 = <span class=\"built_in\">ones</span>(<span class=\"built_in\">size</span>(x1));</span><br><span class=\"line\">semilogx(x1,y1,<span class=\"string\">'r.-'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'x 轴上分布的指数分布型数据变得均匀'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-0f2142a37d6853ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"9.png\"></p>\n<p>semilogy 函数</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x2 = <span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">exp</span>(x2);  <span class=\"comment\">% 因变量呈指数分布</span></span><br><span class=\"line\">semilogy(x2,y2,<span class=\"string\">'r.-'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'y 轴上分布的指数分布数据变得均匀'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-f5e9ede0d3c6beb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"10.png\"></p>\n<p>loglog 函数</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x3 = <span class=\"number\">2.</span>^(<span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>); <span class=\"comment\">% 自变量呈指数分布</span></span><br><span class=\"line\">y3 = <span class=\"number\">5.</span>^(<span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>); <span class=\"comment\">% 因变量呈指数分布</span></span><br><span class=\"line\">loglog(x3,y3,<span class=\"string\">'r.-'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'xy 两轴上分布的指数分布数据都变得均匀'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-3ababe1551402eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"11.png\"></p>\n<p>注：以上三个函数的用法无异于 plot 函数，同样可以使用标记、颜色和线型等特性。</p>\n<h3 id=\"plot3-函数：三维曲线图\"><a href=\"#plot3-函数：三维曲线图\" class=\"headerlink\" title=\"plot3 函数：三维曲线图\"></a>plot3 函数：三维曲线图</h3><p>plot3 函数用于绘制三维曲线图，是 plot 函数的变体。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% plot3 函数仍然沿用 plot3(x,y,z,...)的调用方式</span></span><br><span class=\"line\">t = <span class=\"number\">0</span>:<span class=\"built_in\">pi</span>/<span class=\"number\">50</span>:<span class=\"number\">10</span>*<span class=\"built_in\">pi</span>;</span><br><span class=\"line\">st = <span class=\"built_in\">sin</span>(t);</span><br><span class=\"line\">ct = <span class=\"built_in\">cos</span>(t);</span><br><span class=\"line\">plot3(st,ct,t);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-be2ae5836120a135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"12.png\"></p>\n<p>这里可以看到一条螺旋上升的曲线，也更加印证了 plot 函数是一个遵循描点连线的函数，即使是 plot3 函数也只是绘制三维曲线图 ，而不是三维曲面图。</p>\n<blockquote>\n<p>具体的三维曲面图会在下一节中介绍（曲面图参考实例：在命令行输入 peaks ）。</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>plot 函数是本节内容的核心知识，所有内容都从这里展开，也是使用频率最高的绘图。另一方面，尽管 MATLAB 也支持使用鼠标的交互式绘图，读者可以尝试绘图窗口的各个选项。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>MATLAB 经常用于科学研究中的科学计算，因此 MATLAB 也支持完善的绘图功能，本次主要介绍 MATLAB 中的曲线图的绘制。尽管 MATLAB 中的绘图可以用鼠标交互式操作在本次内容中也会开始使用一些相应的绘图函数。本章的内容可以用于绘制论文中一些相关的图。</p>","more":"<h3 id=\"plot-函数：线性二维曲线图\"><a href=\"#plot-函数：线性二维曲线图\" class=\"headerlink\" title=\"plot 函数：线性二维曲线图\"></a>plot 函数：线性二维曲线图</h3><p>plot 函数是我们最常使用的函数之一，可以根据传入的点坐标对应描点连线。</p>\n<h4 id=\"一条简单的曲线\"><a href=\"#一条简单的曲线\" class=\"headerlink\" title=\"一条简单的曲线\"></a>一条简单的曲线</h4><p>传入两个序列：横坐标序列，纵坐标序列（很自然地，横坐标的总数和纵坐标的总数应该一样，这两个序列理应等长）。函数将打开绘图窗口，依次将对应的点以连续的直线连接。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y = <span class=\"built_in\">sin</span>(x);</span><br><span class=\"line\">plot(x,y);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码将绘制正弦函数的一部分。<br><img src=\"https://upload-images.jianshu.io/upload_images/8078350-fb436e01fe98365d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.png\"></p>\n<h4 id=\"直线还是曲线？\"><a href=\"#直线还是曲线？\" class=\"headerlink\" title=\"直线还是曲线？\"></a>直线还是曲线？</h4><p>我们有这样一个疑问：刚才不是说依次将对应的点用直线连接吗？为什么刚才出现的不是折线。这个现象的秘密在于散点的密度：只要点的密度足够到，在视觉效果上就能还原连续平滑的曲线效果。</p>\n<blockquote>\n<p>线由无限的点组成，计算机处理的点的数量却是有限的，因此 plot 函数做的事是连点成线，只要点足够密集，就可以当作曲线看待，至少绘图效果上没有什么区别。</p>\n</blockquote>\n<p>不妨尝试把点的密度降低，运行以下代码。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">-10</span>:<span class=\"number\">1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y = <span class=\"built_in\">sin</span>(x);</span><br><span class=\"line\">plot(x,y);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-94cc942c9e5a0c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.png\"></p>\n<p>上述代码也绘制正弦函数的一部分，原则上它也是正弦函数（尽管不怎么像）这种现象就是采样点间距过大引起的图形失真。<strong>因此有一点建议：在算力足够的情况下，可以适当提高绘图的精度达到比较好的视觉效果</strong></p>\n<h4 id=\"用-plot-绘制多条曲线\"><a href=\"#用-plot-绘制多条曲线\" class=\"headerlink\" title=\"用 plot 绘制多条曲线\"></a>用 plot 绘制多条曲线</h4><p>在已经掌握了使用 MATLAB 绘制一条曲线的方法之后，正准备用于研究函数曲线的伸缩变换，希望有一种方法可以一次性绘制多条曲线。不妨看一下 plot 函数的帮助信息，直接依次传入对应的横纵坐标即可（x1,y1,x2,y2,x3,y3, …），同时系统还会自动使用不同的颜色绘制不同的曲线。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,x2,y2,x3,y3);</span><br><span class=\"line\"><span class=\"comment\">% plot(x1,y1);plot(x2,y2);plot(x3,y3);</span></span><br><span class=\"line\"><span class=\"comment\">% 你可能会好奇被注释的三条命令能否实现同样的效果</span></span><br><span class=\"line\"><span class=\"comment\">% 答案是做不到，绘图结果永远只有最后一个曲线。</span></span><br><span class=\"line\"><span class=\"comment\">% 你可以使用稍后提到的 hold on 命令来实现。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-340dde90305ce8e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.png\"><br>额，看起来这个显示效果有点差。虽说不同曲线的颜色不同，但是即使你能勉强分辨出三条线的轨迹，也看不出哪条曲线对应哪个函数。更重要的是这样：</p>\n<blockquote>\n<p>你查看了打印版的绘图结果，不同颜色的曲线经过黑白打印后几乎没有区别。这时，你迫切需要一个额外的区分曲线的方法。</p>\n</blockquote>\n<h3 id=\"plot-参数：线型，颜色和标记\"><a href=\"#plot-参数：线型，颜色和标记\" class=\"headerlink\" title=\"plot 参数：线型，颜色和标记\"></a>plot 参数：线型，颜色和标记</h3><p>为了区分不同的曲线，MATLAB 提供三种参数：为曲线指定不同的线型，颜色和标记。</p>\n<p>指定这三种信息的跟随在对应的横坐标和纵坐标之后，以字符串形式传入（也就是使用单引号包含）</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\"><span class=\"comment\">% 函数一：颜色为红色（r），标记为实心圆点（.），线型为实线(-)；</span></span><br><span class=\"line\"><span class=\"comment\">% 函数二：颜色为绿色（g），标记为空心圆点（o），线型为无线</span></span><br><span class=\"line\"><span class=\"comment\">%（尽管默认使用实线，使用标记而不指定线型时为无线）；</span></span><br><span class=\"line\"><span class=\"comment\">% 函数三：颜色为蓝色（b），标记为星号（*），线型为虚线(--)；</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-45c090319eac946a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"4.png\"></p>\n<blockquote>\n<p>请不要刻意记住以下这几个表格，与其花时间记住，还不如直接使用 help plot 命令查看帮助来得更快。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>线型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-</td>\n<td>实线（默认）</td>\n</tr>\n<tr>\n<td>–</td>\n<td>虚线</td>\n</tr>\n<tr>\n<td>:</td>\n<td>点线</td>\n</tr>\n<tr>\n<td>-.</td>\n<td>点划线</td>\n</tr>\n<tr>\n<td>(none)</td>\n<td>无曲线</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>o</td>\n<td>圆圈</td>\n</tr>\n<tr>\n<td>+</td>\n<td>加号</td>\n</tr>\n<tr>\n<td>*</td>\n<td>星号</td>\n</tr>\n<tr>\n<td>.</td>\n<td>点</td>\n</tr>\n<tr>\n<td>x</td>\n<td>叉号</td>\n</tr>\n<tr>\n<td>s</td>\n<td>方形</td>\n</tr>\n<tr>\n<td>d</td>\n<td>菱形</td>\n</tr>\n<tr>\n<td>^</td>\n<td>上三角</td>\n</tr>\n<tr>\n<td>v</td>\n<td>下三角</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>右三角</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>左三角</td>\n</tr>\n<tr>\n<td>p</td>\n<td>五角形</td>\n</tr>\n<tr>\n<td>h</td>\n<td>六角形</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>颜色</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>黄色</td>\n</tr>\n<tr>\n<td>m</td>\n<td>品红色</td>\n</tr>\n<tr>\n<td>c</td>\n<td>青蓝色</td>\n</tr>\n<tr>\n<td>r</td>\n<td>红色</td>\n</tr>\n<tr>\n<td>g</td>\n<td>绿色</td>\n</tr>\n<tr>\n<td>b</td>\n<td>蓝色</td>\n</tr>\n<tr>\n<td>w</td>\n<td>白色</td>\n</tr>\n<tr>\n<td>k</td>\n<td>黑色</td>\n</tr>\n</tbody></table>\n<p>现在的视觉效果挺不错的，但是你仍然会注意到这个图的一个致命缺陷——没有绘图描述。</p>\n<h3 id=\"绘图窗口的控制命令\"><a href=\"#绘图窗口的控制命令\" class=\"headerlink\" title=\"绘图窗口的控制命令\"></a>绘图窗口的控制命令</h3><h4 id=\"使用-figure-命令\"><a href=\"#使用-figure-命令\" class=\"headerlink\" title=\"使用 figure 命令\"></a>使用 figure 命令</h4><p>打开新的一个绘图窗口（指示当前时刻应当执行绘制曲线的窗口）。</p>\n<p>用法：在 plot 命令之前使用 plot 命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">figure(<span class=\"number\">1</span>); <span class=\"comment\">% 指定窗口一用于绘图</span></span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>); </span><br><span class=\"line\">figure(<span class=\"number\">2</span>); <span class=\"comment\">% 指定窗口二用于绘图</span></span><br><span class=\"line\">plot(x2,y2,<span class=\"string\">'go'</span>); </span><br><span class=\"line\">figure(); <span class=\"comment\">% 指定一个新窗口用于绘图 </span></span><br><span class=\"line\">figure; <span class=\"comment\">% 等同于 figure();</span></span><br><span class=\"line\">plot(x3,y3,<span class=\"string\">'b*--'</span>); </span><br><span class=\"line\">figure(<span class=\"number\">1</span>); <span class=\"comment\">% 重新指定窗口一用于绘图</span></span><br><span class=\"line\">plot(x2,y2,<span class=\"string\">'go'</span>); <span class=\"comment\">% 曲线一除去，绘制曲线二</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-legend-命令\"><a href=\"#使用-legend-命令\" class=\"headerlink\" title=\"使用 legend 命令\"></a>使用 legend 命令</h4><p>允许用字符串来对曲线进行注解。</p>\n<p>用法：在 plot 命令之后加上 legend 命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'函数一'</span>,<span class=\"string\">'函数二'</span>,<span class=\"string\">'函数三'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-ed31bd5e8a4a587b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"5.png\"></p>\n<p>相比之前的绘图结果，legend 命令的作用就是将曲线的注释在绘图窗口标记出来，这回就可以根据注释找到对应的曲线了。</p>\n<h4 id=\"使用-title-命令\"><a href=\"#使用-title-命令\" class=\"headerlink\" title=\"使用 title 命令\"></a>使用 title 命令</h4><p>嗯，这时正弦函数的变换关系就确定了。为了应用到论文中取，这个图还需要一个标题（title）。在 plot 命令之后加上 title 命令。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'函数一'</span>,<span class=\"string\">'函数二'</span>,<span class=\"string\">'函数三'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'正弦函数伸缩变换关系图'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-4b60e808347b8715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6.png\"></p>\n<h4 id=\"使用-label-命令\"><a href=\"#使用-label-命令\" class=\"headerlink\" title=\"使用 label 命令\"></a>使用 label 命令</h4><p>label 命令指的是 xlabel 和 ylabel 两个命令。其作用就是在坐标轴上加上想要的字符串描述。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>; </span><br><span class=\"line\">y1 = <span class=\"built_in\">sin</span>(x1);</span><br><span class=\"line\">x2 = <span class=\"number\">-5</span>:<span class=\"number\">0.05</span>:<span class=\"number\">5</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*x2);</span><br><span class=\"line\">x3 = <span class=\"number\">-10</span>:<span class=\"number\">0.1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y3 = <span class=\"number\">2</span>*<span class=\"built_in\">sin</span>(x3);</span><br><span class=\"line\">plot(x1,y1,<span class=\"string\">'r.-'</span>,x2,y2,<span class=\"string\">'go'</span>,x3,y3,<span class=\"string\">'b*--'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'函数一'</span>,<span class=\"string\">'函数二'</span>,<span class=\"string\">'函数三'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'正弦函数伸缩变换关系图'</span>);</span><br><span class=\"line\">xlabel(<span class=\"string\">'自变量'</span>);</span><br><span class=\"line\">ylabel(<span class=\"string\">'因变量'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-dcc9591ccfe219e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"7.png\"></p>\n<p>看上去效果不错，这个图已经有了基本的可视化效果。</p>\n<h4 id=\"其他控制命令\"><a href=\"#其他控制命令\" class=\"headerlink\" title=\"其他控制命令\"></a>其他控制命令</h4><p>为了实现更好的视觉效果，还有一些“无关紧要”的命令可以用来控制绘图窗口。</p>\n<ul>\n<li>grid on 命令可以在图中加上刻度网格。</li>\n<li>grid off 命令可以取消 grid on 命令的效果。 </li>\n<li>hold on 命令可以让绘图窗口中的曲线保留，从而实现一个绘图窗口绘制多个曲线。</li>\n<li>hold off 命令可以取消 hold on 的效果。</li>\n<li>axis([xmin xmax ymin ymax])  用于限制两个坐标轴的范围也就是绘图范围。</li>\n</ul>\n<h4 id=\"拓展绘图控制命令（了解即可）\"><a href=\"#拓展绘图控制命令（了解即可）\" class=\"headerlink\" title=\"拓展绘图控制命令（了解即可）\"></a>拓展绘图控制命令（了解即可）</h4><p>这一部分只是为了告诉你曲线的线宽，标记的大小，颜色都可以通过特定的命令来控制。使用时在搜索引擎中搜索即可。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = -<span class=\"built_in\">pi</span>:<span class=\"built_in\">pi</span>/<span class=\"number\">10</span>:<span class=\"built_in\">pi</span>;</span><br><span class=\"line\">y = <span class=\"built_in\">tan</span>(<span class=\"built_in\">sin</span>(x)) - <span class=\"built_in\">sin</span>(<span class=\"built_in\">tan</span>(x));</span><br><span class=\"line\"></span><br><span class=\"line\">figure</span><br><span class=\"line\">p = plot(x,y,<span class=\"string\">'--gs'</span>,...</span><br><span class=\"line\">    <span class=\"string\">'LineWidth'</span>,<span class=\"number\">2</span>,...</span><br><span class=\"line\">    <span class=\"string\">'MarkerSize'</span>,<span class=\"number\">10</span>,...</span><br><span class=\"line\">    <span class=\"string\">'MarkerEdgeColor'</span>,<span class=\"string\">'b'</span>,...</span><br><span class=\"line\">    <span class=\"string\">'MarkerFaceColor'</span>,[<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>]);</span><br><span class=\"line\">p.LineWidth = <span class=\"number\">5</span>;</span><br><span class=\"line\">p.Marker = <span class=\"string\">'*'</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-fb3205054f2a2cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"8.png\"></p>\n<p>甚至更完全的控制命令可以使用 set 命令，但这不属于应当熟练掌握的范围，这里就不多赘述。</p>\n<h3 id=\"对数（非线性）绘图函数\"><a href=\"#对数（非线性）绘图函数\" class=\"headerlink\" title=\"对数（非线性）绘图函数\"></a>对数（非线性）绘图函数</h3><p>使用 plot 函数可以将图像画在一个 XY 平面坐标系中，美中不足的是：往往数据点分布的不均匀性并不能让我们如愿地绘制足够连续的图案。（如果仍然使用 plot 函数绘制指数分布型的变量，结果将是绝大部分数据点集中于绘图窗口的一侧）</p>\n<p>三种非线性绘图函数：</p>\n<ul>\n<li>semilogx 函数：在 X 轴上使用对数坐标轴绘制曲线；</li>\n<li>semilogy 函数：在 X 轴上使用对数坐标轴绘制曲线；</li>\n<li>loglog 函数：在 X 轴和 Y 轴上使用对数坐标轴绘制曲线；</li>\n</ul>\n<p>semilogx 函数</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x1 = <span class=\"number\">2.</span>^(<span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>); <span class=\"comment\">% 自变量呈指数分布</span></span><br><span class=\"line\">y1 = <span class=\"built_in\">ones</span>(<span class=\"built_in\">size</span>(x1));</span><br><span class=\"line\">semilogx(x1,y1,<span class=\"string\">'r.-'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'x 轴上分布的指数分布型数据变得均匀'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-0f2142a37d6853ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"9.png\"></p>\n<p>semilogy 函数</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x2 = <span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>;</span><br><span class=\"line\">y2 = <span class=\"built_in\">exp</span>(x2);  <span class=\"comment\">% 因变量呈指数分布</span></span><br><span class=\"line\">semilogy(x2,y2,<span class=\"string\">'r.-'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'y 轴上分布的指数分布数据变得均匀'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-f5e9ede0d3c6beb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"10.png\"></p>\n<p>loglog 函数</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x3 = <span class=\"number\">2.</span>^(<span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>); <span class=\"comment\">% 自变量呈指数分布</span></span><br><span class=\"line\">y3 = <span class=\"number\">5.</span>^(<span class=\"number\">0.1</span>:<span class=\"number\">0.2</span>:<span class=\"number\">20</span>); <span class=\"comment\">% 因变量呈指数分布</span></span><br><span class=\"line\">loglog(x3,y3,<span class=\"string\">'r.-'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'xy 两轴上分布的指数分布数据都变得均匀'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-3ababe1551402eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"11.png\"></p>\n<p>注：以上三个函数的用法无异于 plot 函数，同样可以使用标记、颜色和线型等特性。</p>\n<h3 id=\"plot3-函数：三维曲线图\"><a href=\"#plot3-函数：三维曲线图\" class=\"headerlink\" title=\"plot3 函数：三维曲线图\"></a>plot3 函数：三维曲线图</h3><p>plot3 函数用于绘制三维曲线图，是 plot 函数的变体。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% plot3 函数仍然沿用 plot3(x,y,z,...)的调用方式</span></span><br><span class=\"line\">t = <span class=\"number\">0</span>:<span class=\"built_in\">pi</span>/<span class=\"number\">50</span>:<span class=\"number\">10</span>*<span class=\"built_in\">pi</span>;</span><br><span class=\"line\">st = <span class=\"built_in\">sin</span>(t);</span><br><span class=\"line\">ct = <span class=\"built_in\">cos</span>(t);</span><br><span class=\"line\">plot3(st,ct,t);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-be2ae5836120a135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"12.png\"></p>\n<p>这里可以看到一条螺旋上升的曲线，也更加印证了 plot 函数是一个遵循描点连线的函数，即使是 plot3 函数也只是绘制三维曲线图 ，而不是三维曲面图。</p>\n<blockquote>\n<p>具体的三维曲面图会在下一节中介绍（曲面图参考实例：在命令行输入 peaks ）。</p>\n</blockquote>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>plot 函数是本节内容的核心知识，所有内容都从这里展开，也是使用频率最高的绘图。另一方面，尽管 MATLAB 也支持使用鼠标的交互式绘图，读者可以尝试绘图窗口的各个选项。</p>"},{"title":"MATLAB 矩阵（二）","date":"2018-03-03T19:46:39.000Z","_content":"---\n\n### **概述**\n\n本次的内容有点多，划一下重点：\n - size 函数：创建矩阵和确定循环结构的循环次数\n - reshape 函数：重新排列矩阵\n - sort 函数：内置的 sort 函数比自己编写的排序更高效\n - [] 中括号运算符：串联矩阵最重要的步骤\n - repmat 函数：重复矩阵的拼接\n - 索引：功能强大，针对性的选取数组元素\n\n <!--more-->\n \n### **矩阵的属性**  \n\n复习一下之前介绍过的 MATLAB 命令：（>> whos）。\n\n功能为显示所有变量的属性。有时候我们需要根据矩阵的属性来做一些操作就需要用到矩阵的一些相关属性。常用的属性都可以通过函数来调用：size，length，isrow，numel 等。\n\n\n#### size\nsize 函数返回矩阵的各个维度的长度，调用方法为：sz = size(A)  \n\n命令行输入  \n```\n% size ()\n% \nA = zeros(3,4); % 先创建一个 3×4 的零矩阵，观察以下几个值\nS = size(A)\n[m,n] = size(A)\n% 补充：这样写是能够让函数返回两个不同的输出参数。\n% 调用函数时，系统会告诉函数有多少个输入参数和输出参数\n% 函数本身则根据输入输出参数的数量决定自己的输出参数。\nmm = size(A,1)\nnn = size(A,2)\n```\n\n命令行输出\n```\nS =\n     3     4\n% 直接调用返回一个输出参数时：\n% size 函数返回一个矩阵包含各个维度长度的矩阵。\nm =\n\n     3\nn =\n\n     4\n% 直接调用返回两个输出参数时：\n% size函数返回两个标量各自表示各个维度长度。\n\nmm =\n     3\nnn =\n     4\n% 调用size函数时，加上想查询的具体维度，可以返回该维度上的长度\n% 在这里，1 指横坐标，2 指纵坐标，3 指竖坐标   \n```\n\n#### length  \n\nlength函数返回矩阵的最长维度的长度，调用方法为：L = length(A)  \n\n命令行输入 \n```\n% length ()\nA = zeros(3,4); % 先创建一个 3×4 的零矩阵\nS = length(A)\n```\n\n命令行输出  \n```\nS =\n        4\n% length 函数返回矩阵的最长维度的长度，相当于 size(A)的最大值。\n```\n\n\n#### isrow  \n\nisrow如其名，作用就是询问矩阵是不是行向量。\n同样作用的还有 iscolumn 确定矩阵是不是列向量，isempty 确定矩阵是不是为空\n\n命令行输入 \n```\n% isrow ()\nA = zeros(1,4); % 创建一个 1×4 的矩阵，观察以下几个值\nS1 = isrow(A)\nS2 = iscolumn(A)\nS3 = isempty(A)\nwhos S1\n```\n命令行输出\n```\nS1 =\n     1\n\nS2 =\n     0\n\nS3 =\n     0\n  Name      Size            Bytes  Class      Attributes\n  S1        1x1                 1  logical  \n% isrow 函数返回一个布尔值 1 或 0\n% 用 whos 命令可以看到返回的类型是 logical（逻辑值非一即零，非真即假）。\n```\n\n\n#### numel\n\nnumel 函数返回数组元素的数量。  \n\n命令行输入 \n```\nA = zeros(3,4); % 创建一个 1×4 的矩阵，观察以下几个值\nn = numel(A)\n```\n命令行输出\n```\nn =\n    12 \n% 返回矩阵所有元素的个数\n```\n\n### **矩阵的排列**\n\n矩阵的另一类操作是排列，对矩阵内的元素的相对位置重新处理，（很抽象的描述，还是看看函数的功能比较容易）。常见的的函数有 reshape，sort，flip，circshift 等\n\n\n\n#### reshape\n\nreshape 函数顾名思义就是对矩阵重排。  \n\n命令行输入 \n```\nA = magic(4) % 创建一个 4×4 的矩阵，观察以下几个值\nAA = reshape(A,2,8)\n```\n命令行输出\n```\n% reshape 之前\nA =\n\n    16     2     3    13\n     5    11    10     8\n     9     7     6    12\n     4    14    15     1\n\n% reshape 之后\nAA =\n\n    16     9     2     7     3     6    13    12\n     5     4    11    14    10    15     8     1\n     \n% 这里又有另一个关注的点：重排的顺序，可以看到A的每一列分成了两列\n% 原理：所有的矩阵在计算机中都是储存在线性空间里，实际上的顺序就是一列一列的拼接：\n% 16 5 9 4 2 11 7 14 3 10 6 15 13 8 12 1\n% 重排的时候仍然依照这个顺序取出。\n```\n\n\n#### sort  \n\n对矩阵进行排序，默认升序（从小到大）  \n\n命令行输入 \n```\nA1 = [ 23 5 -1 4  7 0]\nB1 = sort(A1)\n\nA2 = [7 8 9; 2 4 -2; 10 2 4]\nB2 = sort(A2,2) % 另一个输入参数为排序的维度\n% 1 指横坐标，2 指纵坐标，3 指竖坐标的规则仍适用\nB2 = sort(A2) % 若不输入另一个参数，则默认另一个参数是 1，按列排序\n\nA3 = [ 23 5 -1 4  7 0]\nB3 = sort(A3,'descend') \n% 默认情况下，sort 为升序（'ascend'），使用降序时，可以使用输入参数'descend'来使用降序方法\n\nA4 = [ 23 5 -1 4  7 0]\n[B,I] = sort(A4)\nA(I)\n% sort 返回两个输出参数时，\n% 第一个变量返回排序后的数组，\n% 第二个变量返回排序后的数组对应原有的数组索引 A(I)和 B 是一样的。\n\n```\n命令行输出  \n```\nA1 =\n    23     5    -1     4     7     0\nB1 =\n    -1     0     4     5     7    23\n% sort 排序一维矩阵时，返回排序后的一维矩阵\n\nA2 =\n     7     8     9\n     2     4    -2\n    10     2     4\n\nB2 =\n     7     8     9\n    -2     2     4\n     2     4    10\n% 另一个输入参数为 2，也就是按纵坐标排序\n\nB2 =\n     2     2    -2\n     7     4     4\n    10     8     9\n% 若不输入另一个参数，则默认另一个参数是 1，按列排序\n    \nA3 =\n    23     5    -1     4     7     0\nB3 =\n    23     7     5     4     0    -1\n% 可以sort(A3,'descend')\n\nA4 =\n    23     5    -1     4     7     0\nB =\n    -1     0     4     5     7    23\nI =\n     3     6     4     2     5     1\nans =\n    -1     0     4     5     7    23\n% B为排序后的矩阵，I 是一个索引（稍后会介绍索引：表示对应的关系）\n% 可以看到 B 和 A(I) 是完全一致的。\n```\n\n\n#### flip\n\nflip 就是反转矩阵的元素  \n\n命令行输入  \n```\nA1 = [3 7 6 -1 0]\nB1 = flip(A1)\n\nA2 = [ 2 5 7;-5 3 5;0 6 5]\nB2 = flip(A2)\n\nA3 = [ 2 5 7;-5 3 5;0 6 5]\nB3 = flip(A3,2)\n```\n命令行输出   \n```\nA1 =\n     3     7     6    -1     0\nB1 =\n     0    -1     6     7     3\n% flip 函数用于快速反转一个矩阵\nA2 =\n     2     5     7\n    -5     3     5\n     0     6     5\nB2 =\n     0     6     5\n    -5     3     5\n     2     5     7\n二维矩阵的反转默认按列反转\nA3 =\n     2     5     7\n    -5     3     5\n     0     6     5\nB3 =\n     7     5     2\n     5     3    -5\n     5     6     0\n二维矩阵的反转也可以用 flip(__,2)指定按行反转\n```\n\n#### circshift\n\n循环移位：所有元素向后移位，超出的部分自动补回到最前面  \n\n命令行输入 \n```\nA1 = [3 7 6 -1 0 2 8 0 ]\nB1 = circshift(A1,[0,3])\n% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位\n\nA2 = [ 1 0 0;0 0 0;0 0 0]\nB2 = circshift(A2,[1,2])\n```\n命令行输出  \n```\nA1 =\n     3     7     6    -1     0     2     8     0\nB1 =\n     2     8     0     3     7     6    -1     0\n% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位\nA2 =\n     1     0     0\n     0     0     0\n     0     0     0\nB2 =\n     0     0     0\n     0     0     1\n     0     0     0\n```\n\n\n### **拼接矩阵**\n\n拼接矩阵是另一类创建矩阵的特殊手段，需要对矩阵元素直接的关系有足够的理解。我们先介绍（[]），再介绍类似于 repmat，cat，repelem 的函数用法。\n\n#### [] 符号\n\n我们将左右中括号用于创建矩阵，我们其实就是将若干个数用中括号实现了元素和矩阵的拼接。\n\n命令行输入  \n```\na = [1,2]\nb = [3,4] % 用来拼接\nc = [a,0,b] \nd = [a;b]\ne = [a,a;a,b]\n% f = [a,a,a;b,b] % 这样做矩阵不匹配\ng = [c;a,0,1,2]\n```\n命令行输出  \n```\na =\n     1     2\nb =\n     3     4\nc =\n     1     2     0     3     4\n% 矩阵和数字可以混合拼接\nd =\n     1     2\n     3     4\n% 分号换行就是在列方向上拼接\ne =\n     1     2     1     2\n     1     2     3     4\n% 二维矩阵也可以拼接\ng =\n     1     2     0     3     4\n     1     2     0     1     2\n% 只要总的可以组成矩阵，矩阵可以任意拼接。\n```\n\n\n#### repmat\n\n创建重复矩阵组成的拼接矩阵\n\n命令行输入 \n```\nA = [1,0;0,-1]\nB1 = repmat(A,2)% \nB2 = repmat(A,2,3)  % \nB3 = repmat(A,[2,3])% \n% repmat(__,[m,n])和repmat(__,m,n)完全一致。\n```\n命令行输出   \n```\nA =\n     1     0\n     0    -1\nB1 =\n     1     0     1     0\n     0    -1     0    -1\n     1     0     1     0\n     0    -1     0    -1\n% 只传一个参数时，会在两个维度上都进行重复\nB2 =\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\nB3 =\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\n % repmat(__,[m,n])和repmat(__,m,n)完全一致。\n % m为在列方向重复次数，n为在行方向重复次数。\n```\n\n\n#### cat\ncat 函数是中括号的函数形式，唯一不同的地方是 cat 函数可以连接三维矩阵  \n\n命令行输入 \n```\nA = [1, 2;3, 4]\nB = [5, 6;7, 8]\nC1 = cat(1,A,B)\nC2 = cat(2,A,B)\nC3 = cat(3,A,B)\n```\n命令行输出  \n```\nA =\n     1     2\n     3     4\nB =\n     5     6\n     7     8\nC1 =\n     1     2\n     3     4\n     5     6\n     7     8\n% 维度一，列方向\nC2 =\n     1     2     5     6\n     3     4     7     8\n% 维度二，行方向\nC3(:,:,1) =\n     1     2\n     3     4\nC3(:,:,2) =\n     5     6\n     7     8\n% 维度三，竖方向这样做可以创建三维矩阵\n```\n\n\n#### repelem\n\n复写矩阵里的元素\n\n命令行输入  \n```\nA1 = [ 1 2 3]\nB1 = repelem(A1,2)\n% 对于一维矩阵而言，repelem(__,m)相当于每个元素都重复 m 次。\nB2 = repelem(A1,[2 3 4])\n% 如果附加的参数是一个等长度的一维矩阵，那么会以对应的频数复写元素。\n\nA3 = [1 2; 3 4]\nB3 = repelem(A3,2,3)\n% 对于任意的矩阵而言都可以repelem(__,m,n),将每个元素以 m×n 复写\n```\n命令行输出 \n```\nA1 =\n     1     2     3\nB1 =\n     1     1     2     2     3     3\n% 输入的第二个参数是 2，对应将 A1 的元素复写 2 次\nB2 =\n     1     1     2     2     2     3     3     3     3\n% 输入的第二个参数是 [2 3 4]，对应将 A1 的元素复写 2，3，4 次\nA3 =\n     1     2\n     3     4\nB3 =\n     1     1     1     2     2     2\n     1     1     1     2     2     2\n     3     3     3     4     4     4\n     3     3     3     4     4     4\n% 输入的第二个参数是 2，输入的第三个参数是3 \n% 对应将 A3 的元素在列方向复写 2 次，行方向复写 3 次\n```\n\n\n### **索引**\n\n前面讲了那么多，终于可以讲最重要的索引部分。索引是什么？索引相当于编号，我们可以利用索引精确地找到我们想要的元素。无论是操作的输入还是输出，都要利用索引来实现。\n\n```\nA1 = [9 8 7 6 5 4 3 2 1]\nB1_1 = A1(1) % 与很多程序语言不一样的是，MATLAB 的索引从 1 开始，所以这一项返回第一个元素。\nB1_2 = A1([1 3 5 2 1]) % 如果索引不止一个，以矩阵形式传入，可以一次性返回。\nB1_3 = A1(1:2:7) % 冒号是使用索引的好助手\nB1_4 = A1(2:6) % 冒号也可以这样使用\nB1_5 = A1(:) % 只输入冒号相当于全部取出\nB1_7 = A1(end) % 另一个强大的标记是 end，表示该列(或者行)的最后一个索引\nB1_8 = A1(3:end) % （如果矩阵的长度会变，这会避免不少麻烦）。\n\nA2 = [4 5 6 7;5 7 9 0;  12 4 6 8; 0 -1 2  5]\nB2_1 = A2(2,2) % 二维矩阵可以用对应坐标取出\nB2_2 = A2(2,:) % 二维矩阵冒号相当于一行（或者一列）\nB2_3 = A2(2:end,1:3) % 可以一次取出对应多行多列的元素组成新的矩阵。\n\n% 特别的我们刚刚提到了一点：所有的矩阵在计算机中都是储存在线性空间里\n% 那么下面这两个例子就是最好的演示\nA3 = [1 2 3 4;5 6 7 8]\nB3_1 = A3(5)\nB3_2 = A3(5:7)\nB3_3 = A3(:)\nB3_4 = A3(:,:)\n\n```\n将以上命令输入至命令行，将得到以下输出：\n```\nA1 =\n     9     8     7     6     5     4     3     2     1\nB1_1 =\n     9\n% MATLAB 的索引从 1 开始！ MATLAB 的索引从1开始！ MATLAB的索引从1开始！\nB1_2 =\n     9     7     5     8     9\n% 多个索引以矩阵形式输入即可，允许重复索引，顺序无关\nB1_3 =\n     9     7     5     3\nB1_4 =\n     8     7     6     5     4\n% 冒号运算符可以线性关系的索引\nB1_5 =\n     9\n     8\n     7\n     6\n     5\n     4\n     3\n     2\n     1\n% 只输入冒号运算符索引全部元素，但是这个时候变成了列向量（元素都是在内存中按列排放的）\nB1_7 =\n     1\n% end是矩阵最后一个元素的索引\nB1_8 =\n     7     6     5     4     3     2     1\n% end和冒号运算符的结合运用可以快捷取出元素\nA2 =\n     4     5     6     7\n     5     7     9     0\n    12     4     6     8\n     0    -1     2     5\nB2_1 =\n     7\n% 二维矩阵的元素可以用对应二维坐标取出\nB2_2 =\n     5     7     9     0\n% 冒号作为矩阵行列索引，就是对应取出整行整列\nB2_3 =\n     5     7     9\n    12     4     6\n     0    -1     2\n% 利用冒号运算符可以一次取出对应多行多列的元素组成新的矩阵。\nA3 =\n     1     2     3     4\n     5     6     7     8\nB3_1 =\n     3\n% 所有的矩阵在计算机中都是储存在线性空间里\n% 实际上 A3 的线性排列 [1 5 2 6 3 7 4 8]\n% 矩阵的第五个元素就是对应元素3\nB3_2 =\n     3     7     4\n% 这种索引方式也可以用矩阵输入索引\nB3_3 =\n     1\n     5\n     2\n     6\n     3\n     7\n     4\n     8\n% 只输入冒号运算符索引全部元素，以列向量输出\nB3_4 =\n     1     2     3     4\n     5     6     7     8\n% A3(:,:)的形式可以取出整个二维矩阵，而不至于转成列向量\n```\n\n\n### **补充内容**\n\n本次的内容有点多，重点内容需要巩固：\n\n - size函数：目前来说最常见用于创建矩阵和确定循环结构的循环次数。\n```\n%% 1.模仿大师——创建一个一样大小的矩阵\na = [1 2 3 5;3 4  6 7];\nb = zeros(size(a)); % 这就创建了一个大小完全一致的全零矩阵\n% 试想如果 a 是外部输入的长度不确定的变量，这种方法就很高效\n%% 2.循环次数\nx = -1 : 0.1 : 3;\ny = x;\nfor index = 1:size(x,2)\n    y(index) = (x(index)-1) * (x(index)-2) + index;\nend\nplot(x,y,'r--','LineWidth',3); % 曲线绘图函数\n```\n\n - reshape函数：重新排列矩阵，快速处理数据的手段\n```\nA = 1:15;\n% 这样可以按列创建顺序的矩阵\nB1 = reshape(A,3,5)\n% 这样可以按行创建顺序的矩阵\nB2 = reshape(A,5,3)'\n% 三维数组为未尝不可\nB3 = reshape(A,5,1,3)\n```\n\n - sort函数：内置的sort函数比自己编写的排序更高效\n```\nx = [ 8 9 2 4 0 10 3 6 7 1];\ny = x.*x;\nplot(x,y,'r*-');\n% 点还是那些点，但顺序不对会影响绘图质量\n% 这时排序可以用上\n[x1,index] = sort(x);\nplot(x1,y(index),'r*-');\n```\n\n - [ ]运算符：串联矩阵最重要的步骤\n```\n% 绘制斐波那契数列的曲线\nx = 1:15;\ny = [1,1];\nfor index = 3:size(x,2)\n    y = [y y(end)+ y(end-1)];\nend\nplot(x,y,'ro-','LineWidth',3); % 曲线绘图函数\n```\n\n - repmat函数：重复矩阵的拼接\n```\n% 字符串也可以拼接\na = ['hello']\nb = repmat(a,3,2)\n```\n\n - 索引：功能强大，针对性的选取数组元素\n\n\n```\n% 仍使用sort的案例\n% 这里我并没有重新计算 y1 = x*x，是因为索引能直接找到对应的 y\nx = [ 8 9 2 4 0 10 3 6 7 1];\ny = x.*x;\nplot(x,y,'r*-');\n% 点还是那些点，但顺序不对会影响绘图质量\n% 这时排序可以用上\n[x1,index] = sort(x);\nplot(x1,y(index),'r*-');\n\n%% 索引的具体应用更重要的是逻辑变量和 find 函数（篇幅有限，之后补充）。\n```\n\n\n### **思考**\n\n每一行代码执行后，对应变量会有什么变化？\n\n```\na = 2:3:8;\nb = [a' a' a'];\nc = b(1:2:3,1:2:3);\nd = a + b(2,:);\nw = [zero(1,3) ones(1,3)' 3:5'];\nb([1,3],2) = b([3,1],2);\ne = 1:-1:5;\n```\n\n解答：   \n\n```\na是一个 1×3 的矩阵 [\t2\t5\t8\t]\nb是一个 3×3 的矩阵 [\t2\t2\t2;\n\t\t\t\t\t\t5\t5\t5;\n\t\t\t\t\t\t8\t8\t8\t]\nc是一个 2×2 的矩阵[\t2\t2;\n                    8\t8\t]\nd是一个 1×3 的矩阵[\t7\t10\t13\t]\ne是一个 1×9 的矩阵[\t0\t0\t0\t1\t1\t1\t3\t4\t5\t]\nb([1\t3],2)=[\t8\t2\t]修改了原有 b 矩阵的值\n实际上 b 发生改变 [\t2\t8\t2;\n\t\t\t\t\t5\t5\t5;\n                    8\t2\t8\t]\ne 是一个空矩阵\n```\n\n### **总结**\n\n本次的内容最大的重点是索引，结合逻辑矩阵能编写高效而简洁的代码。\n\n","source":"_posts/MATLAB-矩阵（二）.md","raw":"---\ntitle: MATLAB 矩阵（二）\ndate: 2018-03-04 03:46:39\ntags: MATLAB\n---\n---\n\n### **概述**\n\n本次的内容有点多，划一下重点：\n - size 函数：创建矩阵和确定循环结构的循环次数\n - reshape 函数：重新排列矩阵\n - sort 函数：内置的 sort 函数比自己编写的排序更高效\n - [] 中括号运算符：串联矩阵最重要的步骤\n - repmat 函数：重复矩阵的拼接\n - 索引：功能强大，针对性的选取数组元素\n\n <!--more-->\n \n### **矩阵的属性**  \n\n复习一下之前介绍过的 MATLAB 命令：（>> whos）。\n\n功能为显示所有变量的属性。有时候我们需要根据矩阵的属性来做一些操作就需要用到矩阵的一些相关属性。常用的属性都可以通过函数来调用：size，length，isrow，numel 等。\n\n\n#### size\nsize 函数返回矩阵的各个维度的长度，调用方法为：sz = size(A)  \n\n命令行输入  \n```\n% size ()\n% \nA = zeros(3,4); % 先创建一个 3×4 的零矩阵，观察以下几个值\nS = size(A)\n[m,n] = size(A)\n% 补充：这样写是能够让函数返回两个不同的输出参数。\n% 调用函数时，系统会告诉函数有多少个输入参数和输出参数\n% 函数本身则根据输入输出参数的数量决定自己的输出参数。\nmm = size(A,1)\nnn = size(A,2)\n```\n\n命令行输出\n```\nS =\n     3     4\n% 直接调用返回一个输出参数时：\n% size 函数返回一个矩阵包含各个维度长度的矩阵。\nm =\n\n     3\nn =\n\n     4\n% 直接调用返回两个输出参数时：\n% size函数返回两个标量各自表示各个维度长度。\n\nmm =\n     3\nnn =\n     4\n% 调用size函数时，加上想查询的具体维度，可以返回该维度上的长度\n% 在这里，1 指横坐标，2 指纵坐标，3 指竖坐标   \n```\n\n#### length  \n\nlength函数返回矩阵的最长维度的长度，调用方法为：L = length(A)  \n\n命令行输入 \n```\n% length ()\nA = zeros(3,4); % 先创建一个 3×4 的零矩阵\nS = length(A)\n```\n\n命令行输出  \n```\nS =\n        4\n% length 函数返回矩阵的最长维度的长度，相当于 size(A)的最大值。\n```\n\n\n#### isrow  \n\nisrow如其名，作用就是询问矩阵是不是行向量。\n同样作用的还有 iscolumn 确定矩阵是不是列向量，isempty 确定矩阵是不是为空\n\n命令行输入 \n```\n% isrow ()\nA = zeros(1,4); % 创建一个 1×4 的矩阵，观察以下几个值\nS1 = isrow(A)\nS2 = iscolumn(A)\nS3 = isempty(A)\nwhos S1\n```\n命令行输出\n```\nS1 =\n     1\n\nS2 =\n     0\n\nS3 =\n     0\n  Name      Size            Bytes  Class      Attributes\n  S1        1x1                 1  logical  \n% isrow 函数返回一个布尔值 1 或 0\n% 用 whos 命令可以看到返回的类型是 logical（逻辑值非一即零，非真即假）。\n```\n\n\n#### numel\n\nnumel 函数返回数组元素的数量。  \n\n命令行输入 \n```\nA = zeros(3,4); % 创建一个 1×4 的矩阵，观察以下几个值\nn = numel(A)\n```\n命令行输出\n```\nn =\n    12 \n% 返回矩阵所有元素的个数\n```\n\n### **矩阵的排列**\n\n矩阵的另一类操作是排列，对矩阵内的元素的相对位置重新处理，（很抽象的描述，还是看看函数的功能比较容易）。常见的的函数有 reshape，sort，flip，circshift 等\n\n\n\n#### reshape\n\nreshape 函数顾名思义就是对矩阵重排。  \n\n命令行输入 \n```\nA = magic(4) % 创建一个 4×4 的矩阵，观察以下几个值\nAA = reshape(A,2,8)\n```\n命令行输出\n```\n% reshape 之前\nA =\n\n    16     2     3    13\n     5    11    10     8\n     9     7     6    12\n     4    14    15     1\n\n% reshape 之后\nAA =\n\n    16     9     2     7     3     6    13    12\n     5     4    11    14    10    15     8     1\n     \n% 这里又有另一个关注的点：重排的顺序，可以看到A的每一列分成了两列\n% 原理：所有的矩阵在计算机中都是储存在线性空间里，实际上的顺序就是一列一列的拼接：\n% 16 5 9 4 2 11 7 14 3 10 6 15 13 8 12 1\n% 重排的时候仍然依照这个顺序取出。\n```\n\n\n#### sort  \n\n对矩阵进行排序，默认升序（从小到大）  \n\n命令行输入 \n```\nA1 = [ 23 5 -1 4  7 0]\nB1 = sort(A1)\n\nA2 = [7 8 9; 2 4 -2; 10 2 4]\nB2 = sort(A2,2) % 另一个输入参数为排序的维度\n% 1 指横坐标，2 指纵坐标，3 指竖坐标的规则仍适用\nB2 = sort(A2) % 若不输入另一个参数，则默认另一个参数是 1，按列排序\n\nA3 = [ 23 5 -1 4  7 0]\nB3 = sort(A3,'descend') \n% 默认情况下，sort 为升序（'ascend'），使用降序时，可以使用输入参数'descend'来使用降序方法\n\nA4 = [ 23 5 -1 4  7 0]\n[B,I] = sort(A4)\nA(I)\n% sort 返回两个输出参数时，\n% 第一个变量返回排序后的数组，\n% 第二个变量返回排序后的数组对应原有的数组索引 A(I)和 B 是一样的。\n\n```\n命令行输出  \n```\nA1 =\n    23     5    -1     4     7     0\nB1 =\n    -1     0     4     5     7    23\n% sort 排序一维矩阵时，返回排序后的一维矩阵\n\nA2 =\n     7     8     9\n     2     4    -2\n    10     2     4\n\nB2 =\n     7     8     9\n    -2     2     4\n     2     4    10\n% 另一个输入参数为 2，也就是按纵坐标排序\n\nB2 =\n     2     2    -2\n     7     4     4\n    10     8     9\n% 若不输入另一个参数，则默认另一个参数是 1，按列排序\n    \nA3 =\n    23     5    -1     4     7     0\nB3 =\n    23     7     5     4     0    -1\n% 可以sort(A3,'descend')\n\nA4 =\n    23     5    -1     4     7     0\nB =\n    -1     0     4     5     7    23\nI =\n     3     6     4     2     5     1\nans =\n    -1     0     4     5     7    23\n% B为排序后的矩阵，I 是一个索引（稍后会介绍索引：表示对应的关系）\n% 可以看到 B 和 A(I) 是完全一致的。\n```\n\n\n#### flip\n\nflip 就是反转矩阵的元素  \n\n命令行输入  \n```\nA1 = [3 7 6 -1 0]\nB1 = flip(A1)\n\nA2 = [ 2 5 7;-5 3 5;0 6 5]\nB2 = flip(A2)\n\nA3 = [ 2 5 7;-5 3 5;0 6 5]\nB3 = flip(A3,2)\n```\n命令行输出   \n```\nA1 =\n     3     7     6    -1     0\nB1 =\n     0    -1     6     7     3\n% flip 函数用于快速反转一个矩阵\nA2 =\n     2     5     7\n    -5     3     5\n     0     6     5\nB2 =\n     0     6     5\n    -5     3     5\n     2     5     7\n二维矩阵的反转默认按列反转\nA3 =\n     2     5     7\n    -5     3     5\n     0     6     5\nB3 =\n     7     5     2\n     5     3    -5\n     5     6     0\n二维矩阵的反转也可以用 flip(__,2)指定按行反转\n```\n\n#### circshift\n\n循环移位：所有元素向后移位，超出的部分自动补回到最前面  \n\n命令行输入 \n```\nA1 = [3 7 6 -1 0 2 8 0 ]\nB1 = circshift(A1,[0,3])\n% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位\n\nA2 = [ 1 0 0;0 0 0;0 0 0]\nB2 = circshift(A2,[1,2])\n```\n命令行输出  \n```\nA1 =\n     3     7     6    -1     0     2     8     0\nB1 =\n     2     8     0     3     7     6    -1     0\n% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位\nA2 =\n     1     0     0\n     0     0     0\n     0     0     0\nB2 =\n     0     0     0\n     0     0     1\n     0     0     0\n```\n\n\n### **拼接矩阵**\n\n拼接矩阵是另一类创建矩阵的特殊手段，需要对矩阵元素直接的关系有足够的理解。我们先介绍（[]），再介绍类似于 repmat，cat，repelem 的函数用法。\n\n#### [] 符号\n\n我们将左右中括号用于创建矩阵，我们其实就是将若干个数用中括号实现了元素和矩阵的拼接。\n\n命令行输入  \n```\na = [1,2]\nb = [3,4] % 用来拼接\nc = [a,0,b] \nd = [a;b]\ne = [a,a;a,b]\n% f = [a,a,a;b,b] % 这样做矩阵不匹配\ng = [c;a,0,1,2]\n```\n命令行输出  \n```\na =\n     1     2\nb =\n     3     4\nc =\n     1     2     0     3     4\n% 矩阵和数字可以混合拼接\nd =\n     1     2\n     3     4\n% 分号换行就是在列方向上拼接\ne =\n     1     2     1     2\n     1     2     3     4\n% 二维矩阵也可以拼接\ng =\n     1     2     0     3     4\n     1     2     0     1     2\n% 只要总的可以组成矩阵，矩阵可以任意拼接。\n```\n\n\n#### repmat\n\n创建重复矩阵组成的拼接矩阵\n\n命令行输入 \n```\nA = [1,0;0,-1]\nB1 = repmat(A,2)% \nB2 = repmat(A,2,3)  % \nB3 = repmat(A,[2,3])% \n% repmat(__,[m,n])和repmat(__,m,n)完全一致。\n```\n命令行输出   \n```\nA =\n     1     0\n     0    -1\nB1 =\n     1     0     1     0\n     0    -1     0    -1\n     1     0     1     0\n     0    -1     0    -1\n% 只传一个参数时，会在两个维度上都进行重复\nB2 =\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\nB3 =\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\n     1     0     1     0     1     0\n     0    -1     0    -1     0    -1\n % repmat(__,[m,n])和repmat(__,m,n)完全一致。\n % m为在列方向重复次数，n为在行方向重复次数。\n```\n\n\n#### cat\ncat 函数是中括号的函数形式，唯一不同的地方是 cat 函数可以连接三维矩阵  \n\n命令行输入 \n```\nA = [1, 2;3, 4]\nB = [5, 6;7, 8]\nC1 = cat(1,A,B)\nC2 = cat(2,A,B)\nC3 = cat(3,A,B)\n```\n命令行输出  \n```\nA =\n     1     2\n     3     4\nB =\n     5     6\n     7     8\nC1 =\n     1     2\n     3     4\n     5     6\n     7     8\n% 维度一，列方向\nC2 =\n     1     2     5     6\n     3     4     7     8\n% 维度二，行方向\nC3(:,:,1) =\n     1     2\n     3     4\nC3(:,:,2) =\n     5     6\n     7     8\n% 维度三，竖方向这样做可以创建三维矩阵\n```\n\n\n#### repelem\n\n复写矩阵里的元素\n\n命令行输入  \n```\nA1 = [ 1 2 3]\nB1 = repelem(A1,2)\n% 对于一维矩阵而言，repelem(__,m)相当于每个元素都重复 m 次。\nB2 = repelem(A1,[2 3 4])\n% 如果附加的参数是一个等长度的一维矩阵，那么会以对应的频数复写元素。\n\nA3 = [1 2; 3 4]\nB3 = repelem(A3,2,3)\n% 对于任意的矩阵而言都可以repelem(__,m,n),将每个元素以 m×n 复写\n```\n命令行输出 \n```\nA1 =\n     1     2     3\nB1 =\n     1     1     2     2     3     3\n% 输入的第二个参数是 2，对应将 A1 的元素复写 2 次\nB2 =\n     1     1     2     2     2     3     3     3     3\n% 输入的第二个参数是 [2 3 4]，对应将 A1 的元素复写 2，3，4 次\nA3 =\n     1     2\n     3     4\nB3 =\n     1     1     1     2     2     2\n     1     1     1     2     2     2\n     3     3     3     4     4     4\n     3     3     3     4     4     4\n% 输入的第二个参数是 2，输入的第三个参数是3 \n% 对应将 A3 的元素在列方向复写 2 次，行方向复写 3 次\n```\n\n\n### **索引**\n\n前面讲了那么多，终于可以讲最重要的索引部分。索引是什么？索引相当于编号，我们可以利用索引精确地找到我们想要的元素。无论是操作的输入还是输出，都要利用索引来实现。\n\n```\nA1 = [9 8 7 6 5 4 3 2 1]\nB1_1 = A1(1) % 与很多程序语言不一样的是，MATLAB 的索引从 1 开始，所以这一项返回第一个元素。\nB1_2 = A1([1 3 5 2 1]) % 如果索引不止一个，以矩阵形式传入，可以一次性返回。\nB1_3 = A1(1:2:7) % 冒号是使用索引的好助手\nB1_4 = A1(2:6) % 冒号也可以这样使用\nB1_5 = A1(:) % 只输入冒号相当于全部取出\nB1_7 = A1(end) % 另一个强大的标记是 end，表示该列(或者行)的最后一个索引\nB1_8 = A1(3:end) % （如果矩阵的长度会变，这会避免不少麻烦）。\n\nA2 = [4 5 6 7;5 7 9 0;  12 4 6 8; 0 -1 2  5]\nB2_1 = A2(2,2) % 二维矩阵可以用对应坐标取出\nB2_2 = A2(2,:) % 二维矩阵冒号相当于一行（或者一列）\nB2_3 = A2(2:end,1:3) % 可以一次取出对应多行多列的元素组成新的矩阵。\n\n% 特别的我们刚刚提到了一点：所有的矩阵在计算机中都是储存在线性空间里\n% 那么下面这两个例子就是最好的演示\nA3 = [1 2 3 4;5 6 7 8]\nB3_1 = A3(5)\nB3_2 = A3(5:7)\nB3_3 = A3(:)\nB3_4 = A3(:,:)\n\n```\n将以上命令输入至命令行，将得到以下输出：\n```\nA1 =\n     9     8     7     6     5     4     3     2     1\nB1_1 =\n     9\n% MATLAB 的索引从 1 开始！ MATLAB 的索引从1开始！ MATLAB的索引从1开始！\nB1_2 =\n     9     7     5     8     9\n% 多个索引以矩阵形式输入即可，允许重复索引，顺序无关\nB1_3 =\n     9     7     5     3\nB1_4 =\n     8     7     6     5     4\n% 冒号运算符可以线性关系的索引\nB1_5 =\n     9\n     8\n     7\n     6\n     5\n     4\n     3\n     2\n     1\n% 只输入冒号运算符索引全部元素，但是这个时候变成了列向量（元素都是在内存中按列排放的）\nB1_7 =\n     1\n% end是矩阵最后一个元素的索引\nB1_8 =\n     7     6     5     4     3     2     1\n% end和冒号运算符的结合运用可以快捷取出元素\nA2 =\n     4     5     6     7\n     5     7     9     0\n    12     4     6     8\n     0    -1     2     5\nB2_1 =\n     7\n% 二维矩阵的元素可以用对应二维坐标取出\nB2_2 =\n     5     7     9     0\n% 冒号作为矩阵行列索引，就是对应取出整行整列\nB2_3 =\n     5     7     9\n    12     4     6\n     0    -1     2\n% 利用冒号运算符可以一次取出对应多行多列的元素组成新的矩阵。\nA3 =\n     1     2     3     4\n     5     6     7     8\nB3_1 =\n     3\n% 所有的矩阵在计算机中都是储存在线性空间里\n% 实际上 A3 的线性排列 [1 5 2 6 3 7 4 8]\n% 矩阵的第五个元素就是对应元素3\nB3_2 =\n     3     7     4\n% 这种索引方式也可以用矩阵输入索引\nB3_3 =\n     1\n     5\n     2\n     6\n     3\n     7\n     4\n     8\n% 只输入冒号运算符索引全部元素，以列向量输出\nB3_4 =\n     1     2     3     4\n     5     6     7     8\n% A3(:,:)的形式可以取出整个二维矩阵，而不至于转成列向量\n```\n\n\n### **补充内容**\n\n本次的内容有点多，重点内容需要巩固：\n\n - size函数：目前来说最常见用于创建矩阵和确定循环结构的循环次数。\n```\n%% 1.模仿大师——创建一个一样大小的矩阵\na = [1 2 3 5;3 4  6 7];\nb = zeros(size(a)); % 这就创建了一个大小完全一致的全零矩阵\n% 试想如果 a 是外部输入的长度不确定的变量，这种方法就很高效\n%% 2.循环次数\nx = -1 : 0.1 : 3;\ny = x;\nfor index = 1:size(x,2)\n    y(index) = (x(index)-1) * (x(index)-2) + index;\nend\nplot(x,y,'r--','LineWidth',3); % 曲线绘图函数\n```\n\n - reshape函数：重新排列矩阵，快速处理数据的手段\n```\nA = 1:15;\n% 这样可以按列创建顺序的矩阵\nB1 = reshape(A,3,5)\n% 这样可以按行创建顺序的矩阵\nB2 = reshape(A,5,3)'\n% 三维数组为未尝不可\nB3 = reshape(A,5,1,3)\n```\n\n - sort函数：内置的sort函数比自己编写的排序更高效\n```\nx = [ 8 9 2 4 0 10 3 6 7 1];\ny = x.*x;\nplot(x,y,'r*-');\n% 点还是那些点，但顺序不对会影响绘图质量\n% 这时排序可以用上\n[x1,index] = sort(x);\nplot(x1,y(index),'r*-');\n```\n\n - [ ]运算符：串联矩阵最重要的步骤\n```\n% 绘制斐波那契数列的曲线\nx = 1:15;\ny = [1,1];\nfor index = 3:size(x,2)\n    y = [y y(end)+ y(end-1)];\nend\nplot(x,y,'ro-','LineWidth',3); % 曲线绘图函数\n```\n\n - repmat函数：重复矩阵的拼接\n```\n% 字符串也可以拼接\na = ['hello']\nb = repmat(a,3,2)\n```\n\n - 索引：功能强大，针对性的选取数组元素\n\n\n```\n% 仍使用sort的案例\n% 这里我并没有重新计算 y1 = x*x，是因为索引能直接找到对应的 y\nx = [ 8 9 2 4 0 10 3 6 7 1];\ny = x.*x;\nplot(x,y,'r*-');\n% 点还是那些点，但顺序不对会影响绘图质量\n% 这时排序可以用上\n[x1,index] = sort(x);\nplot(x1,y(index),'r*-');\n\n%% 索引的具体应用更重要的是逻辑变量和 find 函数（篇幅有限，之后补充）。\n```\n\n\n### **思考**\n\n每一行代码执行后，对应变量会有什么变化？\n\n```\na = 2:3:8;\nb = [a' a' a'];\nc = b(1:2:3,1:2:3);\nd = a + b(2,:);\nw = [zero(1,3) ones(1,3)' 3:5'];\nb([1,3],2) = b([3,1],2);\ne = 1:-1:5;\n```\n\n解答：   \n\n```\na是一个 1×3 的矩阵 [\t2\t5\t8\t]\nb是一个 3×3 的矩阵 [\t2\t2\t2;\n\t\t\t\t\t\t5\t5\t5;\n\t\t\t\t\t\t8\t8\t8\t]\nc是一个 2×2 的矩阵[\t2\t2;\n                    8\t8\t]\nd是一个 1×3 的矩阵[\t7\t10\t13\t]\ne是一个 1×9 的矩阵[\t0\t0\t0\t1\t1\t1\t3\t4\t5\t]\nb([1\t3],2)=[\t8\t2\t]修改了原有 b 矩阵的值\n实际上 b 发生改变 [\t2\t8\t2;\n\t\t\t\t\t5\t5\t5;\n                    8\t2\t8\t]\ne 是一个空矩阵\n```\n\n### **总结**\n\n本次的内容最大的重点是索引，结合逻辑矩阵能编写高效而简洁的代码。\n\n","slug":"MATLAB-矩阵（二）","published":1,"updated":"2020-03-15T21:05:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wi000m29fyejba5fzh","content":"<hr>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>本次的内容有点多，划一下重点：</p>\n<ul>\n<li><p>size 函数：创建矩阵和确定循环结构的循环次数</p>\n</li>\n<li><p>reshape 函数：重新排列矩阵</p>\n</li>\n<li><p>sort 函数：内置的 sort 函数比自己编写的排序更高效</p>\n</li>\n<li><p>[] 中括号运算符：串联矩阵最重要的步骤</p>\n</li>\n<li><p>repmat 函数：重复矩阵的拼接</p>\n</li>\n<li><p>索引：功能强大，针对性的选取数组元素</p>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"矩阵的属性\"><a href=\"#矩阵的属性\" class=\"headerlink\" title=\"矩阵的属性\"></a><strong>矩阵的属性</strong></h3><p>复习一下之前介绍过的 MATLAB 命令：（&gt;&gt; whos）。</p>\n<p>功能为显示所有变量的属性。有时候我们需要根据矩阵的属性来做一些操作就需要用到矩阵的一些相关属性。常用的属性都可以通过函数来调用：size，length，isrow，numel 等。</p>\n<h4 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size\"></a>size</h4><p>size 函数返回矩阵的各个维度的长度，调用方法为：sz = size(A)  </p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% size ()</span><br><span class=\"line\">% </span><br><span class=\"line\">A = zeros(3,4); % 先创建一个 3×4 的零矩阵，观察以下几个值</span><br><span class=\"line\">S = size(A)</span><br><span class=\"line\">[m,n] = size(A)</span><br><span class=\"line\">% 补充：这样写是能够让函数返回两个不同的输出参数。</span><br><span class=\"line\">% 调用函数时，系统会告诉函数有多少个输入参数和输出参数</span><br><span class=\"line\">% 函数本身则根据输入输出参数的数量决定自己的输出参数。</span><br><span class=\"line\">mm = size(A,1)</span><br><span class=\"line\">nn = size(A,2)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S =</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">% 直接调用返回一个输出参数时：</span><br><span class=\"line\">% size 函数返回一个矩阵包含各个维度长度的矩阵。</span><br><span class=\"line\">m =</span><br><span class=\"line\"></span><br><span class=\"line\">     3</span><br><span class=\"line\">n =</span><br><span class=\"line\"></span><br><span class=\"line\">     4</span><br><span class=\"line\">% 直接调用返回两个输出参数时：</span><br><span class=\"line\">% size函数返回两个标量各自表示各个维度长度。</span><br><span class=\"line\"></span><br><span class=\"line\">mm =</span><br><span class=\"line\">     3</span><br><span class=\"line\">nn =</span><br><span class=\"line\">     4</span><br><span class=\"line\">% 调用size函数时，加上想查询的具体维度，可以返回该维度上的长度</span><br><span class=\"line\">% 在这里，1 指横坐标，2 指纵坐标，3 指竖坐标</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h4><p>length函数返回矩阵的最长维度的长度，调用方法为：L = length(A)  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% length ()</span><br><span class=\"line\">A = zeros(3,4); % 先创建一个 3×4 的零矩阵</span><br><span class=\"line\">S = length(A)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S =</span><br><span class=\"line\">        4</span><br><span class=\"line\">% length 函数返回矩阵的最长维度的长度，相当于 size(A)的最大值。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"isrow\"><a href=\"#isrow\" class=\"headerlink\" title=\"isrow\"></a>isrow</h4><p>isrow如其名，作用就是询问矩阵是不是行向量。<br>同样作用的还有 iscolumn 确定矩阵是不是列向量，isempty 确定矩阵是不是为空</p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% isrow ()</span><br><span class=\"line\">A = zeros(1,4); % 创建一个 1×4 的矩阵，观察以下几个值</span><br><span class=\"line\">S1 = isrow(A)</span><br><span class=\"line\">S2 = iscolumn(A)</span><br><span class=\"line\">S3 = isempty(A)</span><br><span class=\"line\">whos S1</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S1 =</span><br><span class=\"line\">     1</span><br><span class=\"line\"></span><br><span class=\"line\">S2 =</span><br><span class=\"line\">     0</span><br><span class=\"line\"></span><br><span class=\"line\">S3 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">  Name      Size            Bytes  Class      Attributes</span><br><span class=\"line\">  S1        1x1                 1  logical  </span><br><span class=\"line\">% isrow 函数返回一个布尔值 1 或 0</span><br><span class=\"line\">% 用 whos 命令可以看到返回的类型是 logical（逻辑值非一即零，非真即假）。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"numel\"><a href=\"#numel\" class=\"headerlink\" title=\"numel\"></a>numel</h4><p>numel 函数返回数组元素的数量。  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = zeros(3,4); % 创建一个 1×4 的矩阵，观察以下几个值</span><br><span class=\"line\">n = numel(A)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n =</span><br><span class=\"line\">    12 </span><br><span class=\"line\">% 返回矩阵所有元素的个数</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"矩阵的排列\"><a href=\"#矩阵的排列\" class=\"headerlink\" title=\"矩阵的排列\"></a><strong>矩阵的排列</strong></h3><p>矩阵的另一类操作是排列，对矩阵内的元素的相对位置重新处理，（很抽象的描述，还是看看函数的功能比较容易）。常见的的函数有 reshape，sort，flip，circshift 等</p>\n<h4 id=\"reshape\"><a href=\"#reshape\" class=\"headerlink\" title=\"reshape\"></a>reshape</h4><p>reshape 函数顾名思义就是对矩阵重排。  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = magic(4) % 创建一个 4×4 的矩阵，观察以下几个值</span><br><span class=\"line\">AA = reshape(A,2,8)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% reshape 之前</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">    16     2     3    13</span><br><span class=\"line\">     5    11    10     8</span><br><span class=\"line\">     9     7     6    12</span><br><span class=\"line\">     4    14    15     1</span><br><span class=\"line\"></span><br><span class=\"line\">% reshape 之后</span><br><span class=\"line\">AA =</span><br><span class=\"line\"></span><br><span class=\"line\">    16     9     2     7     3     6    13    12</span><br><span class=\"line\">     5     4    11    14    10    15     8     1</span><br><span class=\"line\">     </span><br><span class=\"line\">% 这里又有另一个关注的点：重排的顺序，可以看到A的每一列分成了两列</span><br><span class=\"line\">% 原理：所有的矩阵在计算机中都是储存在线性空间里，实际上的顺序就是一列一列的拼接：</span><br><span class=\"line\">% 16 5 9 4 2 11 7 14 3 10 6 15 13 8 12 1</span><br><span class=\"line\">% 重排的时候仍然依照这个顺序取出。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>对矩阵进行排序，默认升序（从小到大）  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [ 23 5 -1 4  7 0]</span><br><span class=\"line\">B1 = sort(A1)</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [7 8 9; 2 4 -2; 10 2 4]</span><br><span class=\"line\">B2 = sort(A2,2) % 另一个输入参数为排序的维度</span><br><span class=\"line\">% 1 指横坐标，2 指纵坐标，3 指竖坐标的规则仍适用</span><br><span class=\"line\">B2 = sort(A2) % 若不输入另一个参数，则默认另一个参数是 1，按列排序</span><br><span class=\"line\"></span><br><span class=\"line\">A3 = [ 23 5 -1 4  7 0]</span><br><span class=\"line\">B3 = sort(A3,&apos;descend&apos;) </span><br><span class=\"line\">% 默认情况下，sort 为升序（&apos;ascend&apos;），使用降序时，可以使用输入参数&apos;descend&apos;来使用降序方法</span><br><span class=\"line\"></span><br><span class=\"line\">A4 = [ 23 5 -1 4  7 0]</span><br><span class=\"line\">[B,I] = sort(A4)</span><br><span class=\"line\">A(I)</span><br><span class=\"line\">% sort 返回两个输出参数时，</span><br><span class=\"line\">% 第一个变量返回排序后的数组，</span><br><span class=\"line\">% 第二个变量返回排序后的数组对应原有的数组索引 A(I)和 B 是一样的。</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">    23     5    -1     4     7     0</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">    -1     0     4     5     7    23</span><br><span class=\"line\">% sort 排序一维矩阵时，返回排序后的一维矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     7     8     9</span><br><span class=\"line\">     2     4    -2</span><br><span class=\"line\">    10     2     4</span><br><span class=\"line\"></span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     7     8     9</span><br><span class=\"line\">    -2     2     4</span><br><span class=\"line\">     2     4    10</span><br><span class=\"line\">% 另一个输入参数为 2，也就是按纵坐标排序</span><br><span class=\"line\"></span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     2     2    -2</span><br><span class=\"line\">     7     4     4</span><br><span class=\"line\">    10     8     9</span><br><span class=\"line\">% 若不输入另一个参数，则默认另一个参数是 1，按列排序</span><br><span class=\"line\">    </span><br><span class=\"line\">A3 =</span><br><span class=\"line\">    23     5    -1     4     7     0</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">    23     7     5     4     0    -1</span><br><span class=\"line\">% 可以sort(A3,&apos;descend&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">A4 =</span><br><span class=\"line\">    23     5    -1     4     7     0</span><br><span class=\"line\">B =</span><br><span class=\"line\">    -1     0     4     5     7    23</span><br><span class=\"line\">I =</span><br><span class=\"line\">     3     6     4     2     5     1</span><br><span class=\"line\">ans =</span><br><span class=\"line\">    -1     0     4     5     7    23</span><br><span class=\"line\">% B为排序后的矩阵，I 是一个索引（稍后会介绍索引：表示对应的关系）</span><br><span class=\"line\">% 可以看到 B 和 A(I) 是完全一致的。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flip\"><a href=\"#flip\" class=\"headerlink\" title=\"flip\"></a>flip</h4><p>flip 就是反转矩阵的元素  </p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [3 7 6 -1 0]</span><br><span class=\"line\">B1 = flip(A1)</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [ 2 5 7;-5 3 5;0 6 5]</span><br><span class=\"line\">B2 = flip(A2)</span><br><span class=\"line\"></span><br><span class=\"line\">A3 = [ 2 5 7;-5 3 5;0 6 5]</span><br><span class=\"line\">B3 = flip(A3,2)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     3     7     6    -1     0</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     0    -1     6     7     3</span><br><span class=\"line\">% flip 函数用于快速反转一个矩阵</span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     2     5     7</span><br><span class=\"line\">    -5     3     5</span><br><span class=\"line\">     0     6     5</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     0     6     5</span><br><span class=\"line\">    -5     3     5</span><br><span class=\"line\">     2     5     7</span><br><span class=\"line\">二维矩阵的反转默认按列反转</span><br><span class=\"line\">A3 =</span><br><span class=\"line\">     2     5     7</span><br><span class=\"line\">    -5     3     5</span><br><span class=\"line\">     0     6     5</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">     7     5     2</span><br><span class=\"line\">     5     3    -5</span><br><span class=\"line\">     5     6     0</span><br><span class=\"line\">二维矩阵的反转也可以用 flip(__,2)指定按行反转</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"circshift\"><a href=\"#circshift\" class=\"headerlink\" title=\"circshift\"></a>circshift</h4><p>循环移位：所有元素向后移位，超出的部分自动补回到最前面  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [3 7 6 -1 0 2 8 0 ]</span><br><span class=\"line\">B1 = circshift(A1,[0,3])</span><br><span class=\"line\">% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [ 1 0 0;0 0 0;0 0 0]</span><br><span class=\"line\">B2 = circshift(A2,[1,2])</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     3     7     6    -1     0     2     8     0</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     2     8     0     3     7     6    -1     0</span><br><span class=\"line\">% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位</span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     1     0     0</span><br><span class=\"line\">     0     0     0</span><br><span class=\"line\">     0     0     0</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     0     0     0</span><br><span class=\"line\">     0     0     1</span><br><span class=\"line\">     0     0     0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接矩阵\"><a href=\"#拼接矩阵\" class=\"headerlink\" title=\"拼接矩阵\"></a><strong>拼接矩阵</strong></h3><p>拼接矩阵是另一类创建矩阵的特殊手段，需要对矩阵元素直接的关系有足够的理解。我们先介绍（[]），再介绍类似于 repmat，cat，repelem 的函数用法。</p>\n<h4 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"[] 符号\"></a>[] 符号</h4><p>我们将左右中括号用于创建矩阵，我们其实就是将若干个数用中括号实现了元素和矩阵的拼接。</p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [1,2]</span><br><span class=\"line\">b = [3,4] % 用来拼接</span><br><span class=\"line\">c = [a,0,b] </span><br><span class=\"line\">d = [a;b]</span><br><span class=\"line\">e = [a,a;a,b]</span><br><span class=\"line\">% f = [a,a,a;b,b] % 这样做矩阵不匹配</span><br><span class=\"line\">g = [c;a,0,1,2]</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">b =</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">c =</span><br><span class=\"line\">     1     2     0     3     4</span><br><span class=\"line\">% 矩阵和数字可以混合拼接</span><br><span class=\"line\">d =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">% 分号换行就是在列方向上拼接</span><br><span class=\"line\">e =</span><br><span class=\"line\">     1     2     1     2</span><br><span class=\"line\">     1     2     3     4</span><br><span class=\"line\">% 二维矩阵也可以拼接</span><br><span class=\"line\">g =</span><br><span class=\"line\">     1     2     0     3     4</span><br><span class=\"line\">     1     2     0     1     2</span><br><span class=\"line\">% 只要总的可以组成矩阵，矩阵可以任意拼接。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"repmat\"><a href=\"#repmat\" class=\"headerlink\" title=\"repmat\"></a>repmat</h4><p>创建重复矩阵组成的拼接矩阵</p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = [1,0;0,-1]</span><br><span class=\"line\">B1 = repmat(A,2)% </span><br><span class=\"line\">B2 = repmat(A,2,3)  % </span><br><span class=\"line\">B3 = repmat(A,[2,3])% </span><br><span class=\"line\">% repmat(__,[m,n])和repmat(__,m,n)完全一致。</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A =</span><br><span class=\"line\">     1     0</span><br><span class=\"line\">     0    -1</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1</span><br><span class=\"line\">     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1</span><br><span class=\"line\">% 只传一个参数时，会在两个维度上都进行重复</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\"> % repmat(__,[m,n])和repmat(__,m,n)完全一致。</span><br><span class=\"line\"> % m为在列方向重复次数，n为在行方向重复次数。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h4><p>cat 函数是中括号的函数形式，唯一不同的地方是 cat 函数可以连接三维矩阵  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = [1, 2;3, 4]</span><br><span class=\"line\">B = [5, 6;7, 8]</span><br><span class=\"line\">C1 = cat(1,A,B)</span><br><span class=\"line\">C2 = cat(2,A,B)</span><br><span class=\"line\">C3 = cat(3,A,B)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">B =</span><br><span class=\"line\">     5     6</span><br><span class=\"line\">     7     8</span><br><span class=\"line\">C1 =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">     5     6</span><br><span class=\"line\">     7     8</span><br><span class=\"line\">% 维度一，列方向</span><br><span class=\"line\">C2 =</span><br><span class=\"line\">     1     2     5     6</span><br><span class=\"line\">     3     4     7     8</span><br><span class=\"line\">% 维度二，行方向</span><br><span class=\"line\">C3(:,:,1) =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">C3(:,:,2) =</span><br><span class=\"line\">     5     6</span><br><span class=\"line\">     7     8</span><br><span class=\"line\">% 维度三，竖方向这样做可以创建三维矩阵</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"repelem\"><a href=\"#repelem\" class=\"headerlink\" title=\"repelem\"></a>repelem</h4><p>复写矩阵里的元素</p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [ 1 2 3]</span><br><span class=\"line\">B1 = repelem(A1,2)</span><br><span class=\"line\">% 对于一维矩阵而言，repelem(__,m)相当于每个元素都重复 m 次。</span><br><span class=\"line\">B2 = repelem(A1,[2 3 4])</span><br><span class=\"line\">% 如果附加的参数是一个等长度的一维矩阵，那么会以对应的频数复写元素。</span><br><span class=\"line\"></span><br><span class=\"line\">A3 = [1 2; 3 4]</span><br><span class=\"line\">B3 = repelem(A3,2,3)</span><br><span class=\"line\">% 对于任意的矩阵而言都可以repelem(__,m,n),将每个元素以 m×n 复写</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     1     2     3</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     1     1     2     2     3     3</span><br><span class=\"line\">% 输入的第二个参数是 2，对应将 A1 的元素复写 2 次</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     1     1     2     2     2     3     3     3     3</span><br><span class=\"line\">% 输入的第二个参数是 [2 3 4]，对应将 A1 的元素复写 2，3，4 次</span><br><span class=\"line\">A3 =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">     1     1     1     2     2     2</span><br><span class=\"line\">     1     1     1     2     2     2</span><br><span class=\"line\">     3     3     3     4     4     4</span><br><span class=\"line\">     3     3     3     4     4     4</span><br><span class=\"line\">% 输入的第二个参数是 2，输入的第三个参数是3 </span><br><span class=\"line\">% 对应将 A3 的元素在列方向复写 2 次，行方向复写 3 次</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a><strong>索引</strong></h3><p>前面讲了那么多，终于可以讲最重要的索引部分。索引是什么？索引相当于编号，我们可以利用索引精确地找到我们想要的元素。无论是操作的输入还是输出，都要利用索引来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [9 8 7 6 5 4 3 2 1]</span><br><span class=\"line\">B1_1 = A1(1) % 与很多程序语言不一样的是，MATLAB 的索引从 1 开始，所以这一项返回第一个元素。</span><br><span class=\"line\">B1_2 = A1([1 3 5 2 1]) % 如果索引不止一个，以矩阵形式传入，可以一次性返回。</span><br><span class=\"line\">B1_3 = A1(1:2:7) % 冒号是使用索引的好助手</span><br><span class=\"line\">B1_4 = A1(2:6) % 冒号也可以这样使用</span><br><span class=\"line\">B1_5 = A1(:) % 只输入冒号相当于全部取出</span><br><span class=\"line\">B1_7 = A1(end) % 另一个强大的标记是 end，表示该列(或者行)的最后一个索引</span><br><span class=\"line\">B1_8 = A1(3:end) % （如果矩阵的长度会变，这会避免不少麻烦）。</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [4 5 6 7;5 7 9 0;  12 4 6 8; 0 -1 2  5]</span><br><span class=\"line\">B2_1 = A2(2,2) % 二维矩阵可以用对应坐标取出</span><br><span class=\"line\">B2_2 = A2(2,:) % 二维矩阵冒号相当于一行（或者一列）</span><br><span class=\"line\">B2_3 = A2(2:end,1:3) % 可以一次取出对应多行多列的元素组成新的矩阵。</span><br><span class=\"line\"></span><br><span class=\"line\">% 特别的我们刚刚提到了一点：所有的矩阵在计算机中都是储存在线性空间里</span><br><span class=\"line\">% 那么下面这两个例子就是最好的演示</span><br><span class=\"line\">A3 = [1 2 3 4;5 6 7 8]</span><br><span class=\"line\">B3_1 = A3(5)</span><br><span class=\"line\">B3_2 = A3(5:7)</span><br><span class=\"line\">B3_3 = A3(:)</span><br><span class=\"line\">B3_4 = A3(:,:)</span><br></pre></td></tr></table></figure>\n\n<p>将以上命令输入至命令行，将得到以下输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     9     8     7     6     5     4     3     2     1</span><br><span class=\"line\">B1_1 =</span><br><span class=\"line\">     9</span><br><span class=\"line\">% MATLAB 的索引从 1 开始！ MATLAB 的索引从1开始！ MATLAB的索引从1开始！</span><br><span class=\"line\">B1_2 =</span><br><span class=\"line\">     9     7     5     8     9</span><br><span class=\"line\">% 多个索引以矩阵形式输入即可，允许重复索引，顺序无关</span><br><span class=\"line\">B1_3 =</span><br><span class=\"line\">     9     7     5     3</span><br><span class=\"line\">B1_4 =</span><br><span class=\"line\">     8     7     6     5     4</span><br><span class=\"line\">% 冒号运算符可以线性关系的索引</span><br><span class=\"line\">B1_5 =</span><br><span class=\"line\">     9</span><br><span class=\"line\">     8</span><br><span class=\"line\">     7</span><br><span class=\"line\">     6</span><br><span class=\"line\">     5</span><br><span class=\"line\">     4</span><br><span class=\"line\">     3</span><br><span class=\"line\">     2</span><br><span class=\"line\">     1</span><br><span class=\"line\">% 只输入冒号运算符索引全部元素，但是这个时候变成了列向量（元素都是在内存中按列排放的）</span><br><span class=\"line\">B1_7 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">% end是矩阵最后一个元素的索引</span><br><span class=\"line\">B1_8 =</span><br><span class=\"line\">     7     6     5     4     3     2     1</span><br><span class=\"line\">% end和冒号运算符的结合运用可以快捷取出元素</span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     4     5     6     7</span><br><span class=\"line\">     5     7     9     0</span><br><span class=\"line\">    12     4     6     8</span><br><span class=\"line\">     0    -1     2     5</span><br><span class=\"line\">B2_1 =</span><br><span class=\"line\">     7</span><br><span class=\"line\">% 二维矩阵的元素可以用对应二维坐标取出</span><br><span class=\"line\">B2_2 =</span><br><span class=\"line\">     5     7     9     0</span><br><span class=\"line\">% 冒号作为矩阵行列索引，就是对应取出整行整列</span><br><span class=\"line\">B2_3 =</span><br><span class=\"line\">     5     7     9</span><br><span class=\"line\">    12     4     6</span><br><span class=\"line\">     0    -1     2</span><br><span class=\"line\">% 利用冒号运算符可以一次取出对应多行多列的元素组成新的矩阵。</span><br><span class=\"line\">A3 =</span><br><span class=\"line\">     1     2     3     4</span><br><span class=\"line\">     5     6     7     8</span><br><span class=\"line\">B3_1 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">% 所有的矩阵在计算机中都是储存在线性空间里</span><br><span class=\"line\">% 实际上 A3 的线性排列 [1 5 2 6 3 7 4 8]</span><br><span class=\"line\">% 矩阵的第五个元素就是对应元素3</span><br><span class=\"line\">B3_2 =</span><br><span class=\"line\">     3     7     4</span><br><span class=\"line\">% 这种索引方式也可以用矩阵输入索引</span><br><span class=\"line\">B3_3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     5</span><br><span class=\"line\">     2</span><br><span class=\"line\">     6</span><br><span class=\"line\">     3</span><br><span class=\"line\">     7</span><br><span class=\"line\">     4</span><br><span class=\"line\">     8</span><br><span class=\"line\">% 只输入冒号运算符索引全部元素，以列向量输出</span><br><span class=\"line\">B3_4 =</span><br><span class=\"line\">     1     2     3     4</span><br><span class=\"line\">     5     6     7     8</span><br><span class=\"line\">% A3(:,:)的形式可以取出整个二维矩阵，而不至于转成列向量</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"补充内容\"><a href=\"#补充内容\" class=\"headerlink\" title=\"补充内容\"></a><strong>补充内容</strong></h3><p>本次的内容有点多，重点内容需要巩固：</p>\n<ul>\n<li><p>size函数：目前来说最常见用于创建矩阵和确定循环结构的循环次数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 1.模仿大师——创建一个一样大小的矩阵</span><br><span class=\"line\">a = [1 2 3 5;3 4  6 7];</span><br><span class=\"line\">b = zeros(size(a)); % 这就创建了一个大小完全一致的全零矩阵</span><br><span class=\"line\">% 试想如果 a 是外部输入的长度不确定的变量，这种方法就很高效</span><br><span class=\"line\">%% 2.循环次数</span><br><span class=\"line\">x = -1 : 0.1 : 3;</span><br><span class=\"line\">y = x;</span><br><span class=\"line\">for index = 1:size(x,2)</span><br><span class=\"line\">    y(index) = (x(index)-1) * (x(index)-2) + index;</span><br><span class=\"line\">end</span><br><span class=\"line\">plot(x,y,&apos;r--&apos;,&apos;LineWidth&apos;,3); % 曲线绘图函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reshape函数：重新排列矩阵，快速处理数据的手段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = 1:15;</span><br><span class=\"line\">% 这样可以按列创建顺序的矩阵</span><br><span class=\"line\">B1 = reshape(A,3,5)</span><br><span class=\"line\">% 这样可以按行创建顺序的矩阵</span><br><span class=\"line\">B2 = reshape(A,5,3)&apos;</span><br><span class=\"line\">% 三维数组为未尝不可</span><br><span class=\"line\">B3 = reshape(A,5,1,3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sort函数：内置的sort函数比自己编写的排序更高效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = [ 8 9 2 4 0 10 3 6 7 1];</span><br><span class=\"line\">y = x.*x;</span><br><span class=\"line\">plot(x,y,&apos;r*-&apos;);</span><br><span class=\"line\">% 点还是那些点，但顺序不对会影响绘图质量</span><br><span class=\"line\">% 这时排序可以用上</span><br><span class=\"line\">[x1,index] = sort(x);</span><br><span class=\"line\">plot(x1,y(index),&apos;r*-&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>[ ]运算符：串联矩阵最重要的步骤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 绘制斐波那契数列的曲线</span><br><span class=\"line\">x = 1:15;</span><br><span class=\"line\">y = [1,1];</span><br><span class=\"line\">for index = 3:size(x,2)</span><br><span class=\"line\">    y = [y y(end)+ y(end-1)];</span><br><span class=\"line\">end</span><br><span class=\"line\">plot(x,y,&apos;ro-&apos;,&apos;LineWidth&apos;,3); % 曲线绘图函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>repmat函数：重复矩阵的拼接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 字符串也可以拼接</span><br><span class=\"line\">a = [&apos;hello&apos;]</span><br><span class=\"line\">b = repmat(a,3,2)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>索引：功能强大，针对性的选取数组元素</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 仍使用sort的案例</span><br><span class=\"line\">% 这里我并没有重新计算 y1 = x*x，是因为索引能直接找到对应的 y</span><br><span class=\"line\">x = [ 8 9 2 4 0 10 3 6 7 1];</span><br><span class=\"line\">y = x.*x;</span><br><span class=\"line\">plot(x,y,&apos;r*-&apos;);</span><br><span class=\"line\">% 点还是那些点，但顺序不对会影响绘图质量</span><br><span class=\"line\">% 这时排序可以用上</span><br><span class=\"line\">[x1,index] = sort(x);</span><br><span class=\"line\">plot(x1,y(index),&apos;r*-&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">%% 索引的具体应用更重要的是逻辑变量和 find 函数（篇幅有限，之后补充）。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a><strong>思考</strong></h3><p>每一行代码执行后，对应变量会有什么变化？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2:3:8;</span><br><span class=\"line\">b = [a&apos; a&apos; a&apos;];</span><br><span class=\"line\">c = b(1:2:3,1:2:3);</span><br><span class=\"line\">d = a + b(2,:);</span><br><span class=\"line\">w = [zero(1,3) ones(1,3)&apos; 3:5&apos;];</span><br><span class=\"line\">b([1,3],2) = b([3,1],2);</span><br><span class=\"line\">e = 1:-1:5;</span><br></pre></td></tr></table></figure>\n\n<p>解答：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a是一个 1×3 的矩阵 [\t2\t5\t8\t]</span><br><span class=\"line\">b是一个 3×3 的矩阵 [\t2\t2\t2;</span><br><span class=\"line\">\t\t\t\t\t\t5\t5\t5;</span><br><span class=\"line\">\t\t\t\t\t\t8\t8\t8\t]</span><br><span class=\"line\">c是一个 2×2 的矩阵[\t2\t2;</span><br><span class=\"line\">                    8\t8\t]</span><br><span class=\"line\">d是一个 1×3 的矩阵[\t7\t10\t13\t]</span><br><span class=\"line\">e是一个 1×9 的矩阵[\t0\t0\t0\t1\t1\t1\t3\t4\t5\t]</span><br><span class=\"line\">b([1\t3],2)=[\t8\t2\t]修改了原有 b 矩阵的值</span><br><span class=\"line\">实际上 b 发生改变 [\t2\t8\t2;</span><br><span class=\"line\">\t\t\t\t\t5\t5\t5;</span><br><span class=\"line\">                    8\t2\t8\t]</span><br><span class=\"line\">e 是一个空矩阵</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>本次的内容最大的重点是索引，结合逻辑矩阵能编写高效而简洁的代码。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>本次的内容有点多，划一下重点：</p>\n<ul>\n<li><p>size 函数：创建矩阵和确定循环结构的循环次数</p>\n</li>\n<li><p>reshape 函数：重新排列矩阵</p>\n</li>\n<li><p>sort 函数：内置的 sort 函数比自己编写的排序更高效</p>\n</li>\n<li><p>[] 中括号运算符：串联矩阵最重要的步骤</p>\n</li>\n<li><p>repmat 函数：重复矩阵的拼接</p>\n</li>\n<li><p>索引：功能强大，针对性的选取数组元素</p>","more":"</li>\n</ul>\n<h3 id=\"矩阵的属性\"><a href=\"#矩阵的属性\" class=\"headerlink\" title=\"矩阵的属性\"></a><strong>矩阵的属性</strong></h3><p>复习一下之前介绍过的 MATLAB 命令：（&gt;&gt; whos）。</p>\n<p>功能为显示所有变量的属性。有时候我们需要根据矩阵的属性来做一些操作就需要用到矩阵的一些相关属性。常用的属性都可以通过函数来调用：size，length，isrow，numel 等。</p>\n<h4 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size\"></a>size</h4><p>size 函数返回矩阵的各个维度的长度，调用方法为：sz = size(A)  </p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% size ()</span><br><span class=\"line\">% </span><br><span class=\"line\">A = zeros(3,4); % 先创建一个 3×4 的零矩阵，观察以下几个值</span><br><span class=\"line\">S = size(A)</span><br><span class=\"line\">[m,n] = size(A)</span><br><span class=\"line\">% 补充：这样写是能够让函数返回两个不同的输出参数。</span><br><span class=\"line\">% 调用函数时，系统会告诉函数有多少个输入参数和输出参数</span><br><span class=\"line\">% 函数本身则根据输入输出参数的数量决定自己的输出参数。</span><br><span class=\"line\">mm = size(A,1)</span><br><span class=\"line\">nn = size(A,2)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S =</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">% 直接调用返回一个输出参数时：</span><br><span class=\"line\">% size 函数返回一个矩阵包含各个维度长度的矩阵。</span><br><span class=\"line\">m =</span><br><span class=\"line\"></span><br><span class=\"line\">     3</span><br><span class=\"line\">n =</span><br><span class=\"line\"></span><br><span class=\"line\">     4</span><br><span class=\"line\">% 直接调用返回两个输出参数时：</span><br><span class=\"line\">% size函数返回两个标量各自表示各个维度长度。</span><br><span class=\"line\"></span><br><span class=\"line\">mm =</span><br><span class=\"line\">     3</span><br><span class=\"line\">nn =</span><br><span class=\"line\">     4</span><br><span class=\"line\">% 调用size函数时，加上想查询的具体维度，可以返回该维度上的长度</span><br><span class=\"line\">% 在这里，1 指横坐标，2 指纵坐标，3 指竖坐标</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length\"></a>length</h4><p>length函数返回矩阵的最长维度的长度，调用方法为：L = length(A)  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% length ()</span><br><span class=\"line\">A = zeros(3,4); % 先创建一个 3×4 的零矩阵</span><br><span class=\"line\">S = length(A)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S =</span><br><span class=\"line\">        4</span><br><span class=\"line\">% length 函数返回矩阵的最长维度的长度，相当于 size(A)的最大值。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"isrow\"><a href=\"#isrow\" class=\"headerlink\" title=\"isrow\"></a>isrow</h4><p>isrow如其名，作用就是询问矩阵是不是行向量。<br>同样作用的还有 iscolumn 确定矩阵是不是列向量，isempty 确定矩阵是不是为空</p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% isrow ()</span><br><span class=\"line\">A = zeros(1,4); % 创建一个 1×4 的矩阵，观察以下几个值</span><br><span class=\"line\">S1 = isrow(A)</span><br><span class=\"line\">S2 = iscolumn(A)</span><br><span class=\"line\">S3 = isempty(A)</span><br><span class=\"line\">whos S1</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S1 =</span><br><span class=\"line\">     1</span><br><span class=\"line\"></span><br><span class=\"line\">S2 =</span><br><span class=\"line\">     0</span><br><span class=\"line\"></span><br><span class=\"line\">S3 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">  Name      Size            Bytes  Class      Attributes</span><br><span class=\"line\">  S1        1x1                 1  logical  </span><br><span class=\"line\">% isrow 函数返回一个布尔值 1 或 0</span><br><span class=\"line\">% 用 whos 命令可以看到返回的类型是 logical（逻辑值非一即零，非真即假）。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"numel\"><a href=\"#numel\" class=\"headerlink\" title=\"numel\"></a>numel</h4><p>numel 函数返回数组元素的数量。  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = zeros(3,4); % 创建一个 1×4 的矩阵，观察以下几个值</span><br><span class=\"line\">n = numel(A)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n =</span><br><span class=\"line\">    12 </span><br><span class=\"line\">% 返回矩阵所有元素的个数</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"矩阵的排列\"><a href=\"#矩阵的排列\" class=\"headerlink\" title=\"矩阵的排列\"></a><strong>矩阵的排列</strong></h3><p>矩阵的另一类操作是排列，对矩阵内的元素的相对位置重新处理，（很抽象的描述，还是看看函数的功能比较容易）。常见的的函数有 reshape，sort，flip，circshift 等</p>\n<h4 id=\"reshape\"><a href=\"#reshape\" class=\"headerlink\" title=\"reshape\"></a>reshape</h4><p>reshape 函数顾名思义就是对矩阵重排。  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = magic(4) % 创建一个 4×4 的矩阵，观察以下几个值</span><br><span class=\"line\">AA = reshape(A,2,8)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% reshape 之前</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">    16     2     3    13</span><br><span class=\"line\">     5    11    10     8</span><br><span class=\"line\">     9     7     6    12</span><br><span class=\"line\">     4    14    15     1</span><br><span class=\"line\"></span><br><span class=\"line\">% reshape 之后</span><br><span class=\"line\">AA =</span><br><span class=\"line\"></span><br><span class=\"line\">    16     9     2     7     3     6    13    12</span><br><span class=\"line\">     5     4    11    14    10    15     8     1</span><br><span class=\"line\">     </span><br><span class=\"line\">% 这里又有另一个关注的点：重排的顺序，可以看到A的每一列分成了两列</span><br><span class=\"line\">% 原理：所有的矩阵在计算机中都是储存在线性空间里，实际上的顺序就是一列一列的拼接：</span><br><span class=\"line\">% 16 5 9 4 2 11 7 14 3 10 6 15 13 8 12 1</span><br><span class=\"line\">% 重排的时候仍然依照这个顺序取出。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>对矩阵进行排序，默认升序（从小到大）  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [ 23 5 -1 4  7 0]</span><br><span class=\"line\">B1 = sort(A1)</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [7 8 9; 2 4 -2; 10 2 4]</span><br><span class=\"line\">B2 = sort(A2,2) % 另一个输入参数为排序的维度</span><br><span class=\"line\">% 1 指横坐标，2 指纵坐标，3 指竖坐标的规则仍适用</span><br><span class=\"line\">B2 = sort(A2) % 若不输入另一个参数，则默认另一个参数是 1，按列排序</span><br><span class=\"line\"></span><br><span class=\"line\">A3 = [ 23 5 -1 4  7 0]</span><br><span class=\"line\">B3 = sort(A3,&apos;descend&apos;) </span><br><span class=\"line\">% 默认情况下，sort 为升序（&apos;ascend&apos;），使用降序时，可以使用输入参数&apos;descend&apos;来使用降序方法</span><br><span class=\"line\"></span><br><span class=\"line\">A4 = [ 23 5 -1 4  7 0]</span><br><span class=\"line\">[B,I] = sort(A4)</span><br><span class=\"line\">A(I)</span><br><span class=\"line\">% sort 返回两个输出参数时，</span><br><span class=\"line\">% 第一个变量返回排序后的数组，</span><br><span class=\"line\">% 第二个变量返回排序后的数组对应原有的数组索引 A(I)和 B 是一样的。</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">    23     5    -1     4     7     0</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">    -1     0     4     5     7    23</span><br><span class=\"line\">% sort 排序一维矩阵时，返回排序后的一维矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     7     8     9</span><br><span class=\"line\">     2     4    -2</span><br><span class=\"line\">    10     2     4</span><br><span class=\"line\"></span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     7     8     9</span><br><span class=\"line\">    -2     2     4</span><br><span class=\"line\">     2     4    10</span><br><span class=\"line\">% 另一个输入参数为 2，也就是按纵坐标排序</span><br><span class=\"line\"></span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     2     2    -2</span><br><span class=\"line\">     7     4     4</span><br><span class=\"line\">    10     8     9</span><br><span class=\"line\">% 若不输入另一个参数，则默认另一个参数是 1，按列排序</span><br><span class=\"line\">    </span><br><span class=\"line\">A3 =</span><br><span class=\"line\">    23     5    -1     4     7     0</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">    23     7     5     4     0    -1</span><br><span class=\"line\">% 可以sort(A3,&apos;descend&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">A4 =</span><br><span class=\"line\">    23     5    -1     4     7     0</span><br><span class=\"line\">B =</span><br><span class=\"line\">    -1     0     4     5     7    23</span><br><span class=\"line\">I =</span><br><span class=\"line\">     3     6     4     2     5     1</span><br><span class=\"line\">ans =</span><br><span class=\"line\">    -1     0     4     5     7    23</span><br><span class=\"line\">% B为排序后的矩阵，I 是一个索引（稍后会介绍索引：表示对应的关系）</span><br><span class=\"line\">% 可以看到 B 和 A(I) 是完全一致的。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flip\"><a href=\"#flip\" class=\"headerlink\" title=\"flip\"></a>flip</h4><p>flip 就是反转矩阵的元素  </p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [3 7 6 -1 0]</span><br><span class=\"line\">B1 = flip(A1)</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [ 2 5 7;-5 3 5;0 6 5]</span><br><span class=\"line\">B2 = flip(A2)</span><br><span class=\"line\"></span><br><span class=\"line\">A3 = [ 2 5 7;-5 3 5;0 6 5]</span><br><span class=\"line\">B3 = flip(A3,2)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     3     7     6    -1     0</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     0    -1     6     7     3</span><br><span class=\"line\">% flip 函数用于快速反转一个矩阵</span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     2     5     7</span><br><span class=\"line\">    -5     3     5</span><br><span class=\"line\">     0     6     5</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     0     6     5</span><br><span class=\"line\">    -5     3     5</span><br><span class=\"line\">     2     5     7</span><br><span class=\"line\">二维矩阵的反转默认按列反转</span><br><span class=\"line\">A3 =</span><br><span class=\"line\">     2     5     7</span><br><span class=\"line\">    -5     3     5</span><br><span class=\"line\">     0     6     5</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">     7     5     2</span><br><span class=\"line\">     5     3    -5</span><br><span class=\"line\">     5     6     0</span><br><span class=\"line\">二维矩阵的反转也可以用 flip(__,2)指定按行反转</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"circshift\"><a href=\"#circshift\" class=\"headerlink\" title=\"circshift\"></a>circshift</h4><p>循环移位：所有元素向后移位，超出的部分自动补回到最前面  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [3 7 6 -1 0 2 8 0 ]</span><br><span class=\"line\">B1 = circshift(A1,[0,3])</span><br><span class=\"line\">% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [ 1 0 0;0 0 0;0 0 0]</span><br><span class=\"line\">B2 = circshift(A2,[1,2])</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     3     7     6    -1     0     2     8     0</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     2     8     0     3     7     6    -1     0</span><br><span class=\"line\">% circshift(__,[m,n])表示，矩阵向下循环移动 m 位，矩阵向右循环移动 n 位</span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     1     0     0</span><br><span class=\"line\">     0     0     0</span><br><span class=\"line\">     0     0     0</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     0     0     0</span><br><span class=\"line\">     0     0     1</span><br><span class=\"line\">     0     0     0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接矩阵\"><a href=\"#拼接矩阵\" class=\"headerlink\" title=\"拼接矩阵\"></a><strong>拼接矩阵</strong></h3><p>拼接矩阵是另一类创建矩阵的特殊手段，需要对矩阵元素直接的关系有足够的理解。我们先介绍（[]），再介绍类似于 repmat，cat，repelem 的函数用法。</p>\n<h4 id=\"符号\"><a href=\"#符号\" class=\"headerlink\" title=\"[] 符号\"></a>[] 符号</h4><p>我们将左右中括号用于创建矩阵，我们其实就是将若干个数用中括号实现了元素和矩阵的拼接。</p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [1,2]</span><br><span class=\"line\">b = [3,4] % 用来拼接</span><br><span class=\"line\">c = [a,0,b] </span><br><span class=\"line\">d = [a;b]</span><br><span class=\"line\">e = [a,a;a,b]</span><br><span class=\"line\">% f = [a,a,a;b,b] % 这样做矩阵不匹配</span><br><span class=\"line\">g = [c;a,0,1,2]</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">b =</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">c =</span><br><span class=\"line\">     1     2     0     3     4</span><br><span class=\"line\">% 矩阵和数字可以混合拼接</span><br><span class=\"line\">d =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">% 分号换行就是在列方向上拼接</span><br><span class=\"line\">e =</span><br><span class=\"line\">     1     2     1     2</span><br><span class=\"line\">     1     2     3     4</span><br><span class=\"line\">% 二维矩阵也可以拼接</span><br><span class=\"line\">g =</span><br><span class=\"line\">     1     2     0     3     4</span><br><span class=\"line\">     1     2     0     1     2</span><br><span class=\"line\">% 只要总的可以组成矩阵，矩阵可以任意拼接。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"repmat\"><a href=\"#repmat\" class=\"headerlink\" title=\"repmat\"></a>repmat</h4><p>创建重复矩阵组成的拼接矩阵</p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = [1,0;0,-1]</span><br><span class=\"line\">B1 = repmat(A,2)% </span><br><span class=\"line\">B2 = repmat(A,2,3)  % </span><br><span class=\"line\">B3 = repmat(A,[2,3])% </span><br><span class=\"line\">% repmat(__,[m,n])和repmat(__,m,n)完全一致。</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A =</span><br><span class=\"line\">     1     0</span><br><span class=\"line\">     0    -1</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1</span><br><span class=\"line\">     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1</span><br><span class=\"line\">% 只传一个参数时，会在两个维度上都进行重复</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\">     1     0     1     0     1     0</span><br><span class=\"line\">     0    -1     0    -1     0    -1</span><br><span class=\"line\"> % repmat(__,[m,n])和repmat(__,m,n)完全一致。</span><br><span class=\"line\"> % m为在列方向重复次数，n为在行方向重复次数。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h4><p>cat 函数是中括号的函数形式，唯一不同的地方是 cat 函数可以连接三维矩阵  </p>\n<p>命令行输入 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = [1, 2;3, 4]</span><br><span class=\"line\">B = [5, 6;7, 8]</span><br><span class=\"line\">C1 = cat(1,A,B)</span><br><span class=\"line\">C2 = cat(2,A,B)</span><br><span class=\"line\">C3 = cat(3,A,B)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">B =</span><br><span class=\"line\">     5     6</span><br><span class=\"line\">     7     8</span><br><span class=\"line\">C1 =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">     5     6</span><br><span class=\"line\">     7     8</span><br><span class=\"line\">% 维度一，列方向</span><br><span class=\"line\">C2 =</span><br><span class=\"line\">     1     2     5     6</span><br><span class=\"line\">     3     4     7     8</span><br><span class=\"line\">% 维度二，行方向</span><br><span class=\"line\">C3(:,:,1) =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">C3(:,:,2) =</span><br><span class=\"line\">     5     6</span><br><span class=\"line\">     7     8</span><br><span class=\"line\">% 维度三，竖方向这样做可以创建三维矩阵</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"repelem\"><a href=\"#repelem\" class=\"headerlink\" title=\"repelem\"></a>repelem</h4><p>复写矩阵里的元素</p>\n<p>命令行输入  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [ 1 2 3]</span><br><span class=\"line\">B1 = repelem(A1,2)</span><br><span class=\"line\">% 对于一维矩阵而言，repelem(__,m)相当于每个元素都重复 m 次。</span><br><span class=\"line\">B2 = repelem(A1,[2 3 4])</span><br><span class=\"line\">% 如果附加的参数是一个等长度的一维矩阵，那么会以对应的频数复写元素。</span><br><span class=\"line\"></span><br><span class=\"line\">A3 = [1 2; 3 4]</span><br><span class=\"line\">B3 = repelem(A3,2,3)</span><br><span class=\"line\">% 对于任意的矩阵而言都可以repelem(__,m,n),将每个元素以 m×n 复写</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     1     2     3</span><br><span class=\"line\">B1 =</span><br><span class=\"line\">     1     1     2     2     3     3</span><br><span class=\"line\">% 输入的第二个参数是 2，对应将 A1 的元素复写 2 次</span><br><span class=\"line\">B2 =</span><br><span class=\"line\">     1     1     2     2     2     3     3     3     3</span><br><span class=\"line\">% 输入的第二个参数是 [2 3 4]，对应将 A1 的元素复写 2，3，4 次</span><br><span class=\"line\">A3 =</span><br><span class=\"line\">     1     2</span><br><span class=\"line\">     3     4</span><br><span class=\"line\">B3 =</span><br><span class=\"line\">     1     1     1     2     2     2</span><br><span class=\"line\">     1     1     1     2     2     2</span><br><span class=\"line\">     3     3     3     4     4     4</span><br><span class=\"line\">     3     3     3     4     4     4</span><br><span class=\"line\">% 输入的第二个参数是 2，输入的第三个参数是3 </span><br><span class=\"line\">% 对应将 A3 的元素在列方向复写 2 次，行方向复写 3 次</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a><strong>索引</strong></h3><p>前面讲了那么多，终于可以讲最重要的索引部分。索引是什么？索引相当于编号，我们可以利用索引精确地找到我们想要的元素。无论是操作的输入还是输出，都要利用索引来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 = [9 8 7 6 5 4 3 2 1]</span><br><span class=\"line\">B1_1 = A1(1) % 与很多程序语言不一样的是，MATLAB 的索引从 1 开始，所以这一项返回第一个元素。</span><br><span class=\"line\">B1_2 = A1([1 3 5 2 1]) % 如果索引不止一个，以矩阵形式传入，可以一次性返回。</span><br><span class=\"line\">B1_3 = A1(1:2:7) % 冒号是使用索引的好助手</span><br><span class=\"line\">B1_4 = A1(2:6) % 冒号也可以这样使用</span><br><span class=\"line\">B1_5 = A1(:) % 只输入冒号相当于全部取出</span><br><span class=\"line\">B1_7 = A1(end) % 另一个强大的标记是 end，表示该列(或者行)的最后一个索引</span><br><span class=\"line\">B1_8 = A1(3:end) % （如果矩阵的长度会变，这会避免不少麻烦）。</span><br><span class=\"line\"></span><br><span class=\"line\">A2 = [4 5 6 7;5 7 9 0;  12 4 6 8; 0 -1 2  5]</span><br><span class=\"line\">B2_1 = A2(2,2) % 二维矩阵可以用对应坐标取出</span><br><span class=\"line\">B2_2 = A2(2,:) % 二维矩阵冒号相当于一行（或者一列）</span><br><span class=\"line\">B2_3 = A2(2:end,1:3) % 可以一次取出对应多行多列的元素组成新的矩阵。</span><br><span class=\"line\"></span><br><span class=\"line\">% 特别的我们刚刚提到了一点：所有的矩阵在计算机中都是储存在线性空间里</span><br><span class=\"line\">% 那么下面这两个例子就是最好的演示</span><br><span class=\"line\">A3 = [1 2 3 4;5 6 7 8]</span><br><span class=\"line\">B3_1 = A3(5)</span><br><span class=\"line\">B3_2 = A3(5:7)</span><br><span class=\"line\">B3_3 = A3(:)</span><br><span class=\"line\">B3_4 = A3(:,:)</span><br></pre></td></tr></table></figure>\n\n<p>将以上命令输入至命令行，将得到以下输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A1 =</span><br><span class=\"line\">     9     8     7     6     5     4     3     2     1</span><br><span class=\"line\">B1_1 =</span><br><span class=\"line\">     9</span><br><span class=\"line\">% MATLAB 的索引从 1 开始！ MATLAB 的索引从1开始！ MATLAB的索引从1开始！</span><br><span class=\"line\">B1_2 =</span><br><span class=\"line\">     9     7     5     8     9</span><br><span class=\"line\">% 多个索引以矩阵形式输入即可，允许重复索引，顺序无关</span><br><span class=\"line\">B1_3 =</span><br><span class=\"line\">     9     7     5     3</span><br><span class=\"line\">B1_4 =</span><br><span class=\"line\">     8     7     6     5     4</span><br><span class=\"line\">% 冒号运算符可以线性关系的索引</span><br><span class=\"line\">B1_5 =</span><br><span class=\"line\">     9</span><br><span class=\"line\">     8</span><br><span class=\"line\">     7</span><br><span class=\"line\">     6</span><br><span class=\"line\">     5</span><br><span class=\"line\">     4</span><br><span class=\"line\">     3</span><br><span class=\"line\">     2</span><br><span class=\"line\">     1</span><br><span class=\"line\">% 只输入冒号运算符索引全部元素，但是这个时候变成了列向量（元素都是在内存中按列排放的）</span><br><span class=\"line\">B1_7 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">% end是矩阵最后一个元素的索引</span><br><span class=\"line\">B1_8 =</span><br><span class=\"line\">     7     6     5     4     3     2     1</span><br><span class=\"line\">% end和冒号运算符的结合运用可以快捷取出元素</span><br><span class=\"line\">A2 =</span><br><span class=\"line\">     4     5     6     7</span><br><span class=\"line\">     5     7     9     0</span><br><span class=\"line\">    12     4     6     8</span><br><span class=\"line\">     0    -1     2     5</span><br><span class=\"line\">B2_1 =</span><br><span class=\"line\">     7</span><br><span class=\"line\">% 二维矩阵的元素可以用对应二维坐标取出</span><br><span class=\"line\">B2_2 =</span><br><span class=\"line\">     5     7     9     0</span><br><span class=\"line\">% 冒号作为矩阵行列索引，就是对应取出整行整列</span><br><span class=\"line\">B2_3 =</span><br><span class=\"line\">     5     7     9</span><br><span class=\"line\">    12     4     6</span><br><span class=\"line\">     0    -1     2</span><br><span class=\"line\">% 利用冒号运算符可以一次取出对应多行多列的元素组成新的矩阵。</span><br><span class=\"line\">A3 =</span><br><span class=\"line\">     1     2     3     4</span><br><span class=\"line\">     5     6     7     8</span><br><span class=\"line\">B3_1 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">% 所有的矩阵在计算机中都是储存在线性空间里</span><br><span class=\"line\">% 实际上 A3 的线性排列 [1 5 2 6 3 7 4 8]</span><br><span class=\"line\">% 矩阵的第五个元素就是对应元素3</span><br><span class=\"line\">B3_2 =</span><br><span class=\"line\">     3     7     4</span><br><span class=\"line\">% 这种索引方式也可以用矩阵输入索引</span><br><span class=\"line\">B3_3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     5</span><br><span class=\"line\">     2</span><br><span class=\"line\">     6</span><br><span class=\"line\">     3</span><br><span class=\"line\">     7</span><br><span class=\"line\">     4</span><br><span class=\"line\">     8</span><br><span class=\"line\">% 只输入冒号运算符索引全部元素，以列向量输出</span><br><span class=\"line\">B3_4 =</span><br><span class=\"line\">     1     2     3     4</span><br><span class=\"line\">     5     6     7     8</span><br><span class=\"line\">% A3(:,:)的形式可以取出整个二维矩阵，而不至于转成列向量</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"补充内容\"><a href=\"#补充内容\" class=\"headerlink\" title=\"补充内容\"></a><strong>补充内容</strong></h3><p>本次的内容有点多，重点内容需要巩固：</p>\n<ul>\n<li><p>size函数：目前来说最常见用于创建矩阵和确定循环结构的循环次数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 1.模仿大师——创建一个一样大小的矩阵</span><br><span class=\"line\">a = [1 2 3 5;3 4  6 7];</span><br><span class=\"line\">b = zeros(size(a)); % 这就创建了一个大小完全一致的全零矩阵</span><br><span class=\"line\">% 试想如果 a 是外部输入的长度不确定的变量，这种方法就很高效</span><br><span class=\"line\">%% 2.循环次数</span><br><span class=\"line\">x = -1 : 0.1 : 3;</span><br><span class=\"line\">y = x;</span><br><span class=\"line\">for index = 1:size(x,2)</span><br><span class=\"line\">    y(index) = (x(index)-1) * (x(index)-2) + index;</span><br><span class=\"line\">end</span><br><span class=\"line\">plot(x,y,&apos;r--&apos;,&apos;LineWidth&apos;,3); % 曲线绘图函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reshape函数：重新排列矩阵，快速处理数据的手段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = 1:15;</span><br><span class=\"line\">% 这样可以按列创建顺序的矩阵</span><br><span class=\"line\">B1 = reshape(A,3,5)</span><br><span class=\"line\">% 这样可以按行创建顺序的矩阵</span><br><span class=\"line\">B2 = reshape(A,5,3)&apos;</span><br><span class=\"line\">% 三维数组为未尝不可</span><br><span class=\"line\">B3 = reshape(A,5,1,3)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>sort函数：内置的sort函数比自己编写的排序更高效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = [ 8 9 2 4 0 10 3 6 7 1];</span><br><span class=\"line\">y = x.*x;</span><br><span class=\"line\">plot(x,y,&apos;r*-&apos;);</span><br><span class=\"line\">% 点还是那些点，但顺序不对会影响绘图质量</span><br><span class=\"line\">% 这时排序可以用上</span><br><span class=\"line\">[x1,index] = sort(x);</span><br><span class=\"line\">plot(x1,y(index),&apos;r*-&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>[ ]运算符：串联矩阵最重要的步骤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 绘制斐波那契数列的曲线</span><br><span class=\"line\">x = 1:15;</span><br><span class=\"line\">y = [1,1];</span><br><span class=\"line\">for index = 3:size(x,2)</span><br><span class=\"line\">    y = [y y(end)+ y(end-1)];</span><br><span class=\"line\">end</span><br><span class=\"line\">plot(x,y,&apos;ro-&apos;,&apos;LineWidth&apos;,3); % 曲线绘图函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>repmat函数：重复矩阵的拼接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 字符串也可以拼接</span><br><span class=\"line\">a = [&apos;hello&apos;]</span><br><span class=\"line\">b = repmat(a,3,2)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>索引：功能强大，针对性的选取数组元素</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 仍使用sort的案例</span><br><span class=\"line\">% 这里我并没有重新计算 y1 = x*x，是因为索引能直接找到对应的 y</span><br><span class=\"line\">x = [ 8 9 2 4 0 10 3 6 7 1];</span><br><span class=\"line\">y = x.*x;</span><br><span class=\"line\">plot(x,y,&apos;r*-&apos;);</span><br><span class=\"line\">% 点还是那些点，但顺序不对会影响绘图质量</span><br><span class=\"line\">% 这时排序可以用上</span><br><span class=\"line\">[x1,index] = sort(x);</span><br><span class=\"line\">plot(x1,y(index),&apos;r*-&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">%% 索引的具体应用更重要的是逻辑变量和 find 函数（篇幅有限，之后补充）。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a><strong>思考</strong></h3><p>每一行代码执行后，对应变量会有什么变化？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2:3:8;</span><br><span class=\"line\">b = [a&apos; a&apos; a&apos;];</span><br><span class=\"line\">c = b(1:2:3,1:2:3);</span><br><span class=\"line\">d = a + b(2,:);</span><br><span class=\"line\">w = [zero(1,3) ones(1,3)&apos; 3:5&apos;];</span><br><span class=\"line\">b([1,3],2) = b([3,1],2);</span><br><span class=\"line\">e = 1:-1:5;</span><br></pre></td></tr></table></figure>\n\n<p>解答：   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a是一个 1×3 的矩阵 [\t2\t5\t8\t]</span><br><span class=\"line\">b是一个 3×3 的矩阵 [\t2\t2\t2;</span><br><span class=\"line\">\t\t\t\t\t\t5\t5\t5;</span><br><span class=\"line\">\t\t\t\t\t\t8\t8\t8\t]</span><br><span class=\"line\">c是一个 2×2 的矩阵[\t2\t2;</span><br><span class=\"line\">                    8\t8\t]</span><br><span class=\"line\">d是一个 1×3 的矩阵[\t7\t10\t13\t]</span><br><span class=\"line\">e是一个 1×9 的矩阵[\t0\t0\t0\t1\t1\t1\t3\t4\t5\t]</span><br><span class=\"line\">b([1\t3],2)=[\t8\t2\t]修改了原有 b 矩阵的值</span><br><span class=\"line\">实际上 b 发生改变 [\t2\t8\t2;</span><br><span class=\"line\">\t\t\t\t\t5\t5\t5;</span><br><span class=\"line\">                    8\t2\t8\t]</span><br><span class=\"line\">e 是一个空矩阵</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>本次的内容最大的重点是索引，结合逻辑矩阵能编写高效而简洁的代码。</p>"},{"title":"HTTP学习笔记","date":"2018-05-04T03:40:19.000Z","_content":"\n### Web 页面的实现\n\n\n\n##### Web 基于 HTTP 协议通信\n\n> 客户端（Client）的 Web 浏览器从 Web 服务器端获取文件资源等信息 。\n\n\n\n<!--more-->\n\n\n\n1. 浏览器的地址栏输入 URL\n2. URL 信息送往某处\n3. 从某处得到回复\n4. 将回复内容显示在 Web 页面上\n\nWeb 建立在 **HTTP 协议**（HyperText Transfer Protocol，超文本传输协议）实现通信。\n\n目前主流的 HTTP 版本：HTTP/1.1\n\n##### TCP/IP 网络层\n\n网络分层：\n\n- 设计各层之间接口，若需要改变设计只需改动有变动的层\n- 简化设计，只需完成该层的任务\n\n位于应用层的 HTTP 数据每经过一层就会打上属于该层的首部信息，这一过程称为**封装**。\n\n1. **IP** （Internet Protocol）网际协议位于网络层，任务是传输数据包。\n\n   IP 协议中有两种地址：IP 地址和 MAC 地址（Media Access Control Address）\n\n- IP 地址：网络中分配到的地址，全网唯一；（IP 地址分段，就像邮编决定数据流动的方向）\n\n\n- MAC 地址：每个网卡固定有一个 MAC 地址，无法改变。（ARP 协议用于解析 IP 地址，得到 MAC 地址）\n\n2. **TCP** 位于传输层：提供通过可靠的字节流服务。\n\n   TCP 的可靠传输：三次握手策略（SYN 和 ACK）\n\n- 发送端发送 SYN  标志的数据包；\n\n\n- 接收端回传 SYN/ACK 标志的数据包传达确认信息；\n- 发送端再回传一个 ACK 标志的数据包；\n\n##### DNS 服务\n\n**DNS** （Domain Name System）服务是位于应用层，可以提供域名解析服务。\n\n在网络中，每个主机都有唯一的 IP 地址，在互联网中我们却不太可能全部使用一串数字来记住网站，我们使用的是**域名**。\n\n- 计算机网络使用 IP 地址来实现网络中数据的传输。\n- 用户使用域名来访问网站。\n- 用户通过访问 DNS 服务器询问域名的 IP 地址，取得 IP 地址后，就可以通过 IP 地址访问。\n\n##### URL 和 URI\n\n- URL（Uniform Resource Locator，统一资源定位符）访问网页时需要输入的网页地址，表示资源的地点。\n- URI（Uniform Resource Identifier，统一资源标识符）用字符串标识某一互联网资源。\n\n```\nhttp://user:pass@www.example.jp:80/dir/index/htm?uid=1#ch1\n```\n\nURI 格式依次由：协议方案、登陆信息、服务器地址、服务器端口号、带层次的文件路径、查询字符串和片段标识符构成。\n\n### HTTP 协议\n\n##### 客户端和服务器\n\nHTTP 协议中，必然是一方为客户端，一方为服务器。\n\n- 客户端：请求访问文本或图像等资源的一端；\n- 服务器端：提供资源响应的一端；\n\n> 通信的双方是不对等的，因此在通信过程中，通常上行速度比下载速度慢很多。\n\n##### 请求和响应\n\n客户端和服务器端通过请求和响应的交换达成通信。\n\n- 客户端先发送请求；\n- 服务器再发送响应；\n- 服务器本身无法在没有请求时发送响应\n\n1. 客户端发送请求\n\n```http\nGET /index.htm HTTP/1.1\nHost: hackr.jp\n```\n\n- 起始行的 GET 表示请求访问的方法（method）；\n- 字符串 /index.htm 指明了请求访问的资源对象，就是请求 URI（request-URI）；\n- HTTP/1.1 为客户端 HTTP 版本号；\n- 也就是说，向主机名为 hackr.jp 的服务器请求 /index.hem 页面资源。\n- 总的来说，请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成。\n\n2. 服务器发送响应\n\n```http\nHTTP/1.1 200 OK\nDate: Tue, 10 Jul 2012 06:50:15 GMT\nContent-Length: 362\nContent-Type: text/html\n\n<html>\n...\n```\n\n- HTTP/1.1 为服务器对应的 HTTP 版本。\n- 200 OK 为请求的处理结果的状态码（status code）和原因短语（reason-phrase）\n- 之后的为首部字段（header field）\n- 空一行之后为资源的主体（entity body）\n- 响应报文由协议版本、状态码、原因短语、首部字段和实体主题\n\n\n##### Cookie 解决状态问题\n\nHTTP 协议自身不对请求和响应之间的通信状态进行保存。这样一来，服务器只需要专一化的处理响应 HTTP 请求即可，减少了服务器 CPU 和内存的消耗。\n\n当然 Web 网络中状态管理还是很重要的，如果网站每次都要重新登录和重新认证，结果是很糟糕的。Cookie 技术会在请求和响应报文中加入 Cookie 信息来控制客户端的状态。\n\n1. 没有 Cookie 时发出请求\n\n- 客户端向服务器发出请求\n- 服务器通过生成 Cookie 信息（这一时刻记住了客户端信息）\n- 在响应中添加 Set-Cookie 的首部字段信息。\n- 服务器回复响应\n- 客户端收到后就把 Cookie 保存起来。\n\n2. 有 Cookie 状态信息时发出请求\n\n- 客户端主动在请求报文中添加 Cookie 信息\n- 客户端向服务器发出请求\n- 服务器检查 Cookie 信息\n- 服务器回复响应\n\n#####  请求 URI 定位网络资源\n\nHTTP 协议使用 URI 定位互联网上的资源，客户端访问请求资源发送请求时，需要在请求报文中添加 URI 。\n\n1. 使用完整的请求 URI\n\n```http\nGET /index.htm HTTP/1.1\n```\n\n2. 使用 Host 首部字段写明网络域名或 IP 地址\n\n```http\nGET /index.htm HTTP/1.1\n```\n\n3. 使用 * 来代替 URI 只访问服务器\n\n```http\nOPTIONS * HTTP/1.1\n```\n\n#####  HTTP 方法告知服务器意图\n\n- GET ：获取资源\n\n```http\nGET /index.html HTTP/1.1\nHost: www.hackr.jp\n```\n\n返回 index.html 的页面资源。\n\n- POST ：传输实体主体\n\n```http\nPOST /submit.cgi HTTP/1.1\nHost: www.hackr.jp\nContent-length: 1560\n```\n\n返回 submit.cgi 接收数据的处理结果\n\n- PUT ：传输文件\n\n```http\nPUT /example.html HTTP/1.1\nHost: www.hackr.jp\nContent-Type: text/html\nContent-Length: 1560\n```\n\n向服务器上传文件，存在安全性问题，一般不使用，需要 Web 验证机制。\n\n- HEAD ：获得报文首部\n\n```http\nHEAD /index.html HTTP/1.1\nHost: www.hackr.jp\n```\n\n告知服务器无需返回报文主体部分，确认 URI 的有效性及资源更新日期时间。\n\n- DELETE ：删除文件\n\n```http\nDELETE /example.html HTTP/1.1\nHost: www.hackr.jp\n```\n\n删除服务器上的资源，存在安全性问题，一般不使用，需要 Web 验证机制。\n\n- OPTIONS ：询问支持的方法\n\n  ```http\n  OPTIONS * HTTP/1.1\n  Host: www.hackr.jp\n  ```\n\n针对服务器查询针对请求 URI 指定的资源支持的方法。\n\n- TRACE ：追踪路径\n\n  ```http\n  TRACE / HTTP/1.1\n  Host: hackr.jp\n  Max-Forward: 2\n  ```\n\n让 Web 服务器端将之前的请求通信环回给客户端，不常使用，可能引起跨站追踪（Cross-Site Tracing）。\n\n添加 Max-Forward 首部字段的数值，每经过服务器数值减一，数值为 0 的服务器返回状态码 200 OK 的响应。\n\n- CONNECT ：要求用隧道协议连接代理\n\n  ```http\n  CONNECT proxy.hackr.jp:8080 HTTP/1.1\n  Host: proxy.hackr.jp\n  ```\n\n要求与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。\n\n主要使用 SSL（Secure Sockets Layer，安全套接层）和 TSL（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输。\n\n#####  HTTP 方法指挥服务器\n\n使用方法作为命令来向服务器下达命令，可以指定请求的资源的行为。\n\n- HTTP/1.0：GET、POST、PUT、HEAD、DELETE、LINK、UNLINK（HTTP/1.1删除 LINK 和 UNLINK）\n- HTTP/1.1：GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT\n\n#####  持久连接减少通信量\n\n原始的 Web 页面信息很少，每进行一次 HTTP 通信就建立一次 TCP 连接。\n\n- 建立 TCP 连接\n- HTTP 请求\n- HTTP 响应\n- 断开 TCP 连接\n\n通信过程：建立 - 请求 - 响应 - 断开\n\n如果一个页面包含大量数据，那就需要建立多次请求。每次请求又会重新断开和建立 TCP 连接，这就造成了许多无谓的开销。\n\n通信过程：建立 - 请求 - 响应 - 断开 - 建立 - 请求 - 响应 - 断开 - ...\n\n解决方案一：**持久连接**\n\n**持久连接**（HTTP Persistent Connection，也称为 HTTP keep-alive 或者 HTTP connection reuse）的特点是只要任意一方提出断开连接，则保持 TCP 连接状态。这样的好处在于在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载；同时也减少了传输所用的时间，加快了 Web 页面的显示速度\n\n通信过程：建立 - 请求 - 响应 - 请求 - 响应 - ... - 请求 - 响应 - 断开\n\n解决方案二：**管线化**\n\n**管线化技术**允许客户端无需等待响应可以直接发送下一个请求。这样一来就可以做到同时并行发送多个请求，而不需要等待响应。\n\n通信过程：建立 - 请求 1 - 请求 2 - 响应 1 - 响应 2 - 断开\n\n### HTTP 报文信息\n\n##### HTTP 报文\n\nHTTP 报文是用于 HTTP 协议交互的信息，是由多行数据构成的字符串文本 。客户端发出请求报文，服务器端回复响应报文。\n\nHTTP 报文分为报文首部和报文主体两部分。二者由空行（CR+LF）来划分。通常，并不一定需要报文主体。\n\n- 报文首部：服务器端或客户端需处理的请求或响应的内容及属性。\n- 空行 CR + LF：CR（Carriage Return，回车符：0x0d）和 LF（Line Feed，换行符：0x0a）\n- 报文主体：应被发送的数据。\n\n##### 请求报文和响应报文结构\n\n###### 请求报文结构\n\n- 请求报文 = 请求报文的首部 + 空行 + 报文主体\n- 请求报文首部 = 请求行 + 请求首部字段 + 通用首部字段 + 实体首部字段 + 其他\n\n###### 请求报文实例\n\n```http\nGET / HTTP/1.1\nHost: hackr.jp\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv13.0) Geoko/20100101 Firefox/13.0.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: ja,en-us;q=0.7,en;q=0.3\nAccept-Encoding: gzip, deflate\nDNT: 1\nConnection: keep-alive\nPragma: no-cache\nCache-Control: co-cache\n (空行：CR+LF)\n```\n\n###### 响应报文结构\n\n响应报文 = 响应报文的首部 + 空行 + 报文主体\n\n响应报文首部 = 状态行 + 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他\n\n###### 响应报文实例\n\n```http\nHTTP/1.1 200 OK\nDate: Fri, 13 Jul 2012 02:45:26 GMT\nServer: Apache\nLast-Modified: Fri, 31 Aug 2007 02:02:20 GMT\nETag: \"45bael-16a-46d776ac\"\nAccept-Range: bytes\nContent-Length: 362\nConnection: close\nContent-Type: text/html\n (空行：CR+LF)\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>hackr.jp</title>\n</head>\n<body>\n<img src=\"hackr.gif\" alt=\"hackr.jp\" width=\"240\" height=\"84\" />\n</body>\n</html>\n```\n\n报文的组成\n\n- 请求行：请求的方法，请求 URI 和 HTTP 版本\n- 状态行：响应结果的状态码，原因短语和 HTTP 版本。\n- 首部字段：请求首部（或响应首部）、通用首部和实体首部\n- 其他：HTTP 的 RFC 未定义的首部\n\n##### 编码提升传输速率\n\nHTTP 协议可以通过计算机编码来压缩或分割传输的内容，提升传输的速率。同样地，编码需要额外消耗计算机资源。\n\n###### 报文主体和实体主体\n\n报文是 HTTP 通信的基本单位，由 8 位组字节流组成，通过 HTTP 通信。\n\n实体作为响应或请求的有效载荷数据被传输，其内容有实体首部和实体主体组成。\n\n- 对于没有编码的情况，报文主体等于实体主体；\n- 对于有编码的情况，报文主体为实体主体编码之后的产物；\n\n内容编码和分块传输编码\n\n- **内容编码**指明应用在实体内容上的编码格式，并保持尸体信息原样压缩。压缩编码后的实体有客户端接收并负责解码。\n\n- **分块传输编码**通过把数据分割成多块，让大容量数据分块逐步显示在 Web 页面上。\n\n  ###### 多部分对象集合\n\nMIME（Multipurpose Internet Mail Extensions，多用途因特网邮件拓展）允许邮件处理文本、图片、视频等多个不同类型的数据。多部分对象集合最早应用在可以添加多份附件的邮件系统中，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体中可以含有多类型实体。\n\n包含的对象如下：\n\n- multipart/from-data：在 Web 表单上传文件时使用\n- multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用\n\n###### 获取部分内容的范围请求\n\n**断点续传**是解决大容量传输的另一个方案：为了避免下载中断的引起下载任务从头开始，需要从下载中断处回复下载的机制。实现这样的功能的请求为**范围请求**，范围请求可以通过首部字段 Range 来指定下载的实体字节范围。\n\n范围请求实例\n\n```http\nGET /tip.jpg HTTP/1.1\nHost: www.usaidesign.jp\nRange: bytes =5001-10000\n```\n\n范围请求的响应\n\n```http\nHTTP/1.1 206 Partial Content\nDate: Fri, 13 Jul 2012 04:29:17 GMT\nContent-Range: bytes 5001-10000/10000\nContent-Length: 5000\nContent-Type: image/jpeg\n\n...\n```\n\n> 特别地，追对范围请求\n>\n> - 响应范围请求时，服务器返回状态码 206 Partial Content\n> - 无法响应范围请求时，服务器返回状态码 200 OK \n\n###### 内容协商机制\n\n**内容协商机制**是指客户端和服务器之间就相应的资源内容进行交涉，然后提供给客户端最为合适的资源。\n\n内容协商技术有三种类型：\n\n- 服务器驱动协商\n- 客户端驱动协商\n- 透明协商\n\n在请求报文中通过使用以下首部字段：\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Content-Language\n\n### HTTP 状态码\n\n状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果。\n\n|      | 类别          | 原因短语                   |\n| ---- | ------------- | -------------------------- |\n| 1XX  | Informational | 接受的请求正在处理         |\n| 2XX  | Success       | 请求正常处理完毕           |\n| 3XX  | Redirection   | 需要进行附加操作以完成请求 |\n| 4XX  | Client Error  | 服务器无法处理请求         |\n| 5XX  | Server Error  | 服务器处理请求出错         |\n\n##### 2XX 成功\n\n- 200 OK ：请求被正常处理了\n- 204 No Content ：接受的请求已经处理，但返回的报文中不包含主体\n- 206 Partial Content ：服务器正常响应了范围请求\n\n##### 3XX 重定向\n\n- 301 Moved  Permanently ： 永久性重定向。客户端应该使用新的 URI \n- 302 Found ：临时性重定向。用户（本次）应当使用新的 URI 访问（尽管禁止 POST 改 GET，实际还是这样操作）\n- 303 See Other ：由于请求对应的资源存在另一个 URI ，应使用 GET 方法定向获取请求的资源。\n- 304 Not Modified ：请求的附带条件不满足，返回 304 Not Modified 不包含任何响应的主体\n- 307 Temporary Redirect ：临时性重定向。与 302 一致但不会从 POST 变成 GET。\n\n##### 4XX 客户端错误\n\n- 400 Bad Request ：请求报文中存在语法错误\n- 401 Unauthorized ：需要 HTTP 认证或者认证失败（This server could not verify that you are authorized to access the document requested. Either you supplied the wrong credentials (e.g., bad password), or your browser doesn't understand how to supply the credentials required）\n- 403 Forbidden ：对请求资源的访问被服务器拒绝了，服务器无需给出理由\n- 404 Not Found ：服务器上没有请求的资源（The request URL /a  was found on this server）\n\n##### 5XX 成功\n\n- 500 Internet Server Error\n- 503 Service Unavailable\n\n### 与 HTTP 协作的 Web 服务器\n\n一台 Web 服务器可以搭建多个独立域名的 Web 网站，也可以作为通信路径上的中转服务器提升传输效率。\n\n##### 单台主机实现多个域名\n\nHTTP/1.1允许允许一台 HTTP 服务器利用虚拟主机（Virtual  Host）搭建多个 Web 站点。\n\n当两个域名同时部署在同一个服务器上时，只会有一个 IP 地址，这时 DNS 服务器解析域名时，二者的访问 IP 地址也会相同。因此必须在 Host 首部内完成指定主机名或域名的 URI。\n\n##### 通信数据转发程序：代理、网关、隧道\n\nHTTP 通信中除了客户端和服务器以外，还有一些配合服务器工作，用于通信数据的转发的应用程序，例如代理、网关和隧道。\n\n- 代理：位于客户端和服务器中间有转发功能的应用程序。接收客户端的请求并转发给服务器，接收服务器的响应并转发给客户端。\n- 网关：转发其他服务器通信数据的服务器，接收客户端发送来的请求时，会像自己拥有资源的服务器一样对请求进行处理。\n- 隧道：在客户端和服务器两者之间进行中专，并保持双方通信连接的应用程序。\n\n###### 代理\n\n代理服务器的基本行为是接收客户端的请求后转发给其他服务器。代理不改变请求 URI ，会直接发送给源服务器。多部代理服务器可以级联，转发时，需要附加 Via 首部字段以标记出经过的主机信息。\n\n多种用途：\n\n- 利用缓存技术减少网络带宽\n- 组织内部针对特定网站的访问控制\n- 获取访问日志为主要目的\n\n两种分类基准：\n\n- 缓存代理：预先将资源的副本保存在代理服务器上，再次接受请求时不从源服务器获取资源，而是将缓存作为响应返回。\n- 透明代理：不对报文做任何加工的代理称为透明代理；对报文进行加工的代理称为非透明代理。\n\n###### 网关\n\n网关能使通信线路上的服务器提供非 HTTP 协议服务。网关能在客户端与网关之间的通信线路上加密，提高通信的安全性。\n\n###### 隧道\n\n隧道可以建立一条与其他服务器的通信连接，并使用 SSL 等加密手段进行通信，确保客户端能与服务器进行安全的通信。此外，隧道本身是透明的，隧道本身不解析 HTTP 请求，保持原样中转给之后的服务器，并自动在在通信双方断开连接时结束。\n\n##### 保存资源的缓存\n\n缓存是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可以减少对源服务器的访问，节省了通信流量和通信时间。\n\n缓存服务器是代理服务器的一种，属于缓存代理。缓存服务器可以利用缓存文件避免多次的从服务器转发资源，一方面通信时间减少，另一方面也可以同时减小服务器的压力。\n\n- 当然缓存必须是有期限，万一源服务器的资源有更新，缓存就会失效。\n- 缓存服务器需要根据客户端要求或者缓存的有效期等音速，向服务器确认确认资源的有效性。\n- 若缓存失效，将再次获取新的资源\n- 浏览器也可以存在于客户端，也会确认并更新资源的有效性。\n\n### HTTP 首部\n\n四种首部字段类型\n\n- 通用首部字段（都会使用的首部）\n- 请求首部字段（仅请求）\n- 响应首部字段（仅响应）\n- 实体首部字段（仅含有实体的报文）\n\n##### 通用首部字段\n\n- Cache-Control：控制缓存的行为\n- Connection：控制不再转发给代理的首部字段，控制持久连接\n- Date：创建 HTTP 报文的日期时间\n- Pragma：只用于请求报文中，要求所有中间服务器不返回缓存的资源\n- Trailer：记录报文主体后的首部字段\n- Transfer-Encoding：指定报文主体的编码方式\n- Upgrade：指定升级为其他通信协议\n- Via：追踪客户端和服务器之间请求和响应报文的传输路径\n- Warning：告知用户警告内容\n\n##### 请求首部字段\n\n- Accept：用户代理可处理的媒体类型以及媒体相对优先级\n- Accept-Charset：用户代理支持的字符集和字符集的相对优先顺序\n- Accept-Encoding：用户代理支持的内容编码和内容编码的优先级顺序\n- Accept-Language：用户代理能处理的自然语言集和自然语言集的相对优先级\n- Authorization：用户代理的认证信息（证书值）\n- Expect：告知服务器，期待服务器的特定行为，无法理解时返回 417 Expectation Failed\n- From：告知服务器使用用户代理的用户的电子邮箱地址\n- Host：告知服务器，请求资源所在的主机名和端口号（必须包含在请求内的首部字段）\n- If-Match：比较实体标记（Etag 与字段值匹配一致，服务器才接受请求，否则返回状态码 412）\n- If-Modified-Since：比较资源的更新时间（指定时间后有更新，接受请求，否则返回状态码 304）\n- If-None-Match：比较实体标记（与 If-Match 相反）\n- If-Range：字段值与 ETag 或更新的日期时间匹配一致，就作为范围请求处理（否则返回全部资源）\n- If-Unmodified-Since：比较资源的更新时间（与 If-Modified-Since 相反）\n- Max-Forwards：最大传输逐跳数（可经过的服务器数量，转发次数）\n- Proxy-Authorization：代理服务器要求客户端的认证信息\n- Range：范围请求时，服务器资源的字节范围\n- Referer：对请求中 URI 的原始获取方\n- TE：告知服务器客户端能够处理的响应的传输编码方式和相对优先级\n- User-Agent：HTTP 客户端程序的信息（创建请求的浏览器，用户代理名称等信息）\n\n##### 响应首部字段\n\n- Accept-Ranges：告知客户端服务器是否接受字节范围请求（可以时字段值为 bytes，否则为 none）\n- Age：由缓存服务器创建，资源经上次认证经过的时间\n- Etag：告知客户端实体标识，将资源以字符串形式做唯一性标识的方式分配 ETag\n- Location：可以将响应接收方引导至某个与请求 URI 位置不同的资源\n- Proxy-Authenticate：把由代理服务器对客户端要求的认证信息发送给客户端\n- Retry-After：告知客户端再次发起请求的时间\n- Server：当前服务器上 HTTP 服务器应用程序的信息\n- Vary：代理服务器缓存的管理信息，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。\n- WWW-Authenticate：HTTP 访问认证。访问请求 URI 制定资源的认证方案和带参数的质询。\n\n##### 实体首部字段\n\n- Allow：资源可支持的 HTTP 方法\n- Content-Encoding：实体主体适用的内容编码方式\n- Content-Language：实体主体使用的自然语言\n- Content-Length：实体主体的大小（单位字节）（内容编码时，不再使用该字段）\n- Content-Location：报文主体返回资源对应的 URI\n- Content-MD5：报文主体的 MD5 码，验证作用\n- Content-Range：实体主体的位置范围\n- Content-Type：实体主体内对象的媒体类型\n- Expires：实体主体过期的日期时间\n- Last-Modified：资源的最后修改日期时间\n\n##### 为 Cookie 服务的首部字段\n\n- Set-Cookie：开始状态管理所使用的 Cookie 信息\n- Cookie：服务器接收到的 Cookie 信息\n\n##### 其他首部字段\n\n- X-Frame-Options：响应首部，控制网站内容在其他 Web 网站的 Frame 标签内的显示问题\n- X-XSS-Protection：响应首部，针对跨站脚本攻击，控制浏览器 XSS 防护机制的开关\n- DNT：请求首部，拒绝个人信息被收集的\n- P3P：响应首部，利用 P3P 技术，让 Web 网站上的个人隐私变成仅供程序可理解的形式，保护用户隐私\n\n### HTTPS：安全的 HTTP\n\nHTTP 协议中有可能存在信息窃听或身份伪装等安全问题，使用 HTTPS 通信机制可以有效地防止这些问题。\n\n##### HTTP 的缺点\n\n- 通信使用明文，内容可能遭遇窃听\n- 不验证通信双方的身份，可能遭遇伪装\n- 无法验证报文的完整性，有可能遭遇篡改\n\n###### 通信使用明文可能会被窃听\n\n>  HTTP 协议不对通信进行加密\n\n互联网由能连通到全世界的网络组成的，通信的数据包在全网中流动传输。只要在互联网中，所有的报文信息都是全网可见的。为了保证通信的安全性，加密处理才是有效的方案。\n\n- 通信的加密（安全的通信线路）\n\nHTTP 协议没有加密机制，但是可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。\n\n- 内容的加密（安全的通信内容）\n\n客户端将 HTTP 报文进行加密处理后再发送请求。为了服从 HTTP 协议的要求，报文首部不加密而只对报文主体加密处理。客户端和服务器需要同时有加密和解密机制，但是没有安全的通信线路，内容仍有被篡改的风险。\n\n######不验证通信双方的身份就可能遭遇伪装\n\n> HTTP 协议不对请求和响应的通信双方进行确认。\n>\n> - 伪装的 Web 服务器和客户端\n> - 无访问权限的通信方\n> - 无法判定请求方\n> - Dos 攻击（Denial of Service，拒绝服务器攻击）\n\n- 查明对方的证书\n\n虽然使用 HTTP 无法确定通信方，如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用证书来验证通信方。**证书**由值得信任的第三方机构颁发根据密码学原理生成，用以证明服务器和客户端是实际存在的。有了证书，就可以证明给通信方就是期望的服务器。\n\n###### 无法证明报文完整性可能已遭篡改\n\n>  HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。（中间人攻击，Man-in-the-Middle attack，MITM）\n\nHTTP 协议存在的确定报文完整性的方法并不便捷、可靠，常用的是 MD5 和 SHA-1 等散列值校验方法和确认文件的数字签名方法。使用这些方法也无法确保结果正确，因为校验值本可能被改写。\n\n**为了防止这三个弊端，因此需要使用 HTTPS。**\n\n##### HTTPS = HTTP + 加密 + 认证 + 完整性保护\n\nHTTPS 不是新的协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。\n\n- 一般情况下，HTTP 直接与 TCP 通信。\n- 采用 SSL 时，HTTP 就先与 SSL 通信，再由 SSL 和 TCP 通信。\n\n##### 对称加密和非对称加密\n\n对称加密指的是加密和解密同用一个密钥的加密方式：\n\n- 密钥对于任何一方都是一样的\n- 任何人只要持有密钥就可以加密和解密\n- 密钥必须安全地提前发给对方\n- 安全性的漏洞在于通信过程必须安全地告知对方\n\n非对称加密指的是加密和解密同用一对非对称密钥的加密方式：\n\n- 密钥分为公钥和私钥，公钥对所有人公开，私钥由接收方单独持有\n- 持有公钥可以加密，持有私钥可以解密\n- 只要将公钥公开交付，交由发送方加密\n- 缺点是加密解密的速度更慢\n\n实际上，两种加密机制都有缺点，对称加密无法安全传输密钥，非对称加密的加密过程耗时更多，HTTPS 采用的是两种机密方式并用的混合加密机制。\n\n- 使用非对称加密安全地交换对称加密中的密钥；\n- 建立通信后，再使用对称加密方式；\n\n###### 证书证明公开密钥的真实性\n\n证书的作用是证明公开密钥的真实性。\n\n数字证书认证机构是对于客户端和服务器都可信任的第三方机构，专门颁发公开密钥的数字证书。服务器将服务器申请的公开密钥做数字签名，这就是数字证书。数字签名是使用数字证书认证机构的私钥加密的，这能证明文件是从数字证书认证机构颁发的。\n\n服务器将数字证书发送至客户端，客户端可以用数字机构的公开密钥验证，一旦验证就知道认证机构和服务器的公开密钥有效。\n\n###### HTTPS 安全通信机制\n\n> 对于一个主机来说，要想保证绝对的通信安全，唯一可信的只有自己。\n\n在只有主机可信的前提下，怎样建立安全的通信机制。万幸浏览器帮了我们一个大忙，多数浏览器都会实现在内部植入常用认证机关的公开密钥。\n\n- 浏览器事先植入认证机构公钥\n- 服务器向客户端发送公钥证书\n- 客户端用认证机构的公钥确认证书的真实性\n- 客户端取出服务器公钥\n- 客户端使用服务器的公钥加密\n- 服务器用私钥解密实现安全通信\n\n\n### 确认访问用户的身份\n\n> 某些 Web 页面需要有一些权限，这就需要认证功能。\n\nHTTP/1.1 使用的认证方式\n\n- BASIC 认证（基本认证）\n- DIGEST 认证（摘要认证）\n- SSL 客户端认证\n- FormBase 认证（基于表单认证）\n\n###### BASIC 认证\n\nBASIC 认证虽然采用 Base64 编码方式，这只是编码方式，不需要任何信息就可以解码。在非 HTTP 的线路上使用 BASIC 认证是很不安全的。此外，浏览器无法注销操作，认证使用上不够灵活。因此 BASIC 认证并不常用。\n\n###### DIGEST 认证\n\nDIGEST 认证是使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。质询/响应的方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方接收到的质询码计算生成响应码。最后向响应码返回给对方进行认证的方式。相比 BASIC 认证，安全性更高。\n\n###### SSL 客户端认证\n\nSSL 客户端使用 HTTPS 的客户端证书完成认证。客户端证书由安全性极高的认证机构颁发，但需要支付一定的费用。以客户端证书进行客户端认证，足以证明服务器正在通信的对方是预料的客户端。\n\nSSL 客户端认证不仅依靠证书完成认证，一般会和基于表单认证组合使用一种双因素认证来使用。SSL 客户端证书用来认证客户端计算机，基于表单认证用来确定这时本人的行为。\n\n###### 基于表单认证\n\n基于表单认证并不是在 HTTP 协议中定义，客户端会像服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果验证。BASIC 认证和 DIGEST 认证安全性和便利性都不够，SSL 客户端足够安全但成本过高，基于表单认证足够安全，也不需要一定的标准规范，因此比较常见。\n\n###### Session 管理及 Cookie 应用\n\n基于表单认证的标准的缺点是 HTTP 的无协议特性，无法实现状态管理，因此使用 Cookie 管理 Session（会话）。\n\n客户端发送已登陆信息，服务器向用户发放 Session ID 记录认证状态，之后通过验证 Session ID 来判定对方是真实用户。\n\n### 基于 HTTP 的功能追加协议\n\n##### HTTP 瓶颈\n\n基于 HTTP 协议无法做到实时更新 Web 页面上的内容。\n\nHTTP 的一些标准会成为瓶颈：\n\n- 一条连接上只可发送一个请求。\n- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。\n- 请求/响应首部未经压缩就发送。首部信息越多延迟越大。\n- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。\n- 可任意选择数据压缩格式。非强制压缩发送。\n\n###### Ajax 的解决方法\n\nAjax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文件对象模型）达到局部 Web 页面替换加载的异步通信手段（只更新部分页面，减少响应中传输的数据量）。\n\n###### Comet 的解决方案\n\nComet 延迟响应，挂起状态，直至内容更新返回响应。\n\n这一过程模拟了服务器向客户端推送（Server Push）功能。尽管 Comet 实现了实时更新，但维持连接消耗更多资源，仍未解决 HTTP 协议的问题。\n\n##### SPDY 缩短 Web 页面的加载时间\n\nSPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，同时 SPDY 规定通信中使用 SSL。\n\nHTTP 处于应用层，SPDY 会话层，SSL 处于表示层，TCP 处于传输层。\n\n使用 SPDY 后，HTTP 协议额外获得一些功能：\n\n- 多用复用流：一次 TCP 连接可以无限制处理多个 HTTP 请求，效率提高。\n- 赋予请求优先级：SPDY 可以给请求分配优先级顺序，解决带宽低而相应变慢的问题。\n- 压缩 HTTP 首部：减少通信数据包的字节数。\n- 推送功能：支持服务器主动向客户端推送功能。\n- 服务器提示功能：服务器可以主动提示客户端所需的资源。\n\n##### 使用浏览器进行全双工通信的 WebSocket\n\n利用 Ajax 和 Comet 级数进行通信可以提升 Web 的浏览速度，WebSocket 网络技术是避免 HTTP 的瓶颈的新协议及 API。WebSocket 既支持服务器向客户端推送数据，也支持持续保持 WebSocket 连接，以更短的首部减少通信量。\n\nWebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行，通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式，并且双方都可以直接向对方发送报文。\n\n###### 握手·请求\n\n为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。\n\n```http\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n\n- Sec-WebSocket-Key：记录握手过程中必不可少的键值\n- Sec-WebSocket-Protocol：记录使用的子协议\n\n###### 握手·响应\n\n响应 WebSocket 通信，返回的状态码为 101 Switching Protocols。\n\n```http\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgeade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\nSec-WebSocket-Protocol: chat\n```\n\nSec-WebSocket-Accept 的值根据握手请求中 Sec-WebSocket-Key 的字段值生成。成功握手确立 WebSocket 连接之后，通信时不在使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。\n\n###### WebSocket API\n\nJavaScript 可调用 “The WebSocket API” 内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。\n\n```javascript\nvar socket = new WebSocket('ws://game.example.com:12010/updates');\nsocket.onopen = function(){\n    setInterval(function(){\n        if (socket.bufferedAmount == 0)\n            socket.send(getUpdateData());\n    }, 50);\n};\n```\n\n##### Web 服务器管理文件的 WebDAV\n\nWebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行进行文件复制、编辑等操作的分布式文件系统。\n\nHTTP/1.1的 PUT 方法和 DELETE 方法，可以对 Web 服务器上的文件进行创建和删除操作，出于安全性和便捷性一般不使用。\n\nWebDAV 新增加的概念：\n\n- 集合（Collection）：一种统一管理多个资源的概念。以集合为单位可进行各种操作，也可实现类似集合的集合这样的操作。\n- 资源（Resource）：文件或集合称为资源。\n- 属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。\n- 锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。\n\n###### WebDAV 新增的方法\n\n- PROPFIND：获取属性\n- PROPPATCH：修改属性\n- MKCOL：创建集合\n- CPOY：复制资源及属性\n- MOVE：移动资源\n- LOCK：资源加锁\n- UNLOCK：资源解锁\n\n###### WebDAV 拓展的状态码\n\n- 102 Processing：可正常处理请求，但目前是处理中状态\n- 207 Muti-Status：存在多种状态\n- 422 Unprocessible Entity：格式正确，内容有误\n- 423 Locked：资源已被加锁\n- 424 Failed Dependency：处理与某请求关联的请求失败，因此维持依赖关系\n- 507 Insufficient Storage：保存空间不足\n\n### 构建 Web 内容的技术\n\n##### HTML\n\n###### 超文本标记语言 HTML \n\nHTML（HyperText Markup Language，超文本标记语言）是一种标记语言。标记语言通过标签控制构建 Web 页面\n\n###### 层叠样式表 CSS\n\nCSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素。\n\n##### 动态 HTML\n\n动态 HTML（Dynamic HTML）值使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。\n\n###### 客户端脚本语言 JavaScript \n\n动态 HTML 调用客户端脚本语言 JavaScript 实现对 HTML 的 Web 页面的动态改造；\n\n###### 文档对象模型 DOM\n\nDOM 将 HTML 内的元素当作对象操作，指定欲发生动态变化的 HTML 元素。\n\n##### Web 应用\n\n###### Web 应用作用于动态内容之上\n\n由程序创建的内容为动态内容；事先准备好的内容称为静态内容。Web 应用作用于动态内容上。\n\n###### 与 Web 服务器及程序协作的 CGI\n\nCGI（Common Gateway Interface，通用网关接口）是 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。（CGI 程序一般用 Perl、PHP、Ruby 和 C 等编程语言编写而成）\n\n###### 因 JAVA 而普及的 Servlet\n\nServlet 是一种能在服务器创建动态内容的程序，是用 JAVA 语言实现的一个接口。\n\n> Servlet 常驻内存，CGI 程序则需要不断启动。\n\n##### 数据发布的格式及语言\n\n###### 可拓展标记语言\n\nXML（eXtensible Markup Language，可拓展标记语言）是一种可按应用目标进行拓展的通用标记语言。\n\n> HTML 更适合显示 Web 页面，XML 更适合数据交换。\n\n###### 发布更新信息的 RSS/Atom\n\nRSS（建议信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。\n\n###### JavaScript 衍生的轻量级易用 JSON\n\nJSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。JSON 字符串形式可以被 JavaScript 轻易读入，能处理 false / null / true / 对象 / 数组 / 数字 / 字符串这七类数据。\n\n### Web 的攻击技术\n\n##### 针对 Web 的攻击技术\n\n###### HTTP 不具备必要的安全功能\n\nHTTP 是一个纯粹的通信协议，无法应对针对 Web 的攻击。开发者需要自行设计并开发认证及会话管理来满足 Web 应用的安全，这样也可能会有安全漏洞。\n\n###### 在客户端即可篡改请求\n\n浏览器接收到的 HTTP 请求的全部内容都可以在客户端自由更变、篡改。若 Web 应用有漏洞，服务器的信息将被窃取，权限被夺取。\n\n##### 针对 Web 应用的攻击模式\n\n- 以服务器为目标的主动攻击：直接访问 Web 应用，传入攻击代码。\n- 以服务器为目标的被动攻击：不直接对 Web 应用访问，而利用圈套策略执行攻击代码。\n\n##### 因输出值转义不完全引发的安全漏洞\n\n- 跨站脚本攻击：通过存在安全漏洞的 Web 网站用户的浏览器内运行 HTML 标签或 JavaScript 进行攻击。\n- SQL 注入攻击：针对 Web 应用使用的数据库，通过运行非法的 SQL 产生攻击。\n- OS 命令注入攻击：通过 Web 应用，执行非法的操作系统命令达到攻击的目的。\n- HTTP 首部注入攻击：攻击者通过在相应首部字段内插入换行，添加任意相应首部或主体的攻击。\n- 邮件首部注入攻击：攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。\n- 目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后达成访问目的。\n- 远程文件包含漏洞：利用外部服务器的 URL 充当以来文件，让脚本读取后，运行任意脚本的一种攻击。\n\n##### 因设置和设计上的缺陷引发的安全漏洞\n\n- 强制浏览：从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。\n- 不正确的错误消息处理：Web 应用的错误消息内包含对攻击者有用的信息。\n- 开放重定向：对指定的任意的 URL 作重定向跳转值特定的 Web 网站。\n\n##### 因会话管理疏忽引发的安全漏洞\n\n- 会话挟持：攻击者窃取用户的会话 ID，并非法使用次会话 ID 伪装成用户达到攻击目的。\n- 会话固定攻击：强制用户使用攻击者指定的会话 ID\n- 跨站点请求伪造：攻击者通过设置好的陷阱强制对已完成认证的用户进行某些状态更新。\n\n##### 其他安全漏洞\n\n- 密码破解：算出密码，突破认证。\n- 点击挟持：利用透明的按钮或连接做成陷阱，覆盖在 Web 页面上，诱使用户访问特定内容。\n- DoS 攻击：让运行中的服务呈停止状态。（过量请求或安全漏洞使服务器过载）\n- 后门程序：开发设置的隐藏入口，可不按正常步骤使用受限功能。\n\n","source":"_posts/HTTP-学习笔记.md","raw":"---\ntitle: HTTP学习笔记\ndate: 2018-05-04 11:40:19\ntags: HTTP\n---\n\n### Web 页面的实现\n\n\n\n##### Web 基于 HTTP 协议通信\n\n> 客户端（Client）的 Web 浏览器从 Web 服务器端获取文件资源等信息 。\n\n\n\n<!--more-->\n\n\n\n1. 浏览器的地址栏输入 URL\n2. URL 信息送往某处\n3. 从某处得到回复\n4. 将回复内容显示在 Web 页面上\n\nWeb 建立在 **HTTP 协议**（HyperText Transfer Protocol，超文本传输协议）实现通信。\n\n目前主流的 HTTP 版本：HTTP/1.1\n\n##### TCP/IP 网络层\n\n网络分层：\n\n- 设计各层之间接口，若需要改变设计只需改动有变动的层\n- 简化设计，只需完成该层的任务\n\n位于应用层的 HTTP 数据每经过一层就会打上属于该层的首部信息，这一过程称为**封装**。\n\n1. **IP** （Internet Protocol）网际协议位于网络层，任务是传输数据包。\n\n   IP 协议中有两种地址：IP 地址和 MAC 地址（Media Access Control Address）\n\n- IP 地址：网络中分配到的地址，全网唯一；（IP 地址分段，就像邮编决定数据流动的方向）\n\n\n- MAC 地址：每个网卡固定有一个 MAC 地址，无法改变。（ARP 协议用于解析 IP 地址，得到 MAC 地址）\n\n2. **TCP** 位于传输层：提供通过可靠的字节流服务。\n\n   TCP 的可靠传输：三次握手策略（SYN 和 ACK）\n\n- 发送端发送 SYN  标志的数据包；\n\n\n- 接收端回传 SYN/ACK 标志的数据包传达确认信息；\n- 发送端再回传一个 ACK 标志的数据包；\n\n##### DNS 服务\n\n**DNS** （Domain Name System）服务是位于应用层，可以提供域名解析服务。\n\n在网络中，每个主机都有唯一的 IP 地址，在互联网中我们却不太可能全部使用一串数字来记住网站，我们使用的是**域名**。\n\n- 计算机网络使用 IP 地址来实现网络中数据的传输。\n- 用户使用域名来访问网站。\n- 用户通过访问 DNS 服务器询问域名的 IP 地址，取得 IP 地址后，就可以通过 IP 地址访问。\n\n##### URL 和 URI\n\n- URL（Uniform Resource Locator，统一资源定位符）访问网页时需要输入的网页地址，表示资源的地点。\n- URI（Uniform Resource Identifier，统一资源标识符）用字符串标识某一互联网资源。\n\n```\nhttp://user:pass@www.example.jp:80/dir/index/htm?uid=1#ch1\n```\n\nURI 格式依次由：协议方案、登陆信息、服务器地址、服务器端口号、带层次的文件路径、查询字符串和片段标识符构成。\n\n### HTTP 协议\n\n##### 客户端和服务器\n\nHTTP 协议中，必然是一方为客户端，一方为服务器。\n\n- 客户端：请求访问文本或图像等资源的一端；\n- 服务器端：提供资源响应的一端；\n\n> 通信的双方是不对等的，因此在通信过程中，通常上行速度比下载速度慢很多。\n\n##### 请求和响应\n\n客户端和服务器端通过请求和响应的交换达成通信。\n\n- 客户端先发送请求；\n- 服务器再发送响应；\n- 服务器本身无法在没有请求时发送响应\n\n1. 客户端发送请求\n\n```http\nGET /index.htm HTTP/1.1\nHost: hackr.jp\n```\n\n- 起始行的 GET 表示请求访问的方法（method）；\n- 字符串 /index.htm 指明了请求访问的资源对象，就是请求 URI（request-URI）；\n- HTTP/1.1 为客户端 HTTP 版本号；\n- 也就是说，向主机名为 hackr.jp 的服务器请求 /index.hem 页面资源。\n- 总的来说，请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成。\n\n2. 服务器发送响应\n\n```http\nHTTP/1.1 200 OK\nDate: Tue, 10 Jul 2012 06:50:15 GMT\nContent-Length: 362\nContent-Type: text/html\n\n<html>\n...\n```\n\n- HTTP/1.1 为服务器对应的 HTTP 版本。\n- 200 OK 为请求的处理结果的状态码（status code）和原因短语（reason-phrase）\n- 之后的为首部字段（header field）\n- 空一行之后为资源的主体（entity body）\n- 响应报文由协议版本、状态码、原因短语、首部字段和实体主题\n\n\n##### Cookie 解决状态问题\n\nHTTP 协议自身不对请求和响应之间的通信状态进行保存。这样一来，服务器只需要专一化的处理响应 HTTP 请求即可，减少了服务器 CPU 和内存的消耗。\n\n当然 Web 网络中状态管理还是很重要的，如果网站每次都要重新登录和重新认证，结果是很糟糕的。Cookie 技术会在请求和响应报文中加入 Cookie 信息来控制客户端的状态。\n\n1. 没有 Cookie 时发出请求\n\n- 客户端向服务器发出请求\n- 服务器通过生成 Cookie 信息（这一时刻记住了客户端信息）\n- 在响应中添加 Set-Cookie 的首部字段信息。\n- 服务器回复响应\n- 客户端收到后就把 Cookie 保存起来。\n\n2. 有 Cookie 状态信息时发出请求\n\n- 客户端主动在请求报文中添加 Cookie 信息\n- 客户端向服务器发出请求\n- 服务器检查 Cookie 信息\n- 服务器回复响应\n\n#####  请求 URI 定位网络资源\n\nHTTP 协议使用 URI 定位互联网上的资源，客户端访问请求资源发送请求时，需要在请求报文中添加 URI 。\n\n1. 使用完整的请求 URI\n\n```http\nGET /index.htm HTTP/1.1\n```\n\n2. 使用 Host 首部字段写明网络域名或 IP 地址\n\n```http\nGET /index.htm HTTP/1.1\n```\n\n3. 使用 * 来代替 URI 只访问服务器\n\n```http\nOPTIONS * HTTP/1.1\n```\n\n#####  HTTP 方法告知服务器意图\n\n- GET ：获取资源\n\n```http\nGET /index.html HTTP/1.1\nHost: www.hackr.jp\n```\n\n返回 index.html 的页面资源。\n\n- POST ：传输实体主体\n\n```http\nPOST /submit.cgi HTTP/1.1\nHost: www.hackr.jp\nContent-length: 1560\n```\n\n返回 submit.cgi 接收数据的处理结果\n\n- PUT ：传输文件\n\n```http\nPUT /example.html HTTP/1.1\nHost: www.hackr.jp\nContent-Type: text/html\nContent-Length: 1560\n```\n\n向服务器上传文件，存在安全性问题，一般不使用，需要 Web 验证机制。\n\n- HEAD ：获得报文首部\n\n```http\nHEAD /index.html HTTP/1.1\nHost: www.hackr.jp\n```\n\n告知服务器无需返回报文主体部分，确认 URI 的有效性及资源更新日期时间。\n\n- DELETE ：删除文件\n\n```http\nDELETE /example.html HTTP/1.1\nHost: www.hackr.jp\n```\n\n删除服务器上的资源，存在安全性问题，一般不使用，需要 Web 验证机制。\n\n- OPTIONS ：询问支持的方法\n\n  ```http\n  OPTIONS * HTTP/1.1\n  Host: www.hackr.jp\n  ```\n\n针对服务器查询针对请求 URI 指定的资源支持的方法。\n\n- TRACE ：追踪路径\n\n  ```http\n  TRACE / HTTP/1.1\n  Host: hackr.jp\n  Max-Forward: 2\n  ```\n\n让 Web 服务器端将之前的请求通信环回给客户端，不常使用，可能引起跨站追踪（Cross-Site Tracing）。\n\n添加 Max-Forward 首部字段的数值，每经过服务器数值减一，数值为 0 的服务器返回状态码 200 OK 的响应。\n\n- CONNECT ：要求用隧道协议连接代理\n\n  ```http\n  CONNECT proxy.hackr.jp:8080 HTTP/1.1\n  Host: proxy.hackr.jp\n  ```\n\n要求与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。\n\n主要使用 SSL（Secure Sockets Layer，安全套接层）和 TSL（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输。\n\n#####  HTTP 方法指挥服务器\n\n使用方法作为命令来向服务器下达命令，可以指定请求的资源的行为。\n\n- HTTP/1.0：GET、POST、PUT、HEAD、DELETE、LINK、UNLINK（HTTP/1.1删除 LINK 和 UNLINK）\n- HTTP/1.1：GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT\n\n#####  持久连接减少通信量\n\n原始的 Web 页面信息很少，每进行一次 HTTP 通信就建立一次 TCP 连接。\n\n- 建立 TCP 连接\n- HTTP 请求\n- HTTP 响应\n- 断开 TCP 连接\n\n通信过程：建立 - 请求 - 响应 - 断开\n\n如果一个页面包含大量数据，那就需要建立多次请求。每次请求又会重新断开和建立 TCP 连接，这就造成了许多无谓的开销。\n\n通信过程：建立 - 请求 - 响应 - 断开 - 建立 - 请求 - 响应 - 断开 - ...\n\n解决方案一：**持久连接**\n\n**持久连接**（HTTP Persistent Connection，也称为 HTTP keep-alive 或者 HTTP connection reuse）的特点是只要任意一方提出断开连接，则保持 TCP 连接状态。这样的好处在于在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载；同时也减少了传输所用的时间，加快了 Web 页面的显示速度\n\n通信过程：建立 - 请求 - 响应 - 请求 - 响应 - ... - 请求 - 响应 - 断开\n\n解决方案二：**管线化**\n\n**管线化技术**允许客户端无需等待响应可以直接发送下一个请求。这样一来就可以做到同时并行发送多个请求，而不需要等待响应。\n\n通信过程：建立 - 请求 1 - 请求 2 - 响应 1 - 响应 2 - 断开\n\n### HTTP 报文信息\n\n##### HTTP 报文\n\nHTTP 报文是用于 HTTP 协议交互的信息，是由多行数据构成的字符串文本 。客户端发出请求报文，服务器端回复响应报文。\n\nHTTP 报文分为报文首部和报文主体两部分。二者由空行（CR+LF）来划分。通常，并不一定需要报文主体。\n\n- 报文首部：服务器端或客户端需处理的请求或响应的内容及属性。\n- 空行 CR + LF：CR（Carriage Return，回车符：0x0d）和 LF（Line Feed，换行符：0x0a）\n- 报文主体：应被发送的数据。\n\n##### 请求报文和响应报文结构\n\n###### 请求报文结构\n\n- 请求报文 = 请求报文的首部 + 空行 + 报文主体\n- 请求报文首部 = 请求行 + 请求首部字段 + 通用首部字段 + 实体首部字段 + 其他\n\n###### 请求报文实例\n\n```http\nGET / HTTP/1.1\nHost: hackr.jp\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv13.0) Geoko/20100101 Firefox/13.0.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: ja,en-us;q=0.7,en;q=0.3\nAccept-Encoding: gzip, deflate\nDNT: 1\nConnection: keep-alive\nPragma: no-cache\nCache-Control: co-cache\n (空行：CR+LF)\n```\n\n###### 响应报文结构\n\n响应报文 = 响应报文的首部 + 空行 + 报文主体\n\n响应报文首部 = 状态行 + 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他\n\n###### 响应报文实例\n\n```http\nHTTP/1.1 200 OK\nDate: Fri, 13 Jul 2012 02:45:26 GMT\nServer: Apache\nLast-Modified: Fri, 31 Aug 2007 02:02:20 GMT\nETag: \"45bael-16a-46d776ac\"\nAccept-Range: bytes\nContent-Length: 362\nConnection: close\nContent-Type: text/html\n (空行：CR+LF)\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>hackr.jp</title>\n</head>\n<body>\n<img src=\"hackr.gif\" alt=\"hackr.jp\" width=\"240\" height=\"84\" />\n</body>\n</html>\n```\n\n报文的组成\n\n- 请求行：请求的方法，请求 URI 和 HTTP 版本\n- 状态行：响应结果的状态码，原因短语和 HTTP 版本。\n- 首部字段：请求首部（或响应首部）、通用首部和实体首部\n- 其他：HTTP 的 RFC 未定义的首部\n\n##### 编码提升传输速率\n\nHTTP 协议可以通过计算机编码来压缩或分割传输的内容，提升传输的速率。同样地，编码需要额外消耗计算机资源。\n\n###### 报文主体和实体主体\n\n报文是 HTTP 通信的基本单位，由 8 位组字节流组成，通过 HTTP 通信。\n\n实体作为响应或请求的有效载荷数据被传输，其内容有实体首部和实体主体组成。\n\n- 对于没有编码的情况，报文主体等于实体主体；\n- 对于有编码的情况，报文主体为实体主体编码之后的产物；\n\n内容编码和分块传输编码\n\n- **内容编码**指明应用在实体内容上的编码格式，并保持尸体信息原样压缩。压缩编码后的实体有客户端接收并负责解码。\n\n- **分块传输编码**通过把数据分割成多块，让大容量数据分块逐步显示在 Web 页面上。\n\n  ###### 多部分对象集合\n\nMIME（Multipurpose Internet Mail Extensions，多用途因特网邮件拓展）允许邮件处理文本、图片、视频等多个不同类型的数据。多部分对象集合最早应用在可以添加多份附件的邮件系统中，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体中可以含有多类型实体。\n\n包含的对象如下：\n\n- multipart/from-data：在 Web 表单上传文件时使用\n- multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用\n\n###### 获取部分内容的范围请求\n\n**断点续传**是解决大容量传输的另一个方案：为了避免下载中断的引起下载任务从头开始，需要从下载中断处回复下载的机制。实现这样的功能的请求为**范围请求**，范围请求可以通过首部字段 Range 来指定下载的实体字节范围。\n\n范围请求实例\n\n```http\nGET /tip.jpg HTTP/1.1\nHost: www.usaidesign.jp\nRange: bytes =5001-10000\n```\n\n范围请求的响应\n\n```http\nHTTP/1.1 206 Partial Content\nDate: Fri, 13 Jul 2012 04:29:17 GMT\nContent-Range: bytes 5001-10000/10000\nContent-Length: 5000\nContent-Type: image/jpeg\n\n...\n```\n\n> 特别地，追对范围请求\n>\n> - 响应范围请求时，服务器返回状态码 206 Partial Content\n> - 无法响应范围请求时，服务器返回状态码 200 OK \n\n###### 内容协商机制\n\n**内容协商机制**是指客户端和服务器之间就相应的资源内容进行交涉，然后提供给客户端最为合适的资源。\n\n内容协商技术有三种类型：\n\n- 服务器驱动协商\n- 客户端驱动协商\n- 透明协商\n\n在请求报文中通过使用以下首部字段：\n\n- Accept\n- Accept-Charset\n- Accept-Encoding\n- Accept-Language\n- Content-Language\n\n### HTTP 状态码\n\n状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果。\n\n|      | 类别          | 原因短语                   |\n| ---- | ------------- | -------------------------- |\n| 1XX  | Informational | 接受的请求正在处理         |\n| 2XX  | Success       | 请求正常处理完毕           |\n| 3XX  | Redirection   | 需要进行附加操作以完成请求 |\n| 4XX  | Client Error  | 服务器无法处理请求         |\n| 5XX  | Server Error  | 服务器处理请求出错         |\n\n##### 2XX 成功\n\n- 200 OK ：请求被正常处理了\n- 204 No Content ：接受的请求已经处理，但返回的报文中不包含主体\n- 206 Partial Content ：服务器正常响应了范围请求\n\n##### 3XX 重定向\n\n- 301 Moved  Permanently ： 永久性重定向。客户端应该使用新的 URI \n- 302 Found ：临时性重定向。用户（本次）应当使用新的 URI 访问（尽管禁止 POST 改 GET，实际还是这样操作）\n- 303 See Other ：由于请求对应的资源存在另一个 URI ，应使用 GET 方法定向获取请求的资源。\n- 304 Not Modified ：请求的附带条件不满足，返回 304 Not Modified 不包含任何响应的主体\n- 307 Temporary Redirect ：临时性重定向。与 302 一致但不会从 POST 变成 GET。\n\n##### 4XX 客户端错误\n\n- 400 Bad Request ：请求报文中存在语法错误\n- 401 Unauthorized ：需要 HTTP 认证或者认证失败（This server could not verify that you are authorized to access the document requested. Either you supplied the wrong credentials (e.g., bad password), or your browser doesn't understand how to supply the credentials required）\n- 403 Forbidden ：对请求资源的访问被服务器拒绝了，服务器无需给出理由\n- 404 Not Found ：服务器上没有请求的资源（The request URL /a  was found on this server）\n\n##### 5XX 成功\n\n- 500 Internet Server Error\n- 503 Service Unavailable\n\n### 与 HTTP 协作的 Web 服务器\n\n一台 Web 服务器可以搭建多个独立域名的 Web 网站，也可以作为通信路径上的中转服务器提升传输效率。\n\n##### 单台主机实现多个域名\n\nHTTP/1.1允许允许一台 HTTP 服务器利用虚拟主机（Virtual  Host）搭建多个 Web 站点。\n\n当两个域名同时部署在同一个服务器上时，只会有一个 IP 地址，这时 DNS 服务器解析域名时，二者的访问 IP 地址也会相同。因此必须在 Host 首部内完成指定主机名或域名的 URI。\n\n##### 通信数据转发程序：代理、网关、隧道\n\nHTTP 通信中除了客户端和服务器以外，还有一些配合服务器工作，用于通信数据的转发的应用程序，例如代理、网关和隧道。\n\n- 代理：位于客户端和服务器中间有转发功能的应用程序。接收客户端的请求并转发给服务器，接收服务器的响应并转发给客户端。\n- 网关：转发其他服务器通信数据的服务器，接收客户端发送来的请求时，会像自己拥有资源的服务器一样对请求进行处理。\n- 隧道：在客户端和服务器两者之间进行中专，并保持双方通信连接的应用程序。\n\n###### 代理\n\n代理服务器的基本行为是接收客户端的请求后转发给其他服务器。代理不改变请求 URI ，会直接发送给源服务器。多部代理服务器可以级联，转发时，需要附加 Via 首部字段以标记出经过的主机信息。\n\n多种用途：\n\n- 利用缓存技术减少网络带宽\n- 组织内部针对特定网站的访问控制\n- 获取访问日志为主要目的\n\n两种分类基准：\n\n- 缓存代理：预先将资源的副本保存在代理服务器上，再次接受请求时不从源服务器获取资源，而是将缓存作为响应返回。\n- 透明代理：不对报文做任何加工的代理称为透明代理；对报文进行加工的代理称为非透明代理。\n\n###### 网关\n\n网关能使通信线路上的服务器提供非 HTTP 协议服务。网关能在客户端与网关之间的通信线路上加密，提高通信的安全性。\n\n###### 隧道\n\n隧道可以建立一条与其他服务器的通信连接，并使用 SSL 等加密手段进行通信，确保客户端能与服务器进行安全的通信。此外，隧道本身是透明的，隧道本身不解析 HTTP 请求，保持原样中转给之后的服务器，并自动在在通信双方断开连接时结束。\n\n##### 保存资源的缓存\n\n缓存是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可以减少对源服务器的访问，节省了通信流量和通信时间。\n\n缓存服务器是代理服务器的一种，属于缓存代理。缓存服务器可以利用缓存文件避免多次的从服务器转发资源，一方面通信时间减少，另一方面也可以同时减小服务器的压力。\n\n- 当然缓存必须是有期限，万一源服务器的资源有更新，缓存就会失效。\n- 缓存服务器需要根据客户端要求或者缓存的有效期等音速，向服务器确认确认资源的有效性。\n- 若缓存失效，将再次获取新的资源\n- 浏览器也可以存在于客户端，也会确认并更新资源的有效性。\n\n### HTTP 首部\n\n四种首部字段类型\n\n- 通用首部字段（都会使用的首部）\n- 请求首部字段（仅请求）\n- 响应首部字段（仅响应）\n- 实体首部字段（仅含有实体的报文）\n\n##### 通用首部字段\n\n- Cache-Control：控制缓存的行为\n- Connection：控制不再转发给代理的首部字段，控制持久连接\n- Date：创建 HTTP 报文的日期时间\n- Pragma：只用于请求报文中，要求所有中间服务器不返回缓存的资源\n- Trailer：记录报文主体后的首部字段\n- Transfer-Encoding：指定报文主体的编码方式\n- Upgrade：指定升级为其他通信协议\n- Via：追踪客户端和服务器之间请求和响应报文的传输路径\n- Warning：告知用户警告内容\n\n##### 请求首部字段\n\n- Accept：用户代理可处理的媒体类型以及媒体相对优先级\n- Accept-Charset：用户代理支持的字符集和字符集的相对优先顺序\n- Accept-Encoding：用户代理支持的内容编码和内容编码的优先级顺序\n- Accept-Language：用户代理能处理的自然语言集和自然语言集的相对优先级\n- Authorization：用户代理的认证信息（证书值）\n- Expect：告知服务器，期待服务器的特定行为，无法理解时返回 417 Expectation Failed\n- From：告知服务器使用用户代理的用户的电子邮箱地址\n- Host：告知服务器，请求资源所在的主机名和端口号（必须包含在请求内的首部字段）\n- If-Match：比较实体标记（Etag 与字段值匹配一致，服务器才接受请求，否则返回状态码 412）\n- If-Modified-Since：比较资源的更新时间（指定时间后有更新，接受请求，否则返回状态码 304）\n- If-None-Match：比较实体标记（与 If-Match 相反）\n- If-Range：字段值与 ETag 或更新的日期时间匹配一致，就作为范围请求处理（否则返回全部资源）\n- If-Unmodified-Since：比较资源的更新时间（与 If-Modified-Since 相反）\n- Max-Forwards：最大传输逐跳数（可经过的服务器数量，转发次数）\n- Proxy-Authorization：代理服务器要求客户端的认证信息\n- Range：范围请求时，服务器资源的字节范围\n- Referer：对请求中 URI 的原始获取方\n- TE：告知服务器客户端能够处理的响应的传输编码方式和相对优先级\n- User-Agent：HTTP 客户端程序的信息（创建请求的浏览器，用户代理名称等信息）\n\n##### 响应首部字段\n\n- Accept-Ranges：告知客户端服务器是否接受字节范围请求（可以时字段值为 bytes，否则为 none）\n- Age：由缓存服务器创建，资源经上次认证经过的时间\n- Etag：告知客户端实体标识，将资源以字符串形式做唯一性标识的方式分配 ETag\n- Location：可以将响应接收方引导至某个与请求 URI 位置不同的资源\n- Proxy-Authenticate：把由代理服务器对客户端要求的认证信息发送给客户端\n- Retry-After：告知客户端再次发起请求的时间\n- Server：当前服务器上 HTTP 服务器应用程序的信息\n- Vary：代理服务器缓存的管理信息，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。\n- WWW-Authenticate：HTTP 访问认证。访问请求 URI 制定资源的认证方案和带参数的质询。\n\n##### 实体首部字段\n\n- Allow：资源可支持的 HTTP 方法\n- Content-Encoding：实体主体适用的内容编码方式\n- Content-Language：实体主体使用的自然语言\n- Content-Length：实体主体的大小（单位字节）（内容编码时，不再使用该字段）\n- Content-Location：报文主体返回资源对应的 URI\n- Content-MD5：报文主体的 MD5 码，验证作用\n- Content-Range：实体主体的位置范围\n- Content-Type：实体主体内对象的媒体类型\n- Expires：实体主体过期的日期时间\n- Last-Modified：资源的最后修改日期时间\n\n##### 为 Cookie 服务的首部字段\n\n- Set-Cookie：开始状态管理所使用的 Cookie 信息\n- Cookie：服务器接收到的 Cookie 信息\n\n##### 其他首部字段\n\n- X-Frame-Options：响应首部，控制网站内容在其他 Web 网站的 Frame 标签内的显示问题\n- X-XSS-Protection：响应首部，针对跨站脚本攻击，控制浏览器 XSS 防护机制的开关\n- DNT：请求首部，拒绝个人信息被收集的\n- P3P：响应首部，利用 P3P 技术，让 Web 网站上的个人隐私变成仅供程序可理解的形式，保护用户隐私\n\n### HTTPS：安全的 HTTP\n\nHTTP 协议中有可能存在信息窃听或身份伪装等安全问题，使用 HTTPS 通信机制可以有效地防止这些问题。\n\n##### HTTP 的缺点\n\n- 通信使用明文，内容可能遭遇窃听\n- 不验证通信双方的身份，可能遭遇伪装\n- 无法验证报文的完整性，有可能遭遇篡改\n\n###### 通信使用明文可能会被窃听\n\n>  HTTP 协议不对通信进行加密\n\n互联网由能连通到全世界的网络组成的，通信的数据包在全网中流动传输。只要在互联网中，所有的报文信息都是全网可见的。为了保证通信的安全性，加密处理才是有效的方案。\n\n- 通信的加密（安全的通信线路）\n\nHTTP 协议没有加密机制，但是可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。\n\n- 内容的加密（安全的通信内容）\n\n客户端将 HTTP 报文进行加密处理后再发送请求。为了服从 HTTP 协议的要求，报文首部不加密而只对报文主体加密处理。客户端和服务器需要同时有加密和解密机制，但是没有安全的通信线路，内容仍有被篡改的风险。\n\n######不验证通信双方的身份就可能遭遇伪装\n\n> HTTP 协议不对请求和响应的通信双方进行确认。\n>\n> - 伪装的 Web 服务器和客户端\n> - 无访问权限的通信方\n> - 无法判定请求方\n> - Dos 攻击（Denial of Service，拒绝服务器攻击）\n\n- 查明对方的证书\n\n虽然使用 HTTP 无法确定通信方，如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用证书来验证通信方。**证书**由值得信任的第三方机构颁发根据密码学原理生成，用以证明服务器和客户端是实际存在的。有了证书，就可以证明给通信方就是期望的服务器。\n\n###### 无法证明报文完整性可能已遭篡改\n\n>  HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。（中间人攻击，Man-in-the-Middle attack，MITM）\n\nHTTP 协议存在的确定报文完整性的方法并不便捷、可靠，常用的是 MD5 和 SHA-1 等散列值校验方法和确认文件的数字签名方法。使用这些方法也无法确保结果正确，因为校验值本可能被改写。\n\n**为了防止这三个弊端，因此需要使用 HTTPS。**\n\n##### HTTPS = HTTP + 加密 + 认证 + 完整性保护\n\nHTTPS 不是新的协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。\n\n- 一般情况下，HTTP 直接与 TCP 通信。\n- 采用 SSL 时，HTTP 就先与 SSL 通信，再由 SSL 和 TCP 通信。\n\n##### 对称加密和非对称加密\n\n对称加密指的是加密和解密同用一个密钥的加密方式：\n\n- 密钥对于任何一方都是一样的\n- 任何人只要持有密钥就可以加密和解密\n- 密钥必须安全地提前发给对方\n- 安全性的漏洞在于通信过程必须安全地告知对方\n\n非对称加密指的是加密和解密同用一对非对称密钥的加密方式：\n\n- 密钥分为公钥和私钥，公钥对所有人公开，私钥由接收方单独持有\n- 持有公钥可以加密，持有私钥可以解密\n- 只要将公钥公开交付，交由发送方加密\n- 缺点是加密解密的速度更慢\n\n实际上，两种加密机制都有缺点，对称加密无法安全传输密钥，非对称加密的加密过程耗时更多，HTTPS 采用的是两种机密方式并用的混合加密机制。\n\n- 使用非对称加密安全地交换对称加密中的密钥；\n- 建立通信后，再使用对称加密方式；\n\n###### 证书证明公开密钥的真实性\n\n证书的作用是证明公开密钥的真实性。\n\n数字证书认证机构是对于客户端和服务器都可信任的第三方机构，专门颁发公开密钥的数字证书。服务器将服务器申请的公开密钥做数字签名，这就是数字证书。数字签名是使用数字证书认证机构的私钥加密的，这能证明文件是从数字证书认证机构颁发的。\n\n服务器将数字证书发送至客户端，客户端可以用数字机构的公开密钥验证，一旦验证就知道认证机构和服务器的公开密钥有效。\n\n###### HTTPS 安全通信机制\n\n> 对于一个主机来说，要想保证绝对的通信安全，唯一可信的只有自己。\n\n在只有主机可信的前提下，怎样建立安全的通信机制。万幸浏览器帮了我们一个大忙，多数浏览器都会实现在内部植入常用认证机关的公开密钥。\n\n- 浏览器事先植入认证机构公钥\n- 服务器向客户端发送公钥证书\n- 客户端用认证机构的公钥确认证书的真实性\n- 客户端取出服务器公钥\n- 客户端使用服务器的公钥加密\n- 服务器用私钥解密实现安全通信\n\n\n### 确认访问用户的身份\n\n> 某些 Web 页面需要有一些权限，这就需要认证功能。\n\nHTTP/1.1 使用的认证方式\n\n- BASIC 认证（基本认证）\n- DIGEST 认证（摘要认证）\n- SSL 客户端认证\n- FormBase 认证（基于表单认证）\n\n###### BASIC 认证\n\nBASIC 认证虽然采用 Base64 编码方式，这只是编码方式，不需要任何信息就可以解码。在非 HTTP 的线路上使用 BASIC 认证是很不安全的。此外，浏览器无法注销操作，认证使用上不够灵活。因此 BASIC 认证并不常用。\n\n###### DIGEST 认证\n\nDIGEST 认证是使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。质询/响应的方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方接收到的质询码计算生成响应码。最后向响应码返回给对方进行认证的方式。相比 BASIC 认证，安全性更高。\n\n###### SSL 客户端认证\n\nSSL 客户端使用 HTTPS 的客户端证书完成认证。客户端证书由安全性极高的认证机构颁发，但需要支付一定的费用。以客户端证书进行客户端认证，足以证明服务器正在通信的对方是预料的客户端。\n\nSSL 客户端认证不仅依靠证书完成认证，一般会和基于表单认证组合使用一种双因素认证来使用。SSL 客户端证书用来认证客户端计算机，基于表单认证用来确定这时本人的行为。\n\n###### 基于表单认证\n\n基于表单认证并不是在 HTTP 协议中定义，客户端会像服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果验证。BASIC 认证和 DIGEST 认证安全性和便利性都不够，SSL 客户端足够安全但成本过高，基于表单认证足够安全，也不需要一定的标准规范，因此比较常见。\n\n###### Session 管理及 Cookie 应用\n\n基于表单认证的标准的缺点是 HTTP 的无协议特性，无法实现状态管理，因此使用 Cookie 管理 Session（会话）。\n\n客户端发送已登陆信息，服务器向用户发放 Session ID 记录认证状态，之后通过验证 Session ID 来判定对方是真实用户。\n\n### 基于 HTTP 的功能追加协议\n\n##### HTTP 瓶颈\n\n基于 HTTP 协议无法做到实时更新 Web 页面上的内容。\n\nHTTP 的一些标准会成为瓶颈：\n\n- 一条连接上只可发送一个请求。\n- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。\n- 请求/响应首部未经压缩就发送。首部信息越多延迟越大。\n- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。\n- 可任意选择数据压缩格式。非强制压缩发送。\n\n###### Ajax 的解决方法\n\nAjax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文件对象模型）达到局部 Web 页面替换加载的异步通信手段（只更新部分页面，减少响应中传输的数据量）。\n\n###### Comet 的解决方案\n\nComet 延迟响应，挂起状态，直至内容更新返回响应。\n\n这一过程模拟了服务器向客户端推送（Server Push）功能。尽管 Comet 实现了实时更新，但维持连接消耗更多资源，仍未解决 HTTP 协议的问题。\n\n##### SPDY 缩短 Web 页面的加载时间\n\nSPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，同时 SPDY 规定通信中使用 SSL。\n\nHTTP 处于应用层，SPDY 会话层，SSL 处于表示层，TCP 处于传输层。\n\n使用 SPDY 后，HTTP 协议额外获得一些功能：\n\n- 多用复用流：一次 TCP 连接可以无限制处理多个 HTTP 请求，效率提高。\n- 赋予请求优先级：SPDY 可以给请求分配优先级顺序，解决带宽低而相应变慢的问题。\n- 压缩 HTTP 首部：减少通信数据包的字节数。\n- 推送功能：支持服务器主动向客户端推送功能。\n- 服务器提示功能：服务器可以主动提示客户端所需的资源。\n\n##### 使用浏览器进行全双工通信的 WebSocket\n\n利用 Ajax 和 Comet 级数进行通信可以提升 Web 的浏览速度，WebSocket 网络技术是避免 HTTP 的瓶颈的新协议及 API。WebSocket 既支持服务器向客户端推送数据，也支持持续保持 WebSocket 连接，以更短的首部减少通信量。\n\nWebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行，通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式，并且双方都可以直接向对方发送报文。\n\n###### 握手·请求\n\n为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。\n\n```http\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n\n- Sec-WebSocket-Key：记录握手过程中必不可少的键值\n- Sec-WebSocket-Protocol：记录使用的子协议\n\n###### 握手·响应\n\n响应 WebSocket 通信，返回的状态码为 101 Switching Protocols。\n\n```http\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgeade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\nSec-WebSocket-Protocol: chat\n```\n\nSec-WebSocket-Accept 的值根据握手请求中 Sec-WebSocket-Key 的字段值生成。成功握手确立 WebSocket 连接之后，通信时不在使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。\n\n###### WebSocket API\n\nJavaScript 可调用 “The WebSocket API” 内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。\n\n```javascript\nvar socket = new WebSocket('ws://game.example.com:12010/updates');\nsocket.onopen = function(){\n    setInterval(function(){\n        if (socket.bufferedAmount == 0)\n            socket.send(getUpdateData());\n    }, 50);\n};\n```\n\n##### Web 服务器管理文件的 WebDAV\n\nWebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行进行文件复制、编辑等操作的分布式文件系统。\n\nHTTP/1.1的 PUT 方法和 DELETE 方法，可以对 Web 服务器上的文件进行创建和删除操作，出于安全性和便捷性一般不使用。\n\nWebDAV 新增加的概念：\n\n- 集合（Collection）：一种统一管理多个资源的概念。以集合为单位可进行各种操作，也可实现类似集合的集合这样的操作。\n- 资源（Resource）：文件或集合称为资源。\n- 属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。\n- 锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。\n\n###### WebDAV 新增的方法\n\n- PROPFIND：获取属性\n- PROPPATCH：修改属性\n- MKCOL：创建集合\n- CPOY：复制资源及属性\n- MOVE：移动资源\n- LOCK：资源加锁\n- UNLOCK：资源解锁\n\n###### WebDAV 拓展的状态码\n\n- 102 Processing：可正常处理请求，但目前是处理中状态\n- 207 Muti-Status：存在多种状态\n- 422 Unprocessible Entity：格式正确，内容有误\n- 423 Locked：资源已被加锁\n- 424 Failed Dependency：处理与某请求关联的请求失败，因此维持依赖关系\n- 507 Insufficient Storage：保存空间不足\n\n### 构建 Web 内容的技术\n\n##### HTML\n\n###### 超文本标记语言 HTML \n\nHTML（HyperText Markup Language，超文本标记语言）是一种标记语言。标记语言通过标签控制构建 Web 页面\n\n###### 层叠样式表 CSS\n\nCSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素。\n\n##### 动态 HTML\n\n动态 HTML（Dynamic HTML）值使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。\n\n###### 客户端脚本语言 JavaScript \n\n动态 HTML 调用客户端脚本语言 JavaScript 实现对 HTML 的 Web 页面的动态改造；\n\n###### 文档对象模型 DOM\n\nDOM 将 HTML 内的元素当作对象操作，指定欲发生动态变化的 HTML 元素。\n\n##### Web 应用\n\n###### Web 应用作用于动态内容之上\n\n由程序创建的内容为动态内容；事先准备好的内容称为静态内容。Web 应用作用于动态内容上。\n\n###### 与 Web 服务器及程序协作的 CGI\n\nCGI（Common Gateway Interface，通用网关接口）是 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。（CGI 程序一般用 Perl、PHP、Ruby 和 C 等编程语言编写而成）\n\n###### 因 JAVA 而普及的 Servlet\n\nServlet 是一种能在服务器创建动态内容的程序，是用 JAVA 语言实现的一个接口。\n\n> Servlet 常驻内存，CGI 程序则需要不断启动。\n\n##### 数据发布的格式及语言\n\n###### 可拓展标记语言\n\nXML（eXtensible Markup Language，可拓展标记语言）是一种可按应用目标进行拓展的通用标记语言。\n\n> HTML 更适合显示 Web 页面，XML 更适合数据交换。\n\n###### 发布更新信息的 RSS/Atom\n\nRSS（建议信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。\n\n###### JavaScript 衍生的轻量级易用 JSON\n\nJSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。JSON 字符串形式可以被 JavaScript 轻易读入，能处理 false / null / true / 对象 / 数组 / 数字 / 字符串这七类数据。\n\n### Web 的攻击技术\n\n##### 针对 Web 的攻击技术\n\n###### HTTP 不具备必要的安全功能\n\nHTTP 是一个纯粹的通信协议，无法应对针对 Web 的攻击。开发者需要自行设计并开发认证及会话管理来满足 Web 应用的安全，这样也可能会有安全漏洞。\n\n###### 在客户端即可篡改请求\n\n浏览器接收到的 HTTP 请求的全部内容都可以在客户端自由更变、篡改。若 Web 应用有漏洞，服务器的信息将被窃取，权限被夺取。\n\n##### 针对 Web 应用的攻击模式\n\n- 以服务器为目标的主动攻击：直接访问 Web 应用，传入攻击代码。\n- 以服务器为目标的被动攻击：不直接对 Web 应用访问，而利用圈套策略执行攻击代码。\n\n##### 因输出值转义不完全引发的安全漏洞\n\n- 跨站脚本攻击：通过存在安全漏洞的 Web 网站用户的浏览器内运行 HTML 标签或 JavaScript 进行攻击。\n- SQL 注入攻击：针对 Web 应用使用的数据库，通过运行非法的 SQL 产生攻击。\n- OS 命令注入攻击：通过 Web 应用，执行非法的操作系统命令达到攻击的目的。\n- HTTP 首部注入攻击：攻击者通过在相应首部字段内插入换行，添加任意相应首部或主体的攻击。\n- 邮件首部注入攻击：攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。\n- 目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后达成访问目的。\n- 远程文件包含漏洞：利用外部服务器的 URL 充当以来文件，让脚本读取后，运行任意脚本的一种攻击。\n\n##### 因设置和设计上的缺陷引发的安全漏洞\n\n- 强制浏览：从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。\n- 不正确的错误消息处理：Web 应用的错误消息内包含对攻击者有用的信息。\n- 开放重定向：对指定的任意的 URL 作重定向跳转值特定的 Web 网站。\n\n##### 因会话管理疏忽引发的安全漏洞\n\n- 会话挟持：攻击者窃取用户的会话 ID，并非法使用次会话 ID 伪装成用户达到攻击目的。\n- 会话固定攻击：强制用户使用攻击者指定的会话 ID\n- 跨站点请求伪造：攻击者通过设置好的陷阱强制对已完成认证的用户进行某些状态更新。\n\n##### 其他安全漏洞\n\n- 密码破解：算出密码，突破认证。\n- 点击挟持：利用透明的按钮或连接做成陷阱，覆盖在 Web 页面上，诱使用户访问特定内容。\n- DoS 攻击：让运行中的服务呈停止状态。（过量请求或安全漏洞使服务器过载）\n- 后门程序：开发设置的隐藏入口，可不按正常步骤使用受限功能。\n\n","slug":"HTTP-学习笔记","published":1,"updated":"2020-03-15T21:05:07.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wj000n29fyup7w0gqg","content":"<h3 id=\"Web-页面的实现\"><a href=\"#Web-页面的实现\" class=\"headerlink\" title=\"Web 页面的实现\"></a>Web 页面的实现</h3><h5 id=\"Web-基于-HTTP-协议通信\"><a href=\"#Web-基于-HTTP-协议通信\" class=\"headerlink\" title=\"Web 基于 HTTP 协议通信\"></a>Web 基于 HTTP 协议通信</h5><blockquote>\n<p>客户端（Client）的 Web 浏览器从 Web 服务器端获取文件资源等信息 。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n\n\n<ol>\n<li>浏览器的地址栏输入 URL</li>\n<li>URL 信息送往某处</li>\n<li>从某处得到回复</li>\n<li>将回复内容显示在 Web 页面上</li>\n</ol>\n<p>Web 建立在 <strong>HTTP 协议</strong>（HyperText Transfer Protocol，超文本传输协议）实现通信。</p>\n<p>目前主流的 HTTP 版本：HTTP/1.1</p>\n<h5 id=\"TCP-IP-网络层\"><a href=\"#TCP-IP-网络层\" class=\"headerlink\" title=\"TCP/IP 网络层\"></a>TCP/IP 网络层</h5><p>网络分层：</p>\n<ul>\n<li>设计各层之间接口，若需要改变设计只需改动有变动的层</li>\n<li>简化设计，只需完成该层的任务</li>\n</ul>\n<p>位于应用层的 HTTP 数据每经过一层就会打上属于该层的首部信息，这一过程称为<strong>封装</strong>。</p>\n<ol>\n<li><p><strong>IP</strong> （Internet Protocol）网际协议位于网络层，任务是传输数据包。</p>\n<p>IP 协议中有两种地址：IP 地址和 MAC 地址（Media Access Control Address）</p>\n</li>\n</ol>\n<ul>\n<li>IP 地址：网络中分配到的地址，全网唯一；（IP 地址分段，就像邮编决定数据流动的方向）</li>\n</ul>\n<ul>\n<li>MAC 地址：每个网卡固定有一个 MAC 地址，无法改变。（ARP 协议用于解析 IP 地址，得到 MAC 地址）</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>TCP</strong> 位于传输层：提供通过可靠的字节流服务。</p>\n<p>TCP 的可靠传输：三次握手策略（SYN 和 ACK）</p>\n</li>\n</ol>\n<ul>\n<li>发送端发送 SYN  标志的数据包；</li>\n</ul>\n<ul>\n<li>接收端回传 SYN/ACK 标志的数据包传达确认信息；</li>\n<li>发送端再回传一个 ACK 标志的数据包；</li>\n</ul>\n<h5 id=\"DNS-服务\"><a href=\"#DNS-服务\" class=\"headerlink\" title=\"DNS 服务\"></a>DNS 服务</h5><p><strong>DNS</strong> （Domain Name System）服务是位于应用层，可以提供域名解析服务。</p>\n<p>在网络中，每个主机都有唯一的 IP 地址，在互联网中我们却不太可能全部使用一串数字来记住网站，我们使用的是<strong>域名</strong>。</p>\n<ul>\n<li>计算机网络使用 IP 地址来实现网络中数据的传输。</li>\n<li>用户使用域名来访问网站。</li>\n<li>用户通过访问 DNS 服务器询问域名的 IP 地址，取得 IP 地址后，就可以通过 IP 地址访问。</li>\n</ul>\n<h5 id=\"URL-和-URI\"><a href=\"#URL-和-URI\" class=\"headerlink\" title=\"URL 和 URI\"></a>URL 和 URI</h5><ul>\n<li>URL（Uniform Resource Locator，统一资源定位符）访问网页时需要输入的网页地址，表示资源的地点。</li>\n<li>URI（Uniform Resource Identifier，统一资源标识符）用字符串标识某一互联网资源。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://user:pass@www.example.jp:80/dir/index/htm?uid=1#ch1</span><br></pre></td></tr></table></figure>\n\n<p>URI 格式依次由：协议方案、登陆信息、服务器地址、服务器端口号、带层次的文件路径、查询字符串和片段标识符构成。</p>\n<h3 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h3><h5 id=\"客户端和服务器\"><a href=\"#客户端和服务器\" class=\"headerlink\" title=\"客户端和服务器\"></a>客户端和服务器</h5><p>HTTP 协议中，必然是一方为客户端，一方为服务器。</p>\n<ul>\n<li>客户端：请求访问文本或图像等资源的一端；</li>\n<li>服务器端：提供资源响应的一端；</li>\n</ul>\n<blockquote>\n<p>通信的双方是不对等的，因此在通信过程中，通常上行速度比下载速度慢很多。</p>\n</blockquote>\n<h5 id=\"请求和响应\"><a href=\"#请求和响应\" class=\"headerlink\" title=\"请求和响应\"></a>请求和响应</h5><p>客户端和服务器端通过请求和响应的交换达成通信。</p>\n<ul>\n<li>客户端先发送请求；</li>\n<li>服务器再发送响应；</li>\n<li>服务器本身无法在没有请求时发送响应</li>\n</ul>\n<ol>\n<li>客户端发送请求</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>起始行的 GET 表示请求访问的方法（method）；</li>\n<li>字符串 /index.htm 指明了请求访问的资源对象，就是请求 URI（request-URI）；</li>\n<li>HTTP/1.1 为客户端 HTTP 版本号；</li>\n<li>也就是说，向主机名为 hackr.jp 的服务器请求 /index.hem 页面资源。</li>\n<li>总的来说，请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成。</li>\n</ul>\n<ol start=\"2\">\n<li>服务器发送响应</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 362</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>HTTP/1.1 为服务器对应的 HTTP 版本。</li>\n<li>200 OK 为请求的处理结果的状态码（status code）和原因短语（reason-phrase）</li>\n<li>之后的为首部字段（header field）</li>\n<li>空一行之后为资源的主体（entity body）</li>\n<li>响应报文由协议版本、状态码、原因短语、首部字段和实体主题</li>\n</ul>\n<h5 id=\"Cookie-解决状态问题\"><a href=\"#Cookie-解决状态问题\" class=\"headerlink\" title=\"Cookie 解决状态问题\"></a>Cookie 解决状态问题</h5><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存。这样一来，服务器只需要专一化的处理响应 HTTP 请求即可，减少了服务器 CPU 和内存的消耗。</p>\n<p>当然 Web 网络中状态管理还是很重要的，如果网站每次都要重新登录和重新认证，结果是很糟糕的。Cookie 技术会在请求和响应报文中加入 Cookie 信息来控制客户端的状态。</p>\n<ol>\n<li>没有 Cookie 时发出请求</li>\n</ol>\n<ul>\n<li>客户端向服务器发出请求</li>\n<li>服务器通过生成 Cookie 信息（这一时刻记住了客户端信息）</li>\n<li>在响应中添加 Set-Cookie 的首部字段信息。</li>\n<li>服务器回复响应</li>\n<li>客户端收到后就把 Cookie 保存起来。</li>\n</ul>\n<ol start=\"2\">\n<li>有 Cookie 状态信息时发出请求</li>\n</ol>\n<ul>\n<li>客户端主动在请求报文中添加 Cookie 信息</li>\n<li>客户端向服务器发出请求</li>\n<li>服务器检查 Cookie 信息</li>\n<li>服务器回复响应</li>\n</ul>\n<h5 id=\"请求-URI-定位网络资源\"><a href=\"#请求-URI-定位网络资源\" class=\"headerlink\" title=\"请求 URI 定位网络资源\"></a>请求 URI 定位网络资源</h5><p>HTTP 协议使用 URI 定位互联网上的资源，客户端访问请求资源发送请求时，需要在请求报文中添加 URI 。</p>\n<ol>\n<li>使用完整的请求 URI</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 Host 首部字段写明网络域名或 IP 地址</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用 * 来代替 URI 只访问服务器</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">OPTIONS</span> <span class=\"string\">*</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HTTP-方法告知服务器意图\"><a href=\"#HTTP-方法告知服务器意图\" class=\"headerlink\" title=\"HTTP 方法告知服务器意图\"></a>HTTP 方法告知服务器意图</h5><ul>\n<li>GET ：获取资源</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n<p>返回 index.html 的页面资源。</p>\n<ul>\n<li>POST ：传输实体主体</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">POST</span> <span class=\"string\">/submit.cgi</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">Content-length</span>: 1560</span><br></pre></td></tr></table></figure>\n\n<p>返回 submit.cgi 接收数据的处理结果</p>\n<ul>\n<li>PUT ：传输文件</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">PUT</span> <span class=\"string\">/example.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 1560</span><br></pre></td></tr></table></figure>\n\n<p>向服务器上传文件，存在安全性问题，一般不使用，需要 Web 验证机制。</p>\n<ul>\n<li>HEAD ：获得报文首部</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">HEAD</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n<p>告知服务器无需返回报文主体部分，确认 URI 的有效性及资源更新日期时间。</p>\n<ul>\n<li>DELETE ：删除文件</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"string\">/example.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n<p>删除服务器上的资源，存在安全性问题，一般不使用，需要 Web 验证机制。</p>\n<ul>\n<li><p>OPTIONS ：询问支持的方法</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">OPTIONS</span> <span class=\"string\">*</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>针对服务器查询针对请求 URI 指定的资源支持的方法。</p>\n<ul>\n<li><p>TRACE ：追踪路径</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">TRACE</span> <span class=\"string\">/</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">Max-Forward</span>: 2</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>让 Web 服务器端将之前的请求通信环回给客户端，不常使用，可能引起跨站追踪（Cross-Site Tracing）。</p>\n<p>添加 Max-Forward 首部字段的数值，每经过服务器数值减一，数值为 0 的服务器返回状态码 200 OK 的响应。</p>\n<ul>\n<li><p>CONNECT ：要求用隧道协议连接代理</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CONNECT</span> <span class=\"string\">proxy.hackr.jp:8080</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: proxy.hackr.jp</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>要求与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。</p>\n<p>主要使用 SSL（Secure Sockets Layer，安全套接层）和 TSL（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h5 id=\"HTTP-方法指挥服务器\"><a href=\"#HTTP-方法指挥服务器\" class=\"headerlink\" title=\"HTTP 方法指挥服务器\"></a>HTTP 方法指挥服务器</h5><p>使用方法作为命令来向服务器下达命令，可以指定请求的资源的行为。</p>\n<ul>\n<li>HTTP/1.0：GET、POST、PUT、HEAD、DELETE、LINK、UNLINK（HTTP/1.1删除 LINK 和 UNLINK）</li>\n<li>HTTP/1.1：GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT</li>\n</ul>\n<h5 id=\"持久连接减少通信量\"><a href=\"#持久连接减少通信量\" class=\"headerlink\" title=\"持久连接减少通信量\"></a>持久连接减少通信量</h5><p>原始的 Web 页面信息很少，每进行一次 HTTP 通信就建立一次 TCP 连接。</p>\n<ul>\n<li>建立 TCP 连接</li>\n<li>HTTP 请求</li>\n<li>HTTP 响应</li>\n<li>断开 TCP 连接</li>\n</ul>\n<p>通信过程：建立 - 请求 - 响应 - 断开</p>\n<p>如果一个页面包含大量数据，那就需要建立多次请求。每次请求又会重新断开和建立 TCP 连接，这就造成了许多无谓的开销。</p>\n<p>通信过程：建立 - 请求 - 响应 - 断开 - 建立 - 请求 - 响应 - 断开 - …</p>\n<p>解决方案一：<strong>持久连接</strong></p>\n<p><strong>持久连接</strong>（HTTP Persistent Connection，也称为 HTTP keep-alive 或者 HTTP connection reuse）的特点是只要任意一方提出断开连接，则保持 TCP 连接状态。这样的好处在于在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载；同时也减少了传输所用的时间，加快了 Web 页面的显示速度</p>\n<p>通信过程：建立 - 请求 - 响应 - 请求 - 响应 - … - 请求 - 响应 - 断开</p>\n<p>解决方案二：<strong>管线化</strong></p>\n<p><strong>管线化技术</strong>允许客户端无需等待响应可以直接发送下一个请求。这样一来就可以做到同时并行发送多个请求，而不需要等待响应。</p>\n<p>通信过程：建立 - 请求 1 - 请求 2 - 响应 1 - 响应 2 - 断开</p>\n<h3 id=\"HTTP-报文信息\"><a href=\"#HTTP-报文信息\" class=\"headerlink\" title=\"HTTP 报文信息\"></a>HTTP 报文信息</h3><h5 id=\"HTTP-报文\"><a href=\"#HTTP-报文\" class=\"headerlink\" title=\"HTTP 报文\"></a>HTTP 报文</h5><p>HTTP 报文是用于 HTTP 协议交互的信息，是由多行数据构成的字符串文本 。客户端发出请求报文，服务器端回复响应报文。</p>\n<p>HTTP 报文分为报文首部和报文主体两部分。二者由空行（CR+LF）来划分。通常，并不一定需要报文主体。</p>\n<ul>\n<li>报文首部：服务器端或客户端需处理的请求或响应的内容及属性。</li>\n<li>空行 CR + LF：CR（Carriage Return，回车符：0x0d）和 LF（Line Feed，换行符：0x0a）</li>\n<li>报文主体：应被发送的数据。</li>\n</ul>\n<h5 id=\"请求报文和响应报文结构\"><a href=\"#请求报文和响应报文结构\" class=\"headerlink\" title=\"请求报文和响应报文结构\"></a>请求报文和响应报文结构</h5><h6 id=\"请求报文结构\"><a href=\"#请求报文结构\" class=\"headerlink\" title=\"请求报文结构\"></a>请求报文结构</h6><ul>\n<li>请求报文 = 请求报文的首部 + 空行 + 报文主体</li>\n<li>请求报文首部 = 请求行 + 请求首部字段 + 通用首部字段 + 实体首部字段 + 其他</li>\n</ul>\n<h6 id=\"请求报文实例\"><a href=\"#请求报文实例\" class=\"headerlink\" title=\"请求报文实例\"></a>请求报文实例</h6><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv13.0) Geoko/20100101 Firefox/13.0.1</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span>: ja,en-us;q=0.7,en;q=0.3</span><br><span class=\"line\"><span class=\"attribute\">Accept-Encoding</span>: gzip, deflate</span><br><span class=\"line\"><span class=\"attribute\">DNT</span>: 1</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Pragma</span>: no-cache</span><br><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: co-cache</span><br><span class=\"line\"> (空行：CR+LF)</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"响应报文结构\"><a href=\"#响应报文结构\" class=\"headerlink\" title=\"响应报文结构\"></a>响应报文结构</h6><p>响应报文 = 响应报文的首部 + 空行 + 报文主体</p>\n<p>响应报文首部 = 状态行 + 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他</p>\n<h6 id=\"响应报文实例\"><a href=\"#响应报文实例\" class=\"headerlink\" title=\"响应报文实例\"></a>响应报文实例</h6><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Fri, 13 Jul 2012 02:45:26 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: Apache</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">ETag</span>: \"45bael-16a-46d776ac\"</span><br><span class=\"line\"><span class=\"attribute\">Accept-Range</span>: bytes</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 362</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: close</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"> (空行：CR+LF)</span><br><span class=\"line\">&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;</span><br><span class=\"line\">&lt;title&gt;hackr.jp&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;img src=\"hackr.gif\" alt=\"hackr.jp\" width=\"240\" height=\"84\" /&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>报文的组成</p>\n<ul>\n<li>请求行：请求的方法，请求 URI 和 HTTP 版本</li>\n<li>状态行：响应结果的状态码，原因短语和 HTTP 版本。</li>\n<li>首部字段：请求首部（或响应首部）、通用首部和实体首部</li>\n<li>其他：HTTP 的 RFC 未定义的首部</li>\n</ul>\n<h5 id=\"编码提升传输速率\"><a href=\"#编码提升传输速率\" class=\"headerlink\" title=\"编码提升传输速率\"></a>编码提升传输速率</h5><p>HTTP 协议可以通过计算机编码来压缩或分割传输的内容，提升传输的速率。同样地，编码需要额外消耗计算机资源。</p>\n<h6 id=\"报文主体和实体主体\"><a href=\"#报文主体和实体主体\" class=\"headerlink\" title=\"报文主体和实体主体\"></a>报文主体和实体主体</h6><p>报文是 HTTP 通信的基本单位，由 8 位组字节流组成，通过 HTTP 通信。</p>\n<p>实体作为响应或请求的有效载荷数据被传输，其内容有实体首部和实体主体组成。</p>\n<ul>\n<li>对于没有编码的情况，报文主体等于实体主体；</li>\n<li>对于有编码的情况，报文主体为实体主体编码之后的产物；</li>\n</ul>\n<p>内容编码和分块传输编码</p>\n<ul>\n<li><p><strong>内容编码</strong>指明应用在实体内容上的编码格式，并保持尸体信息原样压缩。压缩编码后的实体有客户端接收并负责解码。</p>\n</li>\n<li><p><strong>分块传输编码</strong>通过把数据分割成多块，让大容量数据分块逐步显示在 Web 页面上。</p>\n<h6 id=\"多部分对象集合\"><a href=\"#多部分对象集合\" class=\"headerlink\" title=\"多部分对象集合\"></a>多部分对象集合</h6></li>\n</ul>\n<p>MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件拓展）允许邮件处理文本、图片、视频等多个不同类型的数据。多部分对象集合最早应用在可以添加多份附件的邮件系统中，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体中可以含有多类型实体。</p>\n<p>包含的对象如下：</p>\n<ul>\n<li>multipart/from-data：在 Web 表单上传文件时使用</li>\n<li>multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</li>\n</ul>\n<h6 id=\"获取部分内容的范围请求\"><a href=\"#获取部分内容的范围请求\" class=\"headerlink\" title=\"获取部分内容的范围请求\"></a>获取部分内容的范围请求</h6><p><strong>断点续传</strong>是解决大容量传输的另一个方案：为了避免下载中断的引起下载任务从头开始，需要从下载中断处回复下载的机制。实现这样的功能的请求为<strong>范围请求</strong>，范围请求可以通过首部字段 Range 来指定下载的实体字节范围。</p>\n<p>范围请求实例</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/tip.jpg</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.usaidesign.jp</span><br><span class=\"line\"><span class=\"attribute\">Range</span>: bytes =5001-10000</span><br></pre></td></tr></table></figure>\n\n<p>范围请求的响应</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">206</span> Partial Content</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Fri, 13 Jul 2012 04:29:17 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Range</span>: bytes 5001-10000/10000</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 5000</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别地，追对范围请求</p>\n<ul>\n<li>响应范围请求时，服务器返回状态码 206 Partial Content</li>\n<li>无法响应范围请求时，服务器返回状态码 200 OK </li>\n</ul>\n</blockquote>\n<h6 id=\"内容协商机制\"><a href=\"#内容协商机制\" class=\"headerlink\" title=\"内容协商机制\"></a>内容协商机制</h6><p><strong>内容协商机制</strong>是指客户端和服务器之间就相应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p>\n<p>内容协商技术有三种类型：</p>\n<ul>\n<li>服务器驱动协商</li>\n<li>客户端驱动协商</li>\n<li>透明协商</li>\n</ul>\n<p>在请求报文中通过使用以下首部字段：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n<h3 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h3><p>状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h5 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h5><ul>\n<li>200 OK ：请求被正常处理了</li>\n<li>204 No Content ：接受的请求已经处理，但返回的报文中不包含主体</li>\n<li>206 Partial Content ：服务器正常响应了范围请求</li>\n</ul>\n<h5 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h5><ul>\n<li>301 Moved  Permanently ： 永久性重定向。客户端应该使用新的 URI </li>\n<li>302 Found ：临时性重定向。用户（本次）应当使用新的 URI 访问（尽管禁止 POST 改 GET，实际还是这样操作）</li>\n<li>303 See Other ：由于请求对应的资源存在另一个 URI ，应使用 GET 方法定向获取请求的资源。</li>\n<li>304 Not Modified ：请求的附带条件不满足，返回 304 Not Modified 不包含任何响应的主体</li>\n<li>307 Temporary Redirect ：临时性重定向。与 302 一致但不会从 POST 变成 GET。</li>\n</ul>\n<h5 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h5><ul>\n<li>400 Bad Request ：请求报文中存在语法错误</li>\n<li>401 Unauthorized ：需要 HTTP 认证或者认证失败（This server could not verify that you are authorized to access the document requested. Either you supplied the wrong credentials (e.g., bad password), or your browser doesn’t understand how to supply the credentials required）</li>\n<li>403 Forbidden ：对请求资源的访问被服务器拒绝了，服务器无需给出理由</li>\n<li>404 Not Found ：服务器上没有请求的资源（The request URL /a  was found on this server）</li>\n</ul>\n<h5 id=\"5XX-成功\"><a href=\"#5XX-成功\" class=\"headerlink\" title=\"5XX 成功\"></a>5XX 成功</h5><ul>\n<li>500 Internet Server Error</li>\n<li>503 Service Unavailable</li>\n</ul>\n<h3 id=\"与-HTTP-协作的-Web-服务器\"><a href=\"#与-HTTP-协作的-Web-服务器\" class=\"headerlink\" title=\"与 HTTP 协作的 Web 服务器\"></a>与 HTTP 协作的 Web 服务器</h3><p>一台 Web 服务器可以搭建多个独立域名的 Web 网站，也可以作为通信路径上的中转服务器提升传输效率。</p>\n<h5 id=\"单台主机实现多个域名\"><a href=\"#单台主机实现多个域名\" class=\"headerlink\" title=\"单台主机实现多个域名\"></a>单台主机实现多个域名</h5><p>HTTP/1.1允许允许一台 HTTP 服务器利用虚拟主机（Virtual  Host）搭建多个 Web 站点。</p>\n<p>当两个域名同时部署在同一个服务器上时，只会有一个 IP 地址，这时 DNS 服务器解析域名时，二者的访问 IP 地址也会相同。因此必须在 Host 首部内完成指定主机名或域名的 URI。</p>\n<h5 id=\"通信数据转发程序：代理、网关、隧道\"><a href=\"#通信数据转发程序：代理、网关、隧道\" class=\"headerlink\" title=\"通信数据转发程序：代理、网关、隧道\"></a>通信数据转发程序：代理、网关、隧道</h5><p>HTTP 通信中除了客户端和服务器以外，还有一些配合服务器工作，用于通信数据的转发的应用程序，例如代理、网关和隧道。</p>\n<ul>\n<li>代理：位于客户端和服务器中间有转发功能的应用程序。接收客户端的请求并转发给服务器，接收服务器的响应并转发给客户端。</li>\n<li>网关：转发其他服务器通信数据的服务器，接收客户端发送来的请求时，会像自己拥有资源的服务器一样对请求进行处理。</li>\n<li>隧道：在客户端和服务器两者之间进行中专，并保持双方通信连接的应用程序。</li>\n</ul>\n<h6 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h6><p>代理服务器的基本行为是接收客户端的请求后转发给其他服务器。代理不改变请求 URI ，会直接发送给源服务器。多部代理服务器可以级联，转发时，需要附加 Via 首部字段以标记出经过的主机信息。</p>\n<p>多种用途：</p>\n<ul>\n<li>利用缓存技术减少网络带宽</li>\n<li>组织内部针对特定网站的访问控制</li>\n<li>获取访问日志为主要目的</li>\n</ul>\n<p>两种分类基准：</p>\n<ul>\n<li>缓存代理：预先将资源的副本保存在代理服务器上，再次接受请求时不从源服务器获取资源，而是将缓存作为响应返回。</li>\n<li>透明代理：不对报文做任何加工的代理称为透明代理；对报文进行加工的代理称为非透明代理。</li>\n</ul>\n<h6 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h6><p>网关能使通信线路上的服务器提供非 HTTP 协议服务。网关能在客户端与网关之间的通信线路上加密，提高通信的安全性。</p>\n<h6 id=\"隧道\"><a href=\"#隧道\" class=\"headerlink\" title=\"隧道\"></a>隧道</h6><p>隧道可以建立一条与其他服务器的通信连接，并使用 SSL 等加密手段进行通信，确保客户端能与服务器进行安全的通信。此外，隧道本身是透明的，隧道本身不解析 HTTP 请求，保持原样中转给之后的服务器，并自动在在通信双方断开连接时结束。</p>\n<h5 id=\"保存资源的缓存\"><a href=\"#保存资源的缓存\" class=\"headerlink\" title=\"保存资源的缓存\"></a>保存资源的缓存</h5><p>缓存是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可以减少对源服务器的访问，节省了通信流量和通信时间。</p>\n<p>缓存服务器是代理服务器的一种，属于缓存代理。缓存服务器可以利用缓存文件避免多次的从服务器转发资源，一方面通信时间减少，另一方面也可以同时减小服务器的压力。</p>\n<ul>\n<li>当然缓存必须是有期限，万一源服务器的资源有更新，缓存就会失效。</li>\n<li>缓存服务器需要根据客户端要求或者缓存的有效期等音速，向服务器确认确认资源的有效性。</li>\n<li>若缓存失效，将再次获取新的资源</li>\n<li>浏览器也可以存在于客户端，也会确认并更新资源的有效性。</li>\n</ul>\n<h3 id=\"HTTP-首部\"><a href=\"#HTTP-首部\" class=\"headerlink\" title=\"HTTP 首部\"></a>HTTP 首部</h3><p>四种首部字段类型</p>\n<ul>\n<li>通用首部字段（都会使用的首部）</li>\n<li>请求首部字段（仅请求）</li>\n<li>响应首部字段（仅响应）</li>\n<li>实体首部字段（仅含有实体的报文）</li>\n</ul>\n<h5 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h5><ul>\n<li>Cache-Control：控制缓存的行为</li>\n<li>Connection：控制不再转发给代理的首部字段，控制持久连接</li>\n<li>Date：创建 HTTP 报文的日期时间</li>\n<li>Pragma：只用于请求报文中，要求所有中间服务器不返回缓存的资源</li>\n<li>Trailer：记录报文主体后的首部字段</li>\n<li>Transfer-Encoding：指定报文主体的编码方式</li>\n<li>Upgrade：指定升级为其他通信协议</li>\n<li>Via：追踪客户端和服务器之间请求和响应报文的传输路径</li>\n<li>Warning：告知用户警告内容</li>\n</ul>\n<h5 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h5><ul>\n<li>Accept：用户代理可处理的媒体类型以及媒体相对优先级</li>\n<li>Accept-Charset：用户代理支持的字符集和字符集的相对优先顺序</li>\n<li>Accept-Encoding：用户代理支持的内容编码和内容编码的优先级顺序</li>\n<li>Accept-Language：用户代理能处理的自然语言集和自然语言集的相对优先级</li>\n<li>Authorization：用户代理的认证信息（证书值）</li>\n<li>Expect：告知服务器，期待服务器的特定行为，无法理解时返回 417 Expectation Failed</li>\n<li>From：告知服务器使用用户代理的用户的电子邮箱地址</li>\n<li>Host：告知服务器，请求资源所在的主机名和端口号（必须包含在请求内的首部字段）</li>\n<li>If-Match：比较实体标记（Etag 与字段值匹配一致，服务器才接受请求，否则返回状态码 412）</li>\n<li>If-Modified-Since：比较资源的更新时间（指定时间后有更新，接受请求，否则返回状态码 304）</li>\n<li>If-None-Match：比较实体标记（与 If-Match 相反）</li>\n<li>If-Range：字段值与 ETag 或更新的日期时间匹配一致，就作为范围请求处理（否则返回全部资源）</li>\n<li>If-Unmodified-Since：比较资源的更新时间（与 If-Modified-Since 相反）</li>\n<li>Max-Forwards：最大传输逐跳数（可经过的服务器数量，转发次数）</li>\n<li>Proxy-Authorization：代理服务器要求客户端的认证信息</li>\n<li>Range：范围请求时，服务器资源的字节范围</li>\n<li>Referer：对请求中 URI 的原始获取方</li>\n<li>TE：告知服务器客户端能够处理的响应的传输编码方式和相对优先级</li>\n<li>User-Agent：HTTP 客户端程序的信息（创建请求的浏览器，用户代理名称等信息）</li>\n</ul>\n<h5 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h5><ul>\n<li>Accept-Ranges：告知客户端服务器是否接受字节范围请求（可以时字段值为 bytes，否则为 none）</li>\n<li>Age：由缓存服务器创建，资源经上次认证经过的时间</li>\n<li>Etag：告知客户端实体标识，将资源以字符串形式做唯一性标识的方式分配 ETag</li>\n<li>Location：可以将响应接收方引导至某个与请求 URI 位置不同的资源</li>\n<li>Proxy-Authenticate：把由代理服务器对客户端要求的认证信息发送给客户端</li>\n<li>Retry-After：告知客户端再次发起请求的时间</li>\n<li>Server：当前服务器上 HTTP 服务器应用程序的信息</li>\n<li>Vary：代理服务器缓存的管理信息，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。</li>\n<li>WWW-Authenticate：HTTP 访问认证。访问请求 URI 制定资源的认证方案和带参数的质询。</li>\n</ul>\n<h5 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h5><ul>\n<li>Allow：资源可支持的 HTTP 方法</li>\n<li>Content-Encoding：实体主体适用的内容编码方式</li>\n<li>Content-Language：实体主体使用的自然语言</li>\n<li>Content-Length：实体主体的大小（单位字节）（内容编码时，不再使用该字段）</li>\n<li>Content-Location：报文主体返回资源对应的 URI</li>\n<li>Content-MD5：报文主体的 MD5 码，验证作用</li>\n<li>Content-Range：实体主体的位置范围</li>\n<li>Content-Type：实体主体内对象的媒体类型</li>\n<li>Expires：实体主体过期的日期时间</li>\n<li>Last-Modified：资源的最后修改日期时间</li>\n</ul>\n<h5 id=\"为-Cookie-服务的首部字段\"><a href=\"#为-Cookie-服务的首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的首部字段\"></a>为 Cookie 服务的首部字段</h5><ul>\n<li>Set-Cookie：开始状态管理所使用的 Cookie 信息</li>\n<li>Cookie：服务器接收到的 Cookie 信息</li>\n</ul>\n<h5 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h5><ul>\n<li>X-Frame-Options：响应首部，控制网站内容在其他 Web 网站的 Frame 标签内的显示问题</li>\n<li>X-XSS-Protection：响应首部，针对跨站脚本攻击，控制浏览器 XSS 防护机制的开关</li>\n<li>DNT：请求首部，拒绝个人信息被收集的</li>\n<li>P3P：响应首部，利用 P3P 技术，让 Web 网站上的个人隐私变成仅供程序可理解的形式，保护用户隐私</li>\n</ul>\n<h3 id=\"HTTPS：安全的-HTTP\"><a href=\"#HTTPS：安全的-HTTP\" class=\"headerlink\" title=\"HTTPS：安全的 HTTP\"></a>HTTPS：安全的 HTTP</h3><p>HTTP 协议中有可能存在信息窃听或身份伪装等安全问题，使用 HTTPS 通信机制可以有效地防止这些问题。</p>\n<h5 id=\"HTTP-的缺点\"><a href=\"#HTTP-的缺点\" class=\"headerlink\" title=\"HTTP 的缺点\"></a>HTTP 的缺点</h5><ul>\n<li>通信使用明文，内容可能遭遇窃听</li>\n<li>不验证通信双方的身份，可能遭遇伪装</li>\n<li>无法验证报文的完整性，有可能遭遇篡改</li>\n</ul>\n<h6 id=\"通信使用明文可能会被窃听\"><a href=\"#通信使用明文可能会被窃听\" class=\"headerlink\" title=\"通信使用明文可能会被窃听\"></a>通信使用明文可能会被窃听</h6><blockquote>\n<p> HTTP 协议不对通信进行加密</p>\n</blockquote>\n<p>互联网由能连通到全世界的网络组成的，通信的数据包在全网中流动传输。只要在互联网中，所有的报文信息都是全网可见的。为了保证通信的安全性，加密处理才是有效的方案。</p>\n<ul>\n<li>通信的加密（安全的通信线路）</li>\n</ul>\n<p>HTTP 协议没有加密机制，但是可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p>\n<ul>\n<li>内容的加密（安全的通信内容）</li>\n</ul>\n<p>客户端将 HTTP 报文进行加密处理后再发送请求。为了服从 HTTP 协议的要求，报文首部不加密而只对报文主体加密处理。客户端和服务器需要同时有加密和解密机制，但是没有安全的通信线路，内容仍有被篡改的风险。</p>\n<p>######不验证通信双方的身份就可能遭遇伪装</p>\n<blockquote>\n<p>HTTP 协议不对请求和响应的通信双方进行确认。</p>\n<ul>\n<li>伪装的 Web 服务器和客户端</li>\n<li>无访问权限的通信方</li>\n<li>无法判定请求方</li>\n<li>Dos 攻击（Denial of Service，拒绝服务器攻击）</li>\n</ul>\n</blockquote>\n<ul>\n<li>查明对方的证书</li>\n</ul>\n<p>虽然使用 HTTP 无法确定通信方，如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用证书来验证通信方。<strong>证书</strong>由值得信任的第三方机构颁发根据密码学原理生成，用以证明服务器和客户端是实际存在的。有了证书，就可以证明给通信方就是期望的服务器。</p>\n<h6 id=\"无法证明报文完整性可能已遭篡改\"><a href=\"#无法证明报文完整性可能已遭篡改\" class=\"headerlink\" title=\"无法证明报文完整性可能已遭篡改\"></a>无法证明报文完整性可能已遭篡改</h6><blockquote>\n<p> HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。（中间人攻击，Man-in-the-Middle attack，MITM）</p>\n</blockquote>\n<p>HTTP 协议存在的确定报文完整性的方法并不便捷、可靠，常用的是 MD5 和 SHA-1 等散列值校验方法和确认文件的数字签名方法。使用这些方法也无法确保结果正确，因为校验值本可能被改写。</p>\n<p><strong>为了防止这三个弊端，因此需要使用 HTTPS。</strong></p>\n<h5 id=\"HTTPS-HTTP-加密-认证-完整性保护\"><a href=\"#HTTPS-HTTP-加密-认证-完整性保护\" class=\"headerlink\" title=\"HTTPS = HTTP + 加密 + 认证 + 完整性保护\"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h5><p>HTTPS 不是新的协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p>\n<ul>\n<li>一般情况下，HTTP 直接与 TCP 通信。</li>\n<li>采用 SSL 时，HTTP 就先与 SSL 通信，再由 SSL 和 TCP 通信。</li>\n</ul>\n<h5 id=\"对称加密和非对称加密\"><a href=\"#对称加密和非对称加密\" class=\"headerlink\" title=\"对称加密和非对称加密\"></a>对称加密和非对称加密</h5><p>对称加密指的是加密和解密同用一个密钥的加密方式：</p>\n<ul>\n<li>密钥对于任何一方都是一样的</li>\n<li>任何人只要持有密钥就可以加密和解密</li>\n<li>密钥必须安全地提前发给对方</li>\n<li>安全性的漏洞在于通信过程必须安全地告知对方</li>\n</ul>\n<p>非对称加密指的是加密和解密同用一对非对称密钥的加密方式：</p>\n<ul>\n<li>密钥分为公钥和私钥，公钥对所有人公开，私钥由接收方单独持有</li>\n<li>持有公钥可以加密，持有私钥可以解密</li>\n<li>只要将公钥公开交付，交由发送方加密</li>\n<li>缺点是加密解密的速度更慢</li>\n</ul>\n<p>实际上，两种加密机制都有缺点，对称加密无法安全传输密钥，非对称加密的加密过程耗时更多，HTTPS 采用的是两种机密方式并用的混合加密机制。</p>\n<ul>\n<li>使用非对称加密安全地交换对称加密中的密钥；</li>\n<li>建立通信后，再使用对称加密方式；</li>\n</ul>\n<h6 id=\"证书证明公开密钥的真实性\"><a href=\"#证书证明公开密钥的真实性\" class=\"headerlink\" title=\"证书证明公开密钥的真实性\"></a>证书证明公开密钥的真实性</h6><p>证书的作用是证明公开密钥的真实性。</p>\n<p>数字证书认证机构是对于客户端和服务器都可信任的第三方机构，专门颁发公开密钥的数字证书。服务器将服务器申请的公开密钥做数字签名，这就是数字证书。数字签名是使用数字证书认证机构的私钥加密的，这能证明文件是从数字证书认证机构颁发的。</p>\n<p>服务器将数字证书发送至客户端，客户端可以用数字机构的公开密钥验证，一旦验证就知道认证机构和服务器的公开密钥有效。</p>\n<h6 id=\"HTTPS-安全通信机制\"><a href=\"#HTTPS-安全通信机制\" class=\"headerlink\" title=\"HTTPS 安全通信机制\"></a>HTTPS 安全通信机制</h6><blockquote>\n<p>对于一个主机来说，要想保证绝对的通信安全，唯一可信的只有自己。</p>\n</blockquote>\n<p>在只有主机可信的前提下，怎样建立安全的通信机制。万幸浏览器帮了我们一个大忙，多数浏览器都会实现在内部植入常用认证机关的公开密钥。</p>\n<ul>\n<li>浏览器事先植入认证机构公钥</li>\n<li>服务器向客户端发送公钥证书</li>\n<li>客户端用认证机构的公钥确认证书的真实性</li>\n<li>客户端取出服务器公钥</li>\n<li>客户端使用服务器的公钥加密</li>\n<li>服务器用私钥解密实现安全通信</li>\n</ul>\n<h3 id=\"确认访问用户的身份\"><a href=\"#确认访问用户的身份\" class=\"headerlink\" title=\"确认访问用户的身份\"></a>确认访问用户的身份</h3><blockquote>\n<p>某些 Web 页面需要有一些权限，这就需要认证功能。</p>\n</blockquote>\n<p>HTTP/1.1 使用的认证方式</p>\n<ul>\n<li>BASIC 认证（基本认证）</li>\n<li>DIGEST 认证（摘要认证）</li>\n<li>SSL 客户端认证</li>\n<li>FormBase 认证（基于表单认证）</li>\n</ul>\n<h6 id=\"BASIC-认证\"><a href=\"#BASIC-认证\" class=\"headerlink\" title=\"BASIC 认证\"></a>BASIC 认证</h6><p>BASIC 认证虽然采用 Base64 编码方式，这只是编码方式，不需要任何信息就可以解码。在非 HTTP 的线路上使用 BASIC 认证是很不安全的。此外，浏览器无法注销操作，认证使用上不够灵活。因此 BASIC 认证并不常用。</p>\n<h6 id=\"DIGEST-认证\"><a href=\"#DIGEST-认证\" class=\"headerlink\" title=\"DIGEST 认证\"></a>DIGEST 认证</h6><p>DIGEST 认证是使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。质询/响应的方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方接收到的质询码计算生成响应码。最后向响应码返回给对方进行认证的方式。相比 BASIC 认证，安全性更高。</p>\n<h6 id=\"SSL-客户端认证\"><a href=\"#SSL-客户端认证\" class=\"headerlink\" title=\"SSL 客户端认证\"></a>SSL 客户端认证</h6><p>SSL 客户端使用 HTTPS 的客户端证书完成认证。客户端证书由安全性极高的认证机构颁发，但需要支付一定的费用。以客户端证书进行客户端认证，足以证明服务器正在通信的对方是预料的客户端。</p>\n<p>SSL 客户端认证不仅依靠证书完成认证，一般会和基于表单认证组合使用一种双因素认证来使用。SSL 客户端证书用来认证客户端计算机，基于表单认证用来确定这时本人的行为。</p>\n<h6 id=\"基于表单认证\"><a href=\"#基于表单认证\" class=\"headerlink\" title=\"基于表单认证\"></a>基于表单认证</h6><p>基于表单认证并不是在 HTTP 协议中定义，客户端会像服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果验证。BASIC 认证和 DIGEST 认证安全性和便利性都不够，SSL 客户端足够安全但成本过高，基于表单认证足够安全，也不需要一定的标准规范，因此比较常见。</p>\n<h6 id=\"Session-管理及-Cookie-应用\"><a href=\"#Session-管理及-Cookie-应用\" class=\"headerlink\" title=\"Session 管理及 Cookie 应用\"></a>Session 管理及 Cookie 应用</h6><p>基于表单认证的标准的缺点是 HTTP 的无协议特性，无法实现状态管理，因此使用 Cookie 管理 Session（会话）。</p>\n<p>客户端发送已登陆信息，服务器向用户发放 Session ID 记录认证状态，之后通过验证 Session ID 来判定对方是真实用户。</p>\n<h3 id=\"基于-HTTP-的功能追加协议\"><a href=\"#基于-HTTP-的功能追加协议\" class=\"headerlink\" title=\"基于 HTTP 的功能追加协议\"></a>基于 HTTP 的功能追加协议</h3><h5 id=\"HTTP-瓶颈\"><a href=\"#HTTP-瓶颈\" class=\"headerlink\" title=\"HTTP 瓶颈\"></a>HTTP 瓶颈</h5><p>基于 HTTP 协议无法做到实时更新 Web 页面上的内容。</p>\n<p>HTTP 的一些标准会成为瓶颈：</p>\n<ul>\n<li>一条连接上只可发送一个请求。</li>\n<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>\n<li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。</li>\n<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>\n<li>可任意选择数据压缩格式。非强制压缩发送。</li>\n</ul>\n<h6 id=\"Ajax-的解决方法\"><a href=\"#Ajax-的解决方法\" class=\"headerlink\" title=\"Ajax 的解决方法\"></a>Ajax 的解决方法</h6><p>Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文件对象模型）达到局部 Web 页面替换加载的异步通信手段（只更新部分页面，减少响应中传输的数据量）。</p>\n<h6 id=\"Comet-的解决方案\"><a href=\"#Comet-的解决方案\" class=\"headerlink\" title=\"Comet 的解决方案\"></a>Comet 的解决方案</h6><p>Comet 延迟响应，挂起状态，直至内容更新返回响应。</p>\n<p>这一过程模拟了服务器向客户端推送（Server Push）功能。尽管 Comet 实现了实时更新，但维持连接消耗更多资源，仍未解决 HTTP 协议的问题。</p>\n<h5 id=\"SPDY-缩短-Web-页面的加载时间\"><a href=\"#SPDY-缩短-Web-页面的加载时间\" class=\"headerlink\" title=\"SPDY 缩短 Web 页面的加载时间\"></a>SPDY 缩短 Web 页面的加载时间</h5><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，同时 SPDY 规定通信中使用 SSL。</p>\n<p>HTTP 处于应用层，SPDY 会话层，SSL 处于表示层，TCP 处于传输层。</p>\n<p>使用 SPDY 后，HTTP 协议额外获得一些功能：</p>\n<ul>\n<li>多用复用流：一次 TCP 连接可以无限制处理多个 HTTP 请求，效率提高。</li>\n<li>赋予请求优先级：SPDY 可以给请求分配优先级顺序，解决带宽低而相应变慢的问题。</li>\n<li>压缩 HTTP 首部：减少通信数据包的字节数。</li>\n<li>推送功能：支持服务器主动向客户端推送功能。</li>\n<li>服务器提示功能：服务器可以主动提示客户端所需的资源。</li>\n</ul>\n<h5 id=\"使用浏览器进行全双工通信的-WebSocket\"><a href=\"#使用浏览器进行全双工通信的-WebSocket\" class=\"headerlink\" title=\"使用浏览器进行全双工通信的 WebSocket\"></a>使用浏览器进行全双工通信的 WebSocket</h5><p>利用 Ajax 和 Comet 级数进行通信可以提升 Web 的浏览速度，WebSocket 网络技术是避免 HTTP 的瓶颈的新协议及 API。WebSocket 既支持服务器向客户端推送数据，也支持持续保持 WebSocket 连接，以更短的首部减少通信量。</p>\n<p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行，通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式，并且双方都可以直接向对方发送报文。</p>\n<h6 id=\"握手·请求\"><a href=\"#握手·请求\" class=\"headerlink\" title=\"握手·请求\"></a>握手·请求</h6><p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/chat</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: server.example.com</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span>: websocket</span><br><span class=\"line\"><span class=\"attribute\">Conection</span>: Upgrade</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class=\"line\"><span class=\"attribute\">Origin</span>: http://example.com</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Sec-WebSocket-Key：记录握手过程中必不可少的键值</li>\n<li>Sec-WebSocket-Protocol：记录使用的子协议</li>\n</ul>\n<h6 id=\"握手·响应\"><a href=\"#握手·响应\" class=\"headerlink\" title=\"握手·响应\"></a>握手·响应</h6><p>响应 WebSocket 通信，返回的状态码为 101 Switching Protocols。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">101</span> Switching Protocols</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span>: websocket</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: Upgeade</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure>\n\n<p>Sec-WebSocket-Accept 的值根据握手请求中 Sec-WebSocket-Key 的字段值生成。成功握手确立 WebSocket 连接之后，通信时不在使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>\n<h6 id=\"WebSocket-API\"><a href=\"#WebSocket-API\" class=\"headerlink\" title=\"WebSocket API\"></a>WebSocket API</h6><p>JavaScript 可调用 “The WebSocket API” 内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'ws://game.example.com:12010/updates'</span>);</span><br><span class=\"line\">socket.onopen = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socket.bufferedAmount == <span class=\"number\">0</span>)</span><br><span class=\"line\">            socket.send(getUpdateData());</span><br><span class=\"line\">    &#125;, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Web-服务器管理文件的-WebDAV\"><a href=\"#Web-服务器管理文件的-WebDAV\" class=\"headerlink\" title=\"Web 服务器管理文件的 WebDAV\"></a>Web 服务器管理文件的 WebDAV</h5><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行进行文件复制、编辑等操作的分布式文件系统。</p>\n<p>HTTP/1.1的 PUT 方法和 DELETE 方法，可以对 Web 服务器上的文件进行创建和删除操作，出于安全性和便捷性一般不使用。</p>\n<p>WebDAV 新增加的概念：</p>\n<ul>\n<li>集合（Collection）：一种统一管理多个资源的概念。以集合为单位可进行各种操作，也可实现类似集合的集合这样的操作。</li>\n<li>资源（Resource）：文件或集合称为资源。</li>\n<li>属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。</li>\n<li>锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</li>\n</ul>\n<h6 id=\"WebDAV-新增的方法\"><a href=\"#WebDAV-新增的方法\" class=\"headerlink\" title=\"WebDAV 新增的方法\"></a>WebDAV 新增的方法</h6><ul>\n<li>PROPFIND：获取属性</li>\n<li>PROPPATCH：修改属性</li>\n<li>MKCOL：创建集合</li>\n<li>CPOY：复制资源及属性</li>\n<li>MOVE：移动资源</li>\n<li>LOCK：资源加锁</li>\n<li>UNLOCK：资源解锁</li>\n</ul>\n<h6 id=\"WebDAV-拓展的状态码\"><a href=\"#WebDAV-拓展的状态码\" class=\"headerlink\" title=\"WebDAV 拓展的状态码\"></a>WebDAV 拓展的状态码</h6><ul>\n<li>102 Processing：可正常处理请求，但目前是处理中状态</li>\n<li>207 Muti-Status：存在多种状态</li>\n<li>422 Unprocessible Entity：格式正确，内容有误</li>\n<li>423 Locked：资源已被加锁</li>\n<li>424 Failed Dependency：处理与某请求关联的请求失败，因此维持依赖关系</li>\n<li>507 Insufficient Storage：保存空间不足</li>\n</ul>\n<h3 id=\"构建-Web-内容的技术\"><a href=\"#构建-Web-内容的技术\" class=\"headerlink\" title=\"构建 Web 内容的技术\"></a>构建 Web 内容的技术</h3><h5 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h5><h6 id=\"超文本标记语言-HTML\"><a href=\"#超文本标记语言-HTML\" class=\"headerlink\" title=\"超文本标记语言 HTML\"></a>超文本标记语言 HTML</h6><p>HTML（HyperText Markup Language，超文本标记语言）是一种标记语言。标记语言通过标签控制构建 Web 页面</p>\n<h6 id=\"层叠样式表-CSS\"><a href=\"#层叠样式表-CSS\" class=\"headerlink\" title=\"层叠样式表 CSS\"></a>层叠样式表 CSS</h6><p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素。</p>\n<h5 id=\"动态-HTML\"><a href=\"#动态-HTML\" class=\"headerlink\" title=\"动态 HTML\"></a>动态 HTML</h5><p>动态 HTML（Dynamic HTML）值使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。</p>\n<h6 id=\"客户端脚本语言-JavaScript\"><a href=\"#客户端脚本语言-JavaScript\" class=\"headerlink\" title=\"客户端脚本语言 JavaScript\"></a>客户端脚本语言 JavaScript</h6><p>动态 HTML 调用客户端脚本语言 JavaScript 实现对 HTML 的 Web 页面的动态改造；</p>\n<h6 id=\"文档对象模型-DOM\"><a href=\"#文档对象模型-DOM\" class=\"headerlink\" title=\"文档对象模型 DOM\"></a>文档对象模型 DOM</h6><p>DOM 将 HTML 内的元素当作对象操作，指定欲发生动态变化的 HTML 元素。</p>\n<h5 id=\"Web-应用\"><a href=\"#Web-应用\" class=\"headerlink\" title=\"Web 应用\"></a>Web 应用</h5><h6 id=\"Web-应用作用于动态内容之上\"><a href=\"#Web-应用作用于动态内容之上\" class=\"headerlink\" title=\"Web 应用作用于动态内容之上\"></a>Web 应用作用于动态内容之上</h6><p>由程序创建的内容为动态内容；事先准备好的内容称为静态内容。Web 应用作用于动态内容上。</p>\n<h6 id=\"与-Web-服务器及程序协作的-CGI\"><a href=\"#与-Web-服务器及程序协作的-CGI\" class=\"headerlink\" title=\"与 Web 服务器及程序协作的 CGI\"></a>与 Web 服务器及程序协作的 CGI</h6><p>CGI（Common Gateway Interface，通用网关接口）是 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。（CGI 程序一般用 Perl、PHP、Ruby 和 C 等编程语言编写而成）</p>\n<h6 id=\"因-JAVA-而普及的-Servlet\"><a href=\"#因-JAVA-而普及的-Servlet\" class=\"headerlink\" title=\"因 JAVA 而普及的 Servlet\"></a>因 JAVA 而普及的 Servlet</h6><p>Servlet 是一种能在服务器创建动态内容的程序，是用 JAVA 语言实现的一个接口。</p>\n<blockquote>\n<p>Servlet 常驻内存，CGI 程序则需要不断启动。</p>\n</blockquote>\n<h5 id=\"数据发布的格式及语言\"><a href=\"#数据发布的格式及语言\" class=\"headerlink\" title=\"数据发布的格式及语言\"></a>数据发布的格式及语言</h5><h6 id=\"可拓展标记语言\"><a href=\"#可拓展标记语言\" class=\"headerlink\" title=\"可拓展标记语言\"></a>可拓展标记语言</h6><p>XML（eXtensible Markup Language，可拓展标记语言）是一种可按应用目标进行拓展的通用标记语言。</p>\n<blockquote>\n<p>HTML 更适合显示 Web 页面，XML 更适合数据交换。</p>\n</blockquote>\n<h6 id=\"发布更新信息的-RSS-Atom\"><a href=\"#发布更新信息的-RSS-Atom\" class=\"headerlink\" title=\"发布更新信息的 RSS/Atom\"></a>发布更新信息的 RSS/Atom</h6><p>RSS（建议信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。</p>\n<h6 id=\"JavaScript-衍生的轻量级易用-JSON\"><a href=\"#JavaScript-衍生的轻量级易用-JSON\" class=\"headerlink\" title=\"JavaScript 衍生的轻量级易用 JSON\"></a>JavaScript 衍生的轻量级易用 JSON</h6><p>JSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。JSON 字符串形式可以被 JavaScript 轻易读入，能处理 false / null / true / 对象 / 数组 / 数字 / 字符串这七类数据。</p>\n<h3 id=\"Web-的攻击技术\"><a href=\"#Web-的攻击技术\" class=\"headerlink\" title=\"Web 的攻击技术\"></a>Web 的攻击技术</h3><h5 id=\"针对-Web-的攻击技术\"><a href=\"#针对-Web-的攻击技术\" class=\"headerlink\" title=\"针对 Web 的攻击技术\"></a>针对 Web 的攻击技术</h5><h6 id=\"HTTP-不具备必要的安全功能\"><a href=\"#HTTP-不具备必要的安全功能\" class=\"headerlink\" title=\"HTTP 不具备必要的安全功能\"></a>HTTP 不具备必要的安全功能</h6><p>HTTP 是一个纯粹的通信协议，无法应对针对 Web 的攻击。开发者需要自行设计并开发认证及会话管理来满足 Web 应用的安全，这样也可能会有安全漏洞。</p>\n<h6 id=\"在客户端即可篡改请求\"><a href=\"#在客户端即可篡改请求\" class=\"headerlink\" title=\"在客户端即可篡改请求\"></a>在客户端即可篡改请求</h6><p>浏览器接收到的 HTTP 请求的全部内容都可以在客户端自由更变、篡改。若 Web 应用有漏洞，服务器的信息将被窃取，权限被夺取。</p>\n<h5 id=\"针对-Web-应用的攻击模式\"><a href=\"#针对-Web-应用的攻击模式\" class=\"headerlink\" title=\"针对 Web 应用的攻击模式\"></a>针对 Web 应用的攻击模式</h5><ul>\n<li>以服务器为目标的主动攻击：直接访问 Web 应用，传入攻击代码。</li>\n<li>以服务器为目标的被动攻击：不直接对 Web 应用访问，而利用圈套策略执行攻击代码。</li>\n</ul>\n<h5 id=\"因输出值转义不完全引发的安全漏洞\"><a href=\"#因输出值转义不完全引发的安全漏洞\" class=\"headerlink\" title=\"因输出值转义不完全引发的安全漏洞\"></a>因输出值转义不完全引发的安全漏洞</h5><ul>\n<li>跨站脚本攻击：通过存在安全漏洞的 Web 网站用户的浏览器内运行 HTML 标签或 JavaScript 进行攻击。</li>\n<li>SQL 注入攻击：针对 Web 应用使用的数据库，通过运行非法的 SQL 产生攻击。</li>\n<li>OS 命令注入攻击：通过 Web 应用，执行非法的操作系统命令达到攻击的目的。</li>\n<li>HTTP 首部注入攻击：攻击者通过在相应首部字段内插入换行，添加任意相应首部或主体的攻击。</li>\n<li>邮件首部注入攻击：攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。</li>\n<li>目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后达成访问目的。</li>\n<li>远程文件包含漏洞：利用外部服务器的 URL 充当以来文件，让脚本读取后，运行任意脚本的一种攻击。</li>\n</ul>\n<h5 id=\"因设置和设计上的缺陷引发的安全漏洞\"><a href=\"#因设置和设计上的缺陷引发的安全漏洞\" class=\"headerlink\" title=\"因设置和设计上的缺陷引发的安全漏洞\"></a>因设置和设计上的缺陷引发的安全漏洞</h5><ul>\n<li>强制浏览：从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。</li>\n<li>不正确的错误消息处理：Web 应用的错误消息内包含对攻击者有用的信息。</li>\n<li>开放重定向：对指定的任意的 URL 作重定向跳转值特定的 Web 网站。</li>\n</ul>\n<h5 id=\"因会话管理疏忽引发的安全漏洞\"><a href=\"#因会话管理疏忽引发的安全漏洞\" class=\"headerlink\" title=\"因会话管理疏忽引发的安全漏洞\"></a>因会话管理疏忽引发的安全漏洞</h5><ul>\n<li>会话挟持：攻击者窃取用户的会话 ID，并非法使用次会话 ID 伪装成用户达到攻击目的。</li>\n<li>会话固定攻击：强制用户使用攻击者指定的会话 ID</li>\n<li>跨站点请求伪造：攻击者通过设置好的陷阱强制对已完成认证的用户进行某些状态更新。</li>\n</ul>\n<h5 id=\"其他安全漏洞\"><a href=\"#其他安全漏洞\" class=\"headerlink\" title=\"其他安全漏洞\"></a>其他安全漏洞</h5><ul>\n<li>密码破解：算出密码，突破认证。</li>\n<li>点击挟持：利用透明的按钮或连接做成陷阱，覆盖在 Web 页面上，诱使用户访问特定内容。</li>\n<li>DoS 攻击：让运行中的服务呈停止状态。（过量请求或安全漏洞使服务器过载）</li>\n<li>后门程序：开发设置的隐藏入口，可不按正常步骤使用受限功能。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"Web-页面的实现\"><a href=\"#Web-页面的实现\" class=\"headerlink\" title=\"Web 页面的实现\"></a>Web 页面的实现</h3><h5 id=\"Web-基于-HTTP-协议通信\"><a href=\"#Web-基于-HTTP-协议通信\" class=\"headerlink\" title=\"Web 基于 HTTP 协议通信\"></a>Web 基于 HTTP 协议通信</h5><blockquote>\n<p>客户端（Client）的 Web 浏览器从 Web 服务器端获取文件资源等信息 。</p>\n</blockquote>","more":"<ol>\n<li>浏览器的地址栏输入 URL</li>\n<li>URL 信息送往某处</li>\n<li>从某处得到回复</li>\n<li>将回复内容显示在 Web 页面上</li>\n</ol>\n<p>Web 建立在 <strong>HTTP 协议</strong>（HyperText Transfer Protocol，超文本传输协议）实现通信。</p>\n<p>目前主流的 HTTP 版本：HTTP/1.1</p>\n<h5 id=\"TCP-IP-网络层\"><a href=\"#TCP-IP-网络层\" class=\"headerlink\" title=\"TCP/IP 网络层\"></a>TCP/IP 网络层</h5><p>网络分层：</p>\n<ul>\n<li>设计各层之间接口，若需要改变设计只需改动有变动的层</li>\n<li>简化设计，只需完成该层的任务</li>\n</ul>\n<p>位于应用层的 HTTP 数据每经过一层就会打上属于该层的首部信息，这一过程称为<strong>封装</strong>。</p>\n<ol>\n<li><p><strong>IP</strong> （Internet Protocol）网际协议位于网络层，任务是传输数据包。</p>\n<p>IP 协议中有两种地址：IP 地址和 MAC 地址（Media Access Control Address）</p>\n</li>\n</ol>\n<ul>\n<li>IP 地址：网络中分配到的地址，全网唯一；（IP 地址分段，就像邮编决定数据流动的方向）</li>\n</ul>\n<ul>\n<li>MAC 地址：每个网卡固定有一个 MAC 地址，无法改变。（ARP 协议用于解析 IP 地址，得到 MAC 地址）</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>TCP</strong> 位于传输层：提供通过可靠的字节流服务。</p>\n<p>TCP 的可靠传输：三次握手策略（SYN 和 ACK）</p>\n</li>\n</ol>\n<ul>\n<li>发送端发送 SYN  标志的数据包；</li>\n</ul>\n<ul>\n<li>接收端回传 SYN/ACK 标志的数据包传达确认信息；</li>\n<li>发送端再回传一个 ACK 标志的数据包；</li>\n</ul>\n<h5 id=\"DNS-服务\"><a href=\"#DNS-服务\" class=\"headerlink\" title=\"DNS 服务\"></a>DNS 服务</h5><p><strong>DNS</strong> （Domain Name System）服务是位于应用层，可以提供域名解析服务。</p>\n<p>在网络中，每个主机都有唯一的 IP 地址，在互联网中我们却不太可能全部使用一串数字来记住网站，我们使用的是<strong>域名</strong>。</p>\n<ul>\n<li>计算机网络使用 IP 地址来实现网络中数据的传输。</li>\n<li>用户使用域名来访问网站。</li>\n<li>用户通过访问 DNS 服务器询问域名的 IP 地址，取得 IP 地址后，就可以通过 IP 地址访问。</li>\n</ul>\n<h5 id=\"URL-和-URI\"><a href=\"#URL-和-URI\" class=\"headerlink\" title=\"URL 和 URI\"></a>URL 和 URI</h5><ul>\n<li>URL（Uniform Resource Locator，统一资源定位符）访问网页时需要输入的网页地址，表示资源的地点。</li>\n<li>URI（Uniform Resource Identifier，统一资源标识符）用字符串标识某一互联网资源。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://user:pass@www.example.jp:80/dir/index/htm?uid=1#ch1</span><br></pre></td></tr></table></figure>\n\n<p>URI 格式依次由：协议方案、登陆信息、服务器地址、服务器端口号、带层次的文件路径、查询字符串和片段标识符构成。</p>\n<h3 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h3><h5 id=\"客户端和服务器\"><a href=\"#客户端和服务器\" class=\"headerlink\" title=\"客户端和服务器\"></a>客户端和服务器</h5><p>HTTP 协议中，必然是一方为客户端，一方为服务器。</p>\n<ul>\n<li>客户端：请求访问文本或图像等资源的一端；</li>\n<li>服务器端：提供资源响应的一端；</li>\n</ul>\n<blockquote>\n<p>通信的双方是不对等的，因此在通信过程中，通常上行速度比下载速度慢很多。</p>\n</blockquote>\n<h5 id=\"请求和响应\"><a href=\"#请求和响应\" class=\"headerlink\" title=\"请求和响应\"></a>请求和响应</h5><p>客户端和服务器端通过请求和响应的交换达成通信。</p>\n<ul>\n<li>客户端先发送请求；</li>\n<li>服务器再发送响应；</li>\n<li>服务器本身无法在没有请求时发送响应</li>\n</ul>\n<ol>\n<li>客户端发送请求</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>起始行的 GET 表示请求访问的方法（method）；</li>\n<li>字符串 /index.htm 指明了请求访问的资源对象，就是请求 URI（request-URI）；</li>\n<li>HTTP/1.1 为客户端 HTTP 版本号；</li>\n<li>也就是说，向主机名为 hackr.jp 的服务器请求 /index.hem 页面资源。</li>\n<li>总的来说，请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成。</li>\n</ul>\n<ol start=\"2\">\n<li>服务器发送响应</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 362</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>HTTP/1.1 为服务器对应的 HTTP 版本。</li>\n<li>200 OK 为请求的处理结果的状态码（status code）和原因短语（reason-phrase）</li>\n<li>之后的为首部字段（header field）</li>\n<li>空一行之后为资源的主体（entity body）</li>\n<li>响应报文由协议版本、状态码、原因短语、首部字段和实体主题</li>\n</ul>\n<h5 id=\"Cookie-解决状态问题\"><a href=\"#Cookie-解决状态问题\" class=\"headerlink\" title=\"Cookie 解决状态问题\"></a>Cookie 解决状态问题</h5><p>HTTP 协议自身不对请求和响应之间的通信状态进行保存。这样一来，服务器只需要专一化的处理响应 HTTP 请求即可，减少了服务器 CPU 和内存的消耗。</p>\n<p>当然 Web 网络中状态管理还是很重要的，如果网站每次都要重新登录和重新认证，结果是很糟糕的。Cookie 技术会在请求和响应报文中加入 Cookie 信息来控制客户端的状态。</p>\n<ol>\n<li>没有 Cookie 时发出请求</li>\n</ol>\n<ul>\n<li>客户端向服务器发出请求</li>\n<li>服务器通过生成 Cookie 信息（这一时刻记住了客户端信息）</li>\n<li>在响应中添加 Set-Cookie 的首部字段信息。</li>\n<li>服务器回复响应</li>\n<li>客户端收到后就把 Cookie 保存起来。</li>\n</ul>\n<ol start=\"2\">\n<li>有 Cookie 状态信息时发出请求</li>\n</ol>\n<ul>\n<li>客户端主动在请求报文中添加 Cookie 信息</li>\n<li>客户端向服务器发出请求</li>\n<li>服务器检查 Cookie 信息</li>\n<li>服务器回复响应</li>\n</ul>\n<h5 id=\"请求-URI-定位网络资源\"><a href=\"#请求-URI-定位网络资源\" class=\"headerlink\" title=\"请求 URI 定位网络资源\"></a>请求 URI 定位网络资源</h5><p>HTTP 协议使用 URI 定位互联网上的资源，客户端访问请求资源发送请求时，需要在请求报文中添加 URI 。</p>\n<ol>\n<li>使用完整的请求 URI</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 Host 首部字段写明网络域名或 IP 地址</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.htm</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用 * 来代替 URI 只访问服务器</li>\n</ol>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">OPTIONS</span> <span class=\"string\">*</span> HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HTTP-方法告知服务器意图\"><a href=\"#HTTP-方法告知服务器意图\" class=\"headerlink\" title=\"HTTP 方法告知服务器意图\"></a>HTTP 方法告知服务器意图</h5><ul>\n<li>GET ：获取资源</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n<p>返回 index.html 的页面资源。</p>\n<ul>\n<li>POST ：传输实体主体</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">POST</span> <span class=\"string\">/submit.cgi</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">Content-length</span>: 1560</span><br></pre></td></tr></table></figure>\n\n<p>返回 submit.cgi 接收数据的处理结果</p>\n<ul>\n<li>PUT ：传输文件</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">PUT</span> <span class=\"string\">/example.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 1560</span><br></pre></td></tr></table></figure>\n\n<p>向服务器上传文件，存在安全性问题，一般不使用，需要 Web 验证机制。</p>\n<ul>\n<li>HEAD ：获得报文首部</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">HEAD</span> <span class=\"string\">/index.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n<p>告知服务器无需返回报文主体部分，确认 URI 的有效性及资源更新日期时间。</p>\n<ul>\n<li>DELETE ：删除文件</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"string\">/example.html</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n<p>删除服务器上的资源，存在安全性问题，一般不使用，需要 Web 验证机制。</p>\n<ul>\n<li><p>OPTIONS ：询问支持的方法</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">OPTIONS</span> <span class=\"string\">*</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.hackr.jp</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>针对服务器查询针对请求 URI 指定的资源支持的方法。</p>\n<ul>\n<li><p>TRACE ：追踪路径</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">TRACE</span> <span class=\"string\">/</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">Max-Forward</span>: 2</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>让 Web 服务器端将之前的请求通信环回给客户端，不常使用，可能引起跨站追踪（Cross-Site Tracing）。</p>\n<p>添加 Max-Forward 首部字段的数值，每经过服务器数值减一，数值为 0 的服务器返回状态码 200 OK 的响应。</p>\n<ul>\n<li><p>CONNECT ：要求用隧道协议连接代理</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CONNECT</span> <span class=\"string\">proxy.hackr.jp:8080</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: proxy.hackr.jp</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>要求与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。</p>\n<p>主要使用 SSL（Secure Sockets Layer，安全套接层）和 TSL（Transport Layer Security， 传输层安全）协议把通信内容加密后经网络隧道传输。</p>\n<h5 id=\"HTTP-方法指挥服务器\"><a href=\"#HTTP-方法指挥服务器\" class=\"headerlink\" title=\"HTTP 方法指挥服务器\"></a>HTTP 方法指挥服务器</h5><p>使用方法作为命令来向服务器下达命令，可以指定请求的资源的行为。</p>\n<ul>\n<li>HTTP/1.0：GET、POST、PUT、HEAD、DELETE、LINK、UNLINK（HTTP/1.1删除 LINK 和 UNLINK）</li>\n<li>HTTP/1.1：GET、POST、PUT、HEAD、DELETE、OPTIONS、TRACE、CONNECT</li>\n</ul>\n<h5 id=\"持久连接减少通信量\"><a href=\"#持久连接减少通信量\" class=\"headerlink\" title=\"持久连接减少通信量\"></a>持久连接减少通信量</h5><p>原始的 Web 页面信息很少，每进行一次 HTTP 通信就建立一次 TCP 连接。</p>\n<ul>\n<li>建立 TCP 连接</li>\n<li>HTTP 请求</li>\n<li>HTTP 响应</li>\n<li>断开 TCP 连接</li>\n</ul>\n<p>通信过程：建立 - 请求 - 响应 - 断开</p>\n<p>如果一个页面包含大量数据，那就需要建立多次请求。每次请求又会重新断开和建立 TCP 连接，这就造成了许多无谓的开销。</p>\n<p>通信过程：建立 - 请求 - 响应 - 断开 - 建立 - 请求 - 响应 - 断开 - …</p>\n<p>解决方案一：<strong>持久连接</strong></p>\n<p><strong>持久连接</strong>（HTTP Persistent Connection，也称为 HTTP keep-alive 或者 HTTP connection reuse）的特点是只要任意一方提出断开连接，则保持 TCP 连接状态。这样的好处在于在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载；同时也减少了传输所用的时间，加快了 Web 页面的显示速度</p>\n<p>通信过程：建立 - 请求 - 响应 - 请求 - 响应 - … - 请求 - 响应 - 断开</p>\n<p>解决方案二：<strong>管线化</strong></p>\n<p><strong>管线化技术</strong>允许客户端无需等待响应可以直接发送下一个请求。这样一来就可以做到同时并行发送多个请求，而不需要等待响应。</p>\n<p>通信过程：建立 - 请求 1 - 请求 2 - 响应 1 - 响应 2 - 断开</p>\n<h3 id=\"HTTP-报文信息\"><a href=\"#HTTP-报文信息\" class=\"headerlink\" title=\"HTTP 报文信息\"></a>HTTP 报文信息</h3><h5 id=\"HTTP-报文\"><a href=\"#HTTP-报文\" class=\"headerlink\" title=\"HTTP 报文\"></a>HTTP 报文</h5><p>HTTP 报文是用于 HTTP 协议交互的信息，是由多行数据构成的字符串文本 。客户端发出请求报文，服务器端回复响应报文。</p>\n<p>HTTP 报文分为报文首部和报文主体两部分。二者由空行（CR+LF）来划分。通常，并不一定需要报文主体。</p>\n<ul>\n<li>报文首部：服务器端或客户端需处理的请求或响应的内容及属性。</li>\n<li>空行 CR + LF：CR（Carriage Return，回车符：0x0d）和 LF（Line Feed，换行符：0x0a）</li>\n<li>报文主体：应被发送的数据。</li>\n</ul>\n<h5 id=\"请求报文和响应报文结构\"><a href=\"#请求报文和响应报文结构\" class=\"headerlink\" title=\"请求报文和响应报文结构\"></a>请求报文和响应报文结构</h5><h6 id=\"请求报文结构\"><a href=\"#请求报文结构\" class=\"headerlink\" title=\"请求报文结构\"></a>请求报文结构</h6><ul>\n<li>请求报文 = 请求报文的首部 + 空行 + 报文主体</li>\n<li>请求报文首部 = 请求行 + 请求首部字段 + 通用首部字段 + 实体首部字段 + 其他</li>\n</ul>\n<h6 id=\"请求报文实例\"><a href=\"#请求报文实例\" class=\"headerlink\" title=\"请求报文实例\"></a>请求报文实例</h6><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: hackr.jp</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv13.0) Geoko/20100101 Firefox/13.0.1</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span>: ja,en-us;q=0.7,en;q=0.3</span><br><span class=\"line\"><span class=\"attribute\">Accept-Encoding</span>: gzip, deflate</span><br><span class=\"line\"><span class=\"attribute\">DNT</span>: 1</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Pragma</span>: no-cache</span><br><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: co-cache</span><br><span class=\"line\"> (空行：CR+LF)</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"响应报文结构\"><a href=\"#响应报文结构\" class=\"headerlink\" title=\"响应报文结构\"></a>响应报文结构</h6><p>响应报文 = 响应报文的首部 + 空行 + 报文主体</p>\n<p>响应报文首部 = 状态行 + 响应首部字段 + 通用首部字段 + 实体首部字段 + 其他</p>\n<h6 id=\"响应报文实例\"><a href=\"#响应报文实例\" class=\"headerlink\" title=\"响应报文实例\"></a>响应报文实例</h6><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Fri, 13 Jul 2012 02:45:26 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: Apache</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Fri, 31 Aug 2007 02:02:20 GMT</span><br><span class=\"line\"><span class=\"attribute\">ETag</span>: \"45bael-16a-46d776ac\"</span><br><span class=\"line\"><span class=\"attribute\">Accept-Range</span>: bytes</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 362</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: close</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"> (空行：CR+LF)</span><br><span class=\"line\">&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;</span><br><span class=\"line\">&lt;title&gt;hackr.jp&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;img src=\"hackr.gif\" alt=\"hackr.jp\" width=\"240\" height=\"84\" /&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>报文的组成</p>\n<ul>\n<li>请求行：请求的方法，请求 URI 和 HTTP 版本</li>\n<li>状态行：响应结果的状态码，原因短语和 HTTP 版本。</li>\n<li>首部字段：请求首部（或响应首部）、通用首部和实体首部</li>\n<li>其他：HTTP 的 RFC 未定义的首部</li>\n</ul>\n<h5 id=\"编码提升传输速率\"><a href=\"#编码提升传输速率\" class=\"headerlink\" title=\"编码提升传输速率\"></a>编码提升传输速率</h5><p>HTTP 协议可以通过计算机编码来压缩或分割传输的内容，提升传输的速率。同样地，编码需要额外消耗计算机资源。</p>\n<h6 id=\"报文主体和实体主体\"><a href=\"#报文主体和实体主体\" class=\"headerlink\" title=\"报文主体和实体主体\"></a>报文主体和实体主体</h6><p>报文是 HTTP 通信的基本单位，由 8 位组字节流组成，通过 HTTP 通信。</p>\n<p>实体作为响应或请求的有效载荷数据被传输，其内容有实体首部和实体主体组成。</p>\n<ul>\n<li>对于没有编码的情况，报文主体等于实体主体；</li>\n<li>对于有编码的情况，报文主体为实体主体编码之后的产物；</li>\n</ul>\n<p>内容编码和分块传输编码</p>\n<ul>\n<li><p><strong>内容编码</strong>指明应用在实体内容上的编码格式，并保持尸体信息原样压缩。压缩编码后的实体有客户端接收并负责解码。</p>\n</li>\n<li><p><strong>分块传输编码</strong>通过把数据分割成多块，让大容量数据分块逐步显示在 Web 页面上。</p>\n<h6 id=\"多部分对象集合\"><a href=\"#多部分对象集合\" class=\"headerlink\" title=\"多部分对象集合\"></a>多部分对象集合</h6></li>\n</ul>\n<p>MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件拓展）允许邮件处理文本、图片、视频等多个不同类型的数据。多部分对象集合最早应用在可以添加多份附件的邮件系统中，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体中可以含有多类型实体。</p>\n<p>包含的对象如下：</p>\n<ul>\n<li>multipart/from-data：在 Web 表单上传文件时使用</li>\n<li>multipart/byteranges：状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</li>\n</ul>\n<h6 id=\"获取部分内容的范围请求\"><a href=\"#获取部分内容的范围请求\" class=\"headerlink\" title=\"获取部分内容的范围请求\"></a>获取部分内容的范围请求</h6><p><strong>断点续传</strong>是解决大容量传输的另一个方案：为了避免下载中断的引起下载任务从头开始，需要从下载中断处回复下载的机制。实现这样的功能的请求为<strong>范围请求</strong>，范围请求可以通过首部字段 Range 来指定下载的实体字节范围。</p>\n<p>范围请求实例</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/tip.jpg</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: www.usaidesign.jp</span><br><span class=\"line\"><span class=\"attribute\">Range</span>: bytes =5001-10000</span><br></pre></td></tr></table></figure>\n\n<p>范围请求的响应</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">206</span> Partial Content</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Fri, 13 Jul 2012 04:29:17 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Range</span>: bytes 5001-10000/10000</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 5000</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: image/jpeg</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特别地，追对范围请求</p>\n<ul>\n<li>响应范围请求时，服务器返回状态码 206 Partial Content</li>\n<li>无法响应范围请求时，服务器返回状态码 200 OK </li>\n</ul>\n</blockquote>\n<h6 id=\"内容协商机制\"><a href=\"#内容协商机制\" class=\"headerlink\" title=\"内容协商机制\"></a>内容协商机制</h6><p><strong>内容协商机制</strong>是指客户端和服务器之间就相应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p>\n<p>内容协商技术有三种类型：</p>\n<ul>\n<li>服务器驱动协商</li>\n<li>客户端驱动协商</li>\n<li>透明协商</li>\n</ul>\n<p>在请求报文中通过使用以下首部字段：</p>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n<h3 id=\"HTTP-状态码\"><a href=\"#HTTP-状态码\" class=\"headerlink\" title=\"HTTP 状态码\"></a>HTTP 状态码</h3><p>状态码的作用是当客户端向服务器端发送请求时，描述返回的请求结果。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>类别</th>\n<th>原因短语</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1XX</td>\n<td>Informational</td>\n<td>接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody></table>\n<h5 id=\"2XX-成功\"><a href=\"#2XX-成功\" class=\"headerlink\" title=\"2XX 成功\"></a>2XX 成功</h5><ul>\n<li>200 OK ：请求被正常处理了</li>\n<li>204 No Content ：接受的请求已经处理，但返回的报文中不包含主体</li>\n<li>206 Partial Content ：服务器正常响应了范围请求</li>\n</ul>\n<h5 id=\"3XX-重定向\"><a href=\"#3XX-重定向\" class=\"headerlink\" title=\"3XX 重定向\"></a>3XX 重定向</h5><ul>\n<li>301 Moved  Permanently ： 永久性重定向。客户端应该使用新的 URI </li>\n<li>302 Found ：临时性重定向。用户（本次）应当使用新的 URI 访问（尽管禁止 POST 改 GET，实际还是这样操作）</li>\n<li>303 See Other ：由于请求对应的资源存在另一个 URI ，应使用 GET 方法定向获取请求的资源。</li>\n<li>304 Not Modified ：请求的附带条件不满足，返回 304 Not Modified 不包含任何响应的主体</li>\n<li>307 Temporary Redirect ：临时性重定向。与 302 一致但不会从 POST 变成 GET。</li>\n</ul>\n<h5 id=\"4XX-客户端错误\"><a href=\"#4XX-客户端错误\" class=\"headerlink\" title=\"4XX 客户端错误\"></a>4XX 客户端错误</h5><ul>\n<li>400 Bad Request ：请求报文中存在语法错误</li>\n<li>401 Unauthorized ：需要 HTTP 认证或者认证失败（This server could not verify that you are authorized to access the document requested. Either you supplied the wrong credentials (e.g., bad password), or your browser doesn’t understand how to supply the credentials required）</li>\n<li>403 Forbidden ：对请求资源的访问被服务器拒绝了，服务器无需给出理由</li>\n<li>404 Not Found ：服务器上没有请求的资源（The request URL /a  was found on this server）</li>\n</ul>\n<h5 id=\"5XX-成功\"><a href=\"#5XX-成功\" class=\"headerlink\" title=\"5XX 成功\"></a>5XX 成功</h5><ul>\n<li>500 Internet Server Error</li>\n<li>503 Service Unavailable</li>\n</ul>\n<h3 id=\"与-HTTP-协作的-Web-服务器\"><a href=\"#与-HTTP-协作的-Web-服务器\" class=\"headerlink\" title=\"与 HTTP 协作的 Web 服务器\"></a>与 HTTP 协作的 Web 服务器</h3><p>一台 Web 服务器可以搭建多个独立域名的 Web 网站，也可以作为通信路径上的中转服务器提升传输效率。</p>\n<h5 id=\"单台主机实现多个域名\"><a href=\"#单台主机实现多个域名\" class=\"headerlink\" title=\"单台主机实现多个域名\"></a>单台主机实现多个域名</h5><p>HTTP/1.1允许允许一台 HTTP 服务器利用虚拟主机（Virtual  Host）搭建多个 Web 站点。</p>\n<p>当两个域名同时部署在同一个服务器上时，只会有一个 IP 地址，这时 DNS 服务器解析域名时，二者的访问 IP 地址也会相同。因此必须在 Host 首部内完成指定主机名或域名的 URI。</p>\n<h5 id=\"通信数据转发程序：代理、网关、隧道\"><a href=\"#通信数据转发程序：代理、网关、隧道\" class=\"headerlink\" title=\"通信数据转发程序：代理、网关、隧道\"></a>通信数据转发程序：代理、网关、隧道</h5><p>HTTP 通信中除了客户端和服务器以外，还有一些配合服务器工作，用于通信数据的转发的应用程序，例如代理、网关和隧道。</p>\n<ul>\n<li>代理：位于客户端和服务器中间有转发功能的应用程序。接收客户端的请求并转发给服务器，接收服务器的响应并转发给客户端。</li>\n<li>网关：转发其他服务器通信数据的服务器，接收客户端发送来的请求时，会像自己拥有资源的服务器一样对请求进行处理。</li>\n<li>隧道：在客户端和服务器两者之间进行中专，并保持双方通信连接的应用程序。</li>\n</ul>\n<h6 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h6><p>代理服务器的基本行为是接收客户端的请求后转发给其他服务器。代理不改变请求 URI ，会直接发送给源服务器。多部代理服务器可以级联，转发时，需要附加 Via 首部字段以标记出经过的主机信息。</p>\n<p>多种用途：</p>\n<ul>\n<li>利用缓存技术减少网络带宽</li>\n<li>组织内部针对特定网站的访问控制</li>\n<li>获取访问日志为主要目的</li>\n</ul>\n<p>两种分类基准：</p>\n<ul>\n<li>缓存代理：预先将资源的副本保存在代理服务器上，再次接受请求时不从源服务器获取资源，而是将缓存作为响应返回。</li>\n<li>透明代理：不对报文做任何加工的代理称为透明代理；对报文进行加工的代理称为非透明代理。</li>\n</ul>\n<h6 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h6><p>网关能使通信线路上的服务器提供非 HTTP 协议服务。网关能在客户端与网关之间的通信线路上加密，提高通信的安全性。</p>\n<h6 id=\"隧道\"><a href=\"#隧道\" class=\"headerlink\" title=\"隧道\"></a>隧道</h6><p>隧道可以建立一条与其他服务器的通信连接，并使用 SSL 等加密手段进行通信，确保客户端能与服务器进行安全的通信。此外，隧道本身是透明的，隧道本身不解析 HTTP 请求，保持原样中转给之后的服务器，并自动在在通信双方断开连接时结束。</p>\n<h5 id=\"保存资源的缓存\"><a href=\"#保存资源的缓存\" class=\"headerlink\" title=\"保存资源的缓存\"></a>保存资源的缓存</h5><p>缓存是代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可以减少对源服务器的访问，节省了通信流量和通信时间。</p>\n<p>缓存服务器是代理服务器的一种，属于缓存代理。缓存服务器可以利用缓存文件避免多次的从服务器转发资源，一方面通信时间减少，另一方面也可以同时减小服务器的压力。</p>\n<ul>\n<li>当然缓存必须是有期限，万一源服务器的资源有更新，缓存就会失效。</li>\n<li>缓存服务器需要根据客户端要求或者缓存的有效期等音速，向服务器确认确认资源的有效性。</li>\n<li>若缓存失效，将再次获取新的资源</li>\n<li>浏览器也可以存在于客户端，也会确认并更新资源的有效性。</li>\n</ul>\n<h3 id=\"HTTP-首部\"><a href=\"#HTTP-首部\" class=\"headerlink\" title=\"HTTP 首部\"></a>HTTP 首部</h3><p>四种首部字段类型</p>\n<ul>\n<li>通用首部字段（都会使用的首部）</li>\n<li>请求首部字段（仅请求）</li>\n<li>响应首部字段（仅响应）</li>\n<li>实体首部字段（仅含有实体的报文）</li>\n</ul>\n<h5 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h5><ul>\n<li>Cache-Control：控制缓存的行为</li>\n<li>Connection：控制不再转发给代理的首部字段，控制持久连接</li>\n<li>Date：创建 HTTP 报文的日期时间</li>\n<li>Pragma：只用于请求报文中，要求所有中间服务器不返回缓存的资源</li>\n<li>Trailer：记录报文主体后的首部字段</li>\n<li>Transfer-Encoding：指定报文主体的编码方式</li>\n<li>Upgrade：指定升级为其他通信协议</li>\n<li>Via：追踪客户端和服务器之间请求和响应报文的传输路径</li>\n<li>Warning：告知用户警告内容</li>\n</ul>\n<h5 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h5><ul>\n<li>Accept：用户代理可处理的媒体类型以及媒体相对优先级</li>\n<li>Accept-Charset：用户代理支持的字符集和字符集的相对优先顺序</li>\n<li>Accept-Encoding：用户代理支持的内容编码和内容编码的优先级顺序</li>\n<li>Accept-Language：用户代理能处理的自然语言集和自然语言集的相对优先级</li>\n<li>Authorization：用户代理的认证信息（证书值）</li>\n<li>Expect：告知服务器，期待服务器的特定行为，无法理解时返回 417 Expectation Failed</li>\n<li>From：告知服务器使用用户代理的用户的电子邮箱地址</li>\n<li>Host：告知服务器，请求资源所在的主机名和端口号（必须包含在请求内的首部字段）</li>\n<li>If-Match：比较实体标记（Etag 与字段值匹配一致，服务器才接受请求，否则返回状态码 412）</li>\n<li>If-Modified-Since：比较资源的更新时间（指定时间后有更新，接受请求，否则返回状态码 304）</li>\n<li>If-None-Match：比较实体标记（与 If-Match 相反）</li>\n<li>If-Range：字段值与 ETag 或更新的日期时间匹配一致，就作为范围请求处理（否则返回全部资源）</li>\n<li>If-Unmodified-Since：比较资源的更新时间（与 If-Modified-Since 相反）</li>\n<li>Max-Forwards：最大传输逐跳数（可经过的服务器数量，转发次数）</li>\n<li>Proxy-Authorization：代理服务器要求客户端的认证信息</li>\n<li>Range：范围请求时，服务器资源的字节范围</li>\n<li>Referer：对请求中 URI 的原始获取方</li>\n<li>TE：告知服务器客户端能够处理的响应的传输编码方式和相对优先级</li>\n<li>User-Agent：HTTP 客户端程序的信息（创建请求的浏览器，用户代理名称等信息）</li>\n</ul>\n<h5 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h5><ul>\n<li>Accept-Ranges：告知客户端服务器是否接受字节范围请求（可以时字段值为 bytes，否则为 none）</li>\n<li>Age：由缓存服务器创建，资源经上次认证经过的时间</li>\n<li>Etag：告知客户端实体标识，将资源以字符串形式做唯一性标识的方式分配 ETag</li>\n<li>Location：可以将响应接收方引导至某个与请求 URI 位置不同的资源</li>\n<li>Proxy-Authenticate：把由代理服务器对客户端要求的认证信息发送给客户端</li>\n<li>Retry-After：告知客户端再次发起请求的时间</li>\n<li>Server：当前服务器上 HTTP 服务器应用程序的信息</li>\n<li>Vary：代理服务器缓存的管理信息，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。</li>\n<li>WWW-Authenticate：HTTP 访问认证。访问请求 URI 制定资源的认证方案和带参数的质询。</li>\n</ul>\n<h5 id=\"实体首部字段\"><a href=\"#实体首部字段\" class=\"headerlink\" title=\"实体首部字段\"></a>实体首部字段</h5><ul>\n<li>Allow：资源可支持的 HTTP 方法</li>\n<li>Content-Encoding：实体主体适用的内容编码方式</li>\n<li>Content-Language：实体主体使用的自然语言</li>\n<li>Content-Length：实体主体的大小（单位字节）（内容编码时，不再使用该字段）</li>\n<li>Content-Location：报文主体返回资源对应的 URI</li>\n<li>Content-MD5：报文主体的 MD5 码，验证作用</li>\n<li>Content-Range：实体主体的位置范围</li>\n<li>Content-Type：实体主体内对象的媒体类型</li>\n<li>Expires：实体主体过期的日期时间</li>\n<li>Last-Modified：资源的最后修改日期时间</li>\n</ul>\n<h5 id=\"为-Cookie-服务的首部字段\"><a href=\"#为-Cookie-服务的首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的首部字段\"></a>为 Cookie 服务的首部字段</h5><ul>\n<li>Set-Cookie：开始状态管理所使用的 Cookie 信息</li>\n<li>Cookie：服务器接收到的 Cookie 信息</li>\n</ul>\n<h5 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h5><ul>\n<li>X-Frame-Options：响应首部，控制网站内容在其他 Web 网站的 Frame 标签内的显示问题</li>\n<li>X-XSS-Protection：响应首部，针对跨站脚本攻击，控制浏览器 XSS 防护机制的开关</li>\n<li>DNT：请求首部，拒绝个人信息被收集的</li>\n<li>P3P：响应首部，利用 P3P 技术，让 Web 网站上的个人隐私变成仅供程序可理解的形式，保护用户隐私</li>\n</ul>\n<h3 id=\"HTTPS：安全的-HTTP\"><a href=\"#HTTPS：安全的-HTTP\" class=\"headerlink\" title=\"HTTPS：安全的 HTTP\"></a>HTTPS：安全的 HTTP</h3><p>HTTP 协议中有可能存在信息窃听或身份伪装等安全问题，使用 HTTPS 通信机制可以有效地防止这些问题。</p>\n<h5 id=\"HTTP-的缺点\"><a href=\"#HTTP-的缺点\" class=\"headerlink\" title=\"HTTP 的缺点\"></a>HTTP 的缺点</h5><ul>\n<li>通信使用明文，内容可能遭遇窃听</li>\n<li>不验证通信双方的身份，可能遭遇伪装</li>\n<li>无法验证报文的完整性，有可能遭遇篡改</li>\n</ul>\n<h6 id=\"通信使用明文可能会被窃听\"><a href=\"#通信使用明文可能会被窃听\" class=\"headerlink\" title=\"通信使用明文可能会被窃听\"></a>通信使用明文可能会被窃听</h6><blockquote>\n<p> HTTP 协议不对通信进行加密</p>\n</blockquote>\n<p>互联网由能连通到全世界的网络组成的，通信的数据包在全网中流动传输。只要在互联网中，所有的报文信息都是全网可见的。为了保证通信的安全性，加密处理才是有效的方案。</p>\n<ul>\n<li>通信的加密（安全的通信线路）</li>\n</ul>\n<p>HTTP 协议没有加密机制，但是可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p>\n<ul>\n<li>内容的加密（安全的通信内容）</li>\n</ul>\n<p>客户端将 HTTP 报文进行加密处理后再发送请求。为了服从 HTTP 协议的要求，报文首部不加密而只对报文主体加密处理。客户端和服务器需要同时有加密和解密机制，但是没有安全的通信线路，内容仍有被篡改的风险。</p>\n<p>######不验证通信双方的身份就可能遭遇伪装</p>\n<blockquote>\n<p>HTTP 协议不对请求和响应的通信双方进行确认。</p>\n<ul>\n<li>伪装的 Web 服务器和客户端</li>\n<li>无访问权限的通信方</li>\n<li>无法判定请求方</li>\n<li>Dos 攻击（Denial of Service，拒绝服务器攻击）</li>\n</ul>\n</blockquote>\n<ul>\n<li>查明对方的证书</li>\n</ul>\n<p>虽然使用 HTTP 无法确定通信方，如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用证书来验证通信方。<strong>证书</strong>由值得信任的第三方机构颁发根据密码学原理生成，用以证明服务器和客户端是实际存在的。有了证书，就可以证明给通信方就是期望的服务器。</p>\n<h6 id=\"无法证明报文完整性可能已遭篡改\"><a href=\"#无法证明报文完整性可能已遭篡改\" class=\"headerlink\" title=\"无法证明报文完整性可能已遭篡改\"></a>无法证明报文完整性可能已遭篡改</h6><blockquote>\n<p> HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。（中间人攻击，Man-in-the-Middle attack，MITM）</p>\n</blockquote>\n<p>HTTP 协议存在的确定报文完整性的方法并不便捷、可靠，常用的是 MD5 和 SHA-1 等散列值校验方法和确认文件的数字签名方法。使用这些方法也无法确保结果正确，因为校验值本可能被改写。</p>\n<p><strong>为了防止这三个弊端，因此需要使用 HTTPS。</strong></p>\n<h5 id=\"HTTPS-HTTP-加密-认证-完整性保护\"><a href=\"#HTTPS-HTTP-加密-认证-完整性保护\" class=\"headerlink\" title=\"HTTPS = HTTP + 加密 + 认证 + 完整性保护\"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h5><p>HTTPS 不是新的协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p>\n<ul>\n<li>一般情况下，HTTP 直接与 TCP 通信。</li>\n<li>采用 SSL 时，HTTP 就先与 SSL 通信，再由 SSL 和 TCP 通信。</li>\n</ul>\n<h5 id=\"对称加密和非对称加密\"><a href=\"#对称加密和非对称加密\" class=\"headerlink\" title=\"对称加密和非对称加密\"></a>对称加密和非对称加密</h5><p>对称加密指的是加密和解密同用一个密钥的加密方式：</p>\n<ul>\n<li>密钥对于任何一方都是一样的</li>\n<li>任何人只要持有密钥就可以加密和解密</li>\n<li>密钥必须安全地提前发给对方</li>\n<li>安全性的漏洞在于通信过程必须安全地告知对方</li>\n</ul>\n<p>非对称加密指的是加密和解密同用一对非对称密钥的加密方式：</p>\n<ul>\n<li>密钥分为公钥和私钥，公钥对所有人公开，私钥由接收方单独持有</li>\n<li>持有公钥可以加密，持有私钥可以解密</li>\n<li>只要将公钥公开交付，交由发送方加密</li>\n<li>缺点是加密解密的速度更慢</li>\n</ul>\n<p>实际上，两种加密机制都有缺点，对称加密无法安全传输密钥，非对称加密的加密过程耗时更多，HTTPS 采用的是两种机密方式并用的混合加密机制。</p>\n<ul>\n<li>使用非对称加密安全地交换对称加密中的密钥；</li>\n<li>建立通信后，再使用对称加密方式；</li>\n</ul>\n<h6 id=\"证书证明公开密钥的真实性\"><a href=\"#证书证明公开密钥的真实性\" class=\"headerlink\" title=\"证书证明公开密钥的真实性\"></a>证书证明公开密钥的真实性</h6><p>证书的作用是证明公开密钥的真实性。</p>\n<p>数字证书认证机构是对于客户端和服务器都可信任的第三方机构，专门颁发公开密钥的数字证书。服务器将服务器申请的公开密钥做数字签名，这就是数字证书。数字签名是使用数字证书认证机构的私钥加密的，这能证明文件是从数字证书认证机构颁发的。</p>\n<p>服务器将数字证书发送至客户端，客户端可以用数字机构的公开密钥验证，一旦验证就知道认证机构和服务器的公开密钥有效。</p>\n<h6 id=\"HTTPS-安全通信机制\"><a href=\"#HTTPS-安全通信机制\" class=\"headerlink\" title=\"HTTPS 安全通信机制\"></a>HTTPS 安全通信机制</h6><blockquote>\n<p>对于一个主机来说，要想保证绝对的通信安全，唯一可信的只有自己。</p>\n</blockquote>\n<p>在只有主机可信的前提下，怎样建立安全的通信机制。万幸浏览器帮了我们一个大忙，多数浏览器都会实现在内部植入常用认证机关的公开密钥。</p>\n<ul>\n<li>浏览器事先植入认证机构公钥</li>\n<li>服务器向客户端发送公钥证书</li>\n<li>客户端用认证机构的公钥确认证书的真实性</li>\n<li>客户端取出服务器公钥</li>\n<li>客户端使用服务器的公钥加密</li>\n<li>服务器用私钥解密实现安全通信</li>\n</ul>\n<h3 id=\"确认访问用户的身份\"><a href=\"#确认访问用户的身份\" class=\"headerlink\" title=\"确认访问用户的身份\"></a>确认访问用户的身份</h3><blockquote>\n<p>某些 Web 页面需要有一些权限，这就需要认证功能。</p>\n</blockquote>\n<p>HTTP/1.1 使用的认证方式</p>\n<ul>\n<li>BASIC 认证（基本认证）</li>\n<li>DIGEST 认证（摘要认证）</li>\n<li>SSL 客户端认证</li>\n<li>FormBase 认证（基于表单认证）</li>\n</ul>\n<h6 id=\"BASIC-认证\"><a href=\"#BASIC-认证\" class=\"headerlink\" title=\"BASIC 认证\"></a>BASIC 认证</h6><p>BASIC 认证虽然采用 Base64 编码方式，这只是编码方式，不需要任何信息就可以解码。在非 HTTP 的线路上使用 BASIC 认证是很不安全的。此外，浏览器无法注销操作，认证使用上不够灵活。因此 BASIC 认证并不常用。</p>\n<h6 id=\"DIGEST-认证\"><a href=\"#DIGEST-认证\" class=\"headerlink\" title=\"DIGEST 认证\"></a>DIGEST 认证</h6><p>DIGEST 认证是使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。质询/响应的方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方接收到的质询码计算生成响应码。最后向响应码返回给对方进行认证的方式。相比 BASIC 认证，安全性更高。</p>\n<h6 id=\"SSL-客户端认证\"><a href=\"#SSL-客户端认证\" class=\"headerlink\" title=\"SSL 客户端认证\"></a>SSL 客户端认证</h6><p>SSL 客户端使用 HTTPS 的客户端证书完成认证。客户端证书由安全性极高的认证机构颁发，但需要支付一定的费用。以客户端证书进行客户端认证，足以证明服务器正在通信的对方是预料的客户端。</p>\n<p>SSL 客户端认证不仅依靠证书完成认证，一般会和基于表单认证组合使用一种双因素认证来使用。SSL 客户端证书用来认证客户端计算机，基于表单认证用来确定这时本人的行为。</p>\n<h6 id=\"基于表单认证\"><a href=\"#基于表单认证\" class=\"headerlink\" title=\"基于表单认证\"></a>基于表单认证</h6><p>基于表单认证并不是在 HTTP 协议中定义，客户端会像服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果验证。BASIC 认证和 DIGEST 认证安全性和便利性都不够，SSL 客户端足够安全但成本过高，基于表单认证足够安全，也不需要一定的标准规范，因此比较常见。</p>\n<h6 id=\"Session-管理及-Cookie-应用\"><a href=\"#Session-管理及-Cookie-应用\" class=\"headerlink\" title=\"Session 管理及 Cookie 应用\"></a>Session 管理及 Cookie 应用</h6><p>基于表单认证的标准的缺点是 HTTP 的无协议特性，无法实现状态管理，因此使用 Cookie 管理 Session（会话）。</p>\n<p>客户端发送已登陆信息，服务器向用户发放 Session ID 记录认证状态，之后通过验证 Session ID 来判定对方是真实用户。</p>\n<h3 id=\"基于-HTTP-的功能追加协议\"><a href=\"#基于-HTTP-的功能追加协议\" class=\"headerlink\" title=\"基于 HTTP 的功能追加协议\"></a>基于 HTTP 的功能追加协议</h3><h5 id=\"HTTP-瓶颈\"><a href=\"#HTTP-瓶颈\" class=\"headerlink\" title=\"HTTP 瓶颈\"></a>HTTP 瓶颈</h5><p>基于 HTTP 协议无法做到实时更新 Web 页面上的内容。</p>\n<p>HTTP 的一些标准会成为瓶颈：</p>\n<ul>\n<li>一条连接上只可发送一个请求。</li>\n<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>\n<li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。</li>\n<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>\n<li>可任意选择数据压缩格式。非强制压缩发送。</li>\n</ul>\n<h6 id=\"Ajax-的解决方法\"><a href=\"#Ajax-的解决方法\" class=\"headerlink\" title=\"Ajax 的解决方法\"></a>Ajax 的解决方法</h6><p>Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文件对象模型）达到局部 Web 页面替换加载的异步通信手段（只更新部分页面，减少响应中传输的数据量）。</p>\n<h6 id=\"Comet-的解决方案\"><a href=\"#Comet-的解决方案\" class=\"headerlink\" title=\"Comet 的解决方案\"></a>Comet 的解决方案</h6><p>Comet 延迟响应，挂起状态，直至内容更新返回响应。</p>\n<p>这一过程模拟了服务器向客户端推送（Server Push）功能。尽管 Comet 实现了实时更新，但维持连接消耗更多资源，仍未解决 HTTP 协议的问题。</p>\n<h5 id=\"SPDY-缩短-Web-页面的加载时间\"><a href=\"#SPDY-缩短-Web-页面的加载时间\" class=\"headerlink\" title=\"SPDY 缩短 Web 页面的加载时间\"></a>SPDY 缩短 Web 页面的加载时间</h5><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作，同时 SPDY 规定通信中使用 SSL。</p>\n<p>HTTP 处于应用层，SPDY 会话层，SSL 处于表示层，TCP 处于传输层。</p>\n<p>使用 SPDY 后，HTTP 协议额外获得一些功能：</p>\n<ul>\n<li>多用复用流：一次 TCP 连接可以无限制处理多个 HTTP 请求，效率提高。</li>\n<li>赋予请求优先级：SPDY 可以给请求分配优先级顺序，解决带宽低而相应变慢的问题。</li>\n<li>压缩 HTTP 首部：减少通信数据包的字节数。</li>\n<li>推送功能：支持服务器主动向客户端推送功能。</li>\n<li>服务器提示功能：服务器可以主动提示客户端所需的资源。</li>\n</ul>\n<h5 id=\"使用浏览器进行全双工通信的-WebSocket\"><a href=\"#使用浏览器进行全双工通信的-WebSocket\" class=\"headerlink\" title=\"使用浏览器进行全双工通信的 WebSocket\"></a>使用浏览器进行全双工通信的 WebSocket</h5><p>利用 Ajax 和 Comet 级数进行通信可以提升 Web 的浏览速度，WebSocket 网络技术是避免 HTTP 的瓶颈的新协议及 API。WebSocket 既支持服务器向客户端推送数据，也支持持续保持 WebSocket 连接，以更短的首部减少通信量。</p>\n<p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行，通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式，并且双方都可以直接向对方发送报文。</p>\n<h6 id=\"握手·请求\"><a href=\"#握手·请求\" class=\"headerlink\" title=\"握手·请求\"></a>握手·请求</h6><p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/chat</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: server.example.com</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span>: websocket</span><br><span class=\"line\"><span class=\"attribute\">Conection</span>: Upgrade</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class=\"line\"><span class=\"attribute\">Origin</span>: http://example.com</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Sec-WebSocket-Key：记录握手过程中必不可少的键值</li>\n<li>Sec-WebSocket-Protocol：记录使用的子协议</li>\n</ul>\n<h6 id=\"握手·响应\"><a href=\"#握手·响应\" class=\"headerlink\" title=\"握手·响应\"></a>握手·响应</h6><p>响应 WebSocket 通信，返回的状态码为 101 Switching Protocols。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">101</span> Switching Protocols</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span>: websocket</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: Upgeade</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure>\n\n<p>Sec-WebSocket-Accept 的值根据握手请求中 Sec-WebSocket-Key 的字段值生成。成功握手确立 WebSocket 连接之后，通信时不在使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>\n<h6 id=\"WebSocket-API\"><a href=\"#WebSocket-API\" class=\"headerlink\" title=\"WebSocket API\"></a>WebSocket API</h6><p>JavaScript 可调用 “The WebSocket API” 内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> socket = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'ws://game.example.com:12010/updates'</span>);</span><br><span class=\"line\">socket.onopen = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (socket.bufferedAmount == <span class=\"number\">0</span>)</span><br><span class=\"line\">            socket.send(getUpdateData());</span><br><span class=\"line\">    &#125;, <span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Web-服务器管理文件的-WebDAV\"><a href=\"#Web-服务器管理文件的-WebDAV\" class=\"headerlink\" title=\"Web 服务器管理文件的 WebDAV\"></a>Web 服务器管理文件的 WebDAV</h5><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行进行文件复制、编辑等操作的分布式文件系统。</p>\n<p>HTTP/1.1的 PUT 方法和 DELETE 方法，可以对 Web 服务器上的文件进行创建和删除操作，出于安全性和便捷性一般不使用。</p>\n<p>WebDAV 新增加的概念：</p>\n<ul>\n<li>集合（Collection）：一种统一管理多个资源的概念。以集合为单位可进行各种操作，也可实现类似集合的集合这样的操作。</li>\n<li>资源（Resource）：文件或集合称为资源。</li>\n<li>属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。</li>\n<li>锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</li>\n</ul>\n<h6 id=\"WebDAV-新增的方法\"><a href=\"#WebDAV-新增的方法\" class=\"headerlink\" title=\"WebDAV 新增的方法\"></a>WebDAV 新增的方法</h6><ul>\n<li>PROPFIND：获取属性</li>\n<li>PROPPATCH：修改属性</li>\n<li>MKCOL：创建集合</li>\n<li>CPOY：复制资源及属性</li>\n<li>MOVE：移动资源</li>\n<li>LOCK：资源加锁</li>\n<li>UNLOCK：资源解锁</li>\n</ul>\n<h6 id=\"WebDAV-拓展的状态码\"><a href=\"#WebDAV-拓展的状态码\" class=\"headerlink\" title=\"WebDAV 拓展的状态码\"></a>WebDAV 拓展的状态码</h6><ul>\n<li>102 Processing：可正常处理请求，但目前是处理中状态</li>\n<li>207 Muti-Status：存在多种状态</li>\n<li>422 Unprocessible Entity：格式正确，内容有误</li>\n<li>423 Locked：资源已被加锁</li>\n<li>424 Failed Dependency：处理与某请求关联的请求失败，因此维持依赖关系</li>\n<li>507 Insufficient Storage：保存空间不足</li>\n</ul>\n<h3 id=\"构建-Web-内容的技术\"><a href=\"#构建-Web-内容的技术\" class=\"headerlink\" title=\"构建 Web 内容的技术\"></a>构建 Web 内容的技术</h3><h5 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h5><h6 id=\"超文本标记语言-HTML\"><a href=\"#超文本标记语言-HTML\" class=\"headerlink\" title=\"超文本标记语言 HTML\"></a>超文本标记语言 HTML</h6><p>HTML（HyperText Markup Language，超文本标记语言）是一种标记语言。标记语言通过标签控制构建 Web 页面</p>\n<h6 id=\"层叠样式表-CSS\"><a href=\"#层叠样式表-CSS\" class=\"headerlink\" title=\"层叠样式表 CSS\"></a>层叠样式表 CSS</h6><p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素。</p>\n<h5 id=\"动态-HTML\"><a href=\"#动态-HTML\" class=\"headerlink\" title=\"动态 HTML\"></a>动态 HTML</h5><p>动态 HTML（Dynamic HTML）值使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。</p>\n<h6 id=\"客户端脚本语言-JavaScript\"><a href=\"#客户端脚本语言-JavaScript\" class=\"headerlink\" title=\"客户端脚本语言 JavaScript\"></a>客户端脚本语言 JavaScript</h6><p>动态 HTML 调用客户端脚本语言 JavaScript 实现对 HTML 的 Web 页面的动态改造；</p>\n<h6 id=\"文档对象模型-DOM\"><a href=\"#文档对象模型-DOM\" class=\"headerlink\" title=\"文档对象模型 DOM\"></a>文档对象模型 DOM</h6><p>DOM 将 HTML 内的元素当作对象操作，指定欲发生动态变化的 HTML 元素。</p>\n<h5 id=\"Web-应用\"><a href=\"#Web-应用\" class=\"headerlink\" title=\"Web 应用\"></a>Web 应用</h5><h6 id=\"Web-应用作用于动态内容之上\"><a href=\"#Web-应用作用于动态内容之上\" class=\"headerlink\" title=\"Web 应用作用于动态内容之上\"></a>Web 应用作用于动态内容之上</h6><p>由程序创建的内容为动态内容；事先准备好的内容称为静态内容。Web 应用作用于动态内容上。</p>\n<h6 id=\"与-Web-服务器及程序协作的-CGI\"><a href=\"#与-Web-服务器及程序协作的-CGI\" class=\"headerlink\" title=\"与 Web 服务器及程序协作的 CGI\"></a>与 Web 服务器及程序协作的 CGI</h6><p>CGI（Common Gateway Interface，通用网关接口）是 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。（CGI 程序一般用 Perl、PHP、Ruby 和 C 等编程语言编写而成）</p>\n<h6 id=\"因-JAVA-而普及的-Servlet\"><a href=\"#因-JAVA-而普及的-Servlet\" class=\"headerlink\" title=\"因 JAVA 而普及的 Servlet\"></a>因 JAVA 而普及的 Servlet</h6><p>Servlet 是一种能在服务器创建动态内容的程序，是用 JAVA 语言实现的一个接口。</p>\n<blockquote>\n<p>Servlet 常驻内存，CGI 程序则需要不断启动。</p>\n</blockquote>\n<h5 id=\"数据发布的格式及语言\"><a href=\"#数据发布的格式及语言\" class=\"headerlink\" title=\"数据发布的格式及语言\"></a>数据发布的格式及语言</h5><h6 id=\"可拓展标记语言\"><a href=\"#可拓展标记语言\" class=\"headerlink\" title=\"可拓展标记语言\"></a>可拓展标记语言</h6><p>XML（eXtensible Markup Language，可拓展标记语言）是一种可按应用目标进行拓展的通用标记语言。</p>\n<blockquote>\n<p>HTML 更适合显示 Web 页面，XML 更适合数据交换。</p>\n</blockquote>\n<h6 id=\"发布更新信息的-RSS-Atom\"><a href=\"#发布更新信息的-RSS-Atom\" class=\"headerlink\" title=\"发布更新信息的 RSS/Atom\"></a>发布更新信息的 RSS/Atom</h6><p>RSS（建议信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。</p>\n<h6 id=\"JavaScript-衍生的轻量级易用-JSON\"><a href=\"#JavaScript-衍生的轻量级易用-JSON\" class=\"headerlink\" title=\"JavaScript 衍生的轻量级易用 JSON\"></a>JavaScript 衍生的轻量级易用 JSON</h6><p>JSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。JSON 字符串形式可以被 JavaScript 轻易读入，能处理 false / null / true / 对象 / 数组 / 数字 / 字符串这七类数据。</p>\n<h3 id=\"Web-的攻击技术\"><a href=\"#Web-的攻击技术\" class=\"headerlink\" title=\"Web 的攻击技术\"></a>Web 的攻击技术</h3><h5 id=\"针对-Web-的攻击技术\"><a href=\"#针对-Web-的攻击技术\" class=\"headerlink\" title=\"针对 Web 的攻击技术\"></a>针对 Web 的攻击技术</h5><h6 id=\"HTTP-不具备必要的安全功能\"><a href=\"#HTTP-不具备必要的安全功能\" class=\"headerlink\" title=\"HTTP 不具备必要的安全功能\"></a>HTTP 不具备必要的安全功能</h6><p>HTTP 是一个纯粹的通信协议，无法应对针对 Web 的攻击。开发者需要自行设计并开发认证及会话管理来满足 Web 应用的安全，这样也可能会有安全漏洞。</p>\n<h6 id=\"在客户端即可篡改请求\"><a href=\"#在客户端即可篡改请求\" class=\"headerlink\" title=\"在客户端即可篡改请求\"></a>在客户端即可篡改请求</h6><p>浏览器接收到的 HTTP 请求的全部内容都可以在客户端自由更变、篡改。若 Web 应用有漏洞，服务器的信息将被窃取，权限被夺取。</p>\n<h5 id=\"针对-Web-应用的攻击模式\"><a href=\"#针对-Web-应用的攻击模式\" class=\"headerlink\" title=\"针对 Web 应用的攻击模式\"></a>针对 Web 应用的攻击模式</h5><ul>\n<li>以服务器为目标的主动攻击：直接访问 Web 应用，传入攻击代码。</li>\n<li>以服务器为目标的被动攻击：不直接对 Web 应用访问，而利用圈套策略执行攻击代码。</li>\n</ul>\n<h5 id=\"因输出值转义不完全引发的安全漏洞\"><a href=\"#因输出值转义不完全引发的安全漏洞\" class=\"headerlink\" title=\"因输出值转义不完全引发的安全漏洞\"></a>因输出值转义不完全引发的安全漏洞</h5><ul>\n<li>跨站脚本攻击：通过存在安全漏洞的 Web 网站用户的浏览器内运行 HTML 标签或 JavaScript 进行攻击。</li>\n<li>SQL 注入攻击：针对 Web 应用使用的数据库，通过运行非法的 SQL 产生攻击。</li>\n<li>OS 命令注入攻击：通过 Web 应用，执行非法的操作系统命令达到攻击的目的。</li>\n<li>HTTP 首部注入攻击：攻击者通过在相应首部字段内插入换行，添加任意相应首部或主体的攻击。</li>\n<li>邮件首部注入攻击：攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。</li>\n<li>目录遍历攻击：对本无意公开的文件目录，通过非法截断其目录路径后达成访问目的。</li>\n<li>远程文件包含漏洞：利用外部服务器的 URL 充当以来文件，让脚本读取后，运行任意脚本的一种攻击。</li>\n</ul>\n<h5 id=\"因设置和设计上的缺陷引发的安全漏洞\"><a href=\"#因设置和设计上的缺陷引发的安全漏洞\" class=\"headerlink\" title=\"因设置和设计上的缺陷引发的安全漏洞\"></a>因设置和设计上的缺陷引发的安全漏洞</h5><ul>\n<li>强制浏览：从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。</li>\n<li>不正确的错误消息处理：Web 应用的错误消息内包含对攻击者有用的信息。</li>\n<li>开放重定向：对指定的任意的 URL 作重定向跳转值特定的 Web 网站。</li>\n</ul>\n<h5 id=\"因会话管理疏忽引发的安全漏洞\"><a href=\"#因会话管理疏忽引发的安全漏洞\" class=\"headerlink\" title=\"因会话管理疏忽引发的安全漏洞\"></a>因会话管理疏忽引发的安全漏洞</h5><ul>\n<li>会话挟持：攻击者窃取用户的会话 ID，并非法使用次会话 ID 伪装成用户达到攻击目的。</li>\n<li>会话固定攻击：强制用户使用攻击者指定的会话 ID</li>\n<li>跨站点请求伪造：攻击者通过设置好的陷阱强制对已完成认证的用户进行某些状态更新。</li>\n</ul>\n<h5 id=\"其他安全漏洞\"><a href=\"#其他安全漏洞\" class=\"headerlink\" title=\"其他安全漏洞\"></a>其他安全漏洞</h5><ul>\n<li>密码破解：算出密码，突破认证。</li>\n<li>点击挟持：利用透明的按钮或连接做成陷阱，覆盖在 Web 页面上，诱使用户访问特定内容。</li>\n<li>DoS 攻击：让运行中的服务呈停止状态。（过量请求或安全漏洞使服务器过载）</li>\n<li>后门程序：开发设置的隐藏入口，可不按正常步骤使用受限功能。</li>\n</ul>"},{"title":"MATLAB 绘图（二）","date":"2018-04-12T21:00:02.000Z","_content":"\n### 概述\n\n本次的内容涉及到除了线图以外的绘图，包括离散绘图、极坐标绘图、曲面绘图和统计绘图。\n\n- 离散绘图：茎干图、阶梯图和散点图\n- 极坐标绘图：polar前缀\n- 曲面绘图：surf 曲面图和 mesh 网格图\n- 统计绘图：条形图、统计直方图和饼状图\n\n\n\n<!--more-->\n\n### 子窗口\n\nsubplot 函数指的是将当前图窗划分为 `m`×`n` 网格，并在编号 `p` 指定的位置创建坐标区。\n\n编号规则为：从第一行自左向右递增。\n\n```matlab\n% subplot(m,n,p);\n% 将绘图窗口分为 m 行 n 列的矩形区域\n% 并在编号第 p 的区域中绘图\nfigure();\n% 2*2 分割的第一块区域也就是左上角\nsubplot(2,2,1); \nx = linspace(-3.8,3.8);\ny_cos = cos(x);\nplot(x,y_cos);\ntitle('Subplot 1: Cosine')\n% 2*2 分割的第二块区域也就是右上角\nsubplot(2,2,2);\ny_poly = 1 - x.^2./2 + x.^4./24;\nplot(x,y_poly,'g');\ntitle('Subplot 2: Polynomial')\n% 2*2 分割的第三、四块区域也就是下方\nsubplot(2,2,[3,4]);\n% 也可以写作 subplot(2,1,2); 指的是同一区域。\nplot(x,y_cos,'b',x,y_poly,'g');\ntitle('Subplot 3 and 4: Both')\n```\n![1.png](https://upload-images.jianshu.io/upload_images/8078350-b2e3a5c17fe98d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 离散绘图\n\n#### 茎干图（stem）\n\nstem 函数的功能是描述离散数据中的冲激函数，以绘图高度反映一维离散序列中脉冲的强度。\n\n数据值对应每一个脉冲的强度。\n\n```matlab\nfigure(1)\nX = linspace(0,2*pi,50)';\nY = cos(X);\nsubplot(2,1,1);\nstem(X);\nsubplot(2,1,2);\nstem(X,Y); \n```\n![2.png](https://upload-images.jianshu.io/upload_images/8078350-3db50d1307370792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n#### 阶梯图（stairs）\n\nstairs 函数的功能是描述离散数据中的阶跃函数，以绘图高度反映一维阶跃信号中的实时强度。\n\n数据值为每一个时间周期的高度。\n\n```matlab\nX = linspace(0,4*pi,40);\nY = sin(X);\nfigure(1);\nsubplot(2,1,1);\nstairs(Y);\nsubplot(2,1,2);\nstairs(X,Y);% 这种调用方式应当保证 X 有序\n```\n![3.png](https://upload-images.jianshu.io/upload_images/8078350-44b1b44ad66a1c64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n#### 散点图（scatter）\n\nscatter 函数绘制二维平面上的散点图，也就是不绘制曲线的 plot 函数。\n\n输入参数为散点图的横坐标序列和纵坐标序列。\n\n```matlab \nx = linspace(0,3*pi,200);\ny = cos(x) + rand(1,200); \nM_size = linspace(1,100,200);\nfigure(1);\nsubplot(2,1,1);\nscatter(x,y);\nsubplot(2,1,2);\nscatter(x,y,M_size);\n```\n\n![4.png](https://upload-images.jianshu.io/upload_images/8078350-8645080245b3169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 极坐标绘图\n\n> 我们直到直角坐标和极坐标系都是常用的坐标系，并且两种坐标系之间存在一定的转换关系，但是用 plot 函数绘制转换后的极坐标系图形总是不美观。\n\n~~polar 函数是 MATLAB 中用于绘制极坐标图的函数。~~ \n\npolar 函数已经被 MATLAB 官方更替，更推荐使用的是新的函数方法：polarplot （新方法在旧版本的 MATLAB 如 2015b 版本仍不可用）。因此如果你在使用旧版本软件，使用 polar 方法；如果你在使用的版本支持 polarplot 函数，那就使用 polarplot 函数。\n\npolarplot 函数就是极坐标系下的 plot 函数。以 polarplot(theta,rho) 形式调用。\n\n```matlab\ntheta = 0:0.01:2*pi; % 角度\nrho = sin(2*theta).*cos(2*theta); % 幅值\nfigure(1);\npolarplot(theta,rho); \n% 此处有版本兼容问题，旧版本无法使用该函数\n% 旧版本应当使用 polar(theta,rho);\n```\n![5.png](https://upload-images.jianshu.io/upload_images/8078350-eb9086dcb346a0fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n同理，也有 polarscatter 函数。\n\n### 曲面绘图\n\n> 曲线上的点是无限的，于是计算机用散点序列代替直线；曲面上由无数曲线构成，自然类比想到使用网格代替平面。\n\n#### surf 函数\n\nsurf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；此外，函数将对三维曲面进行渲染，每个区域的颜色与高度成比例。\n\n```matlab\nx0 = 1:0.5:10;\ny0 = 1:20;\n[X,Y] = meshgrid(x0,y0);\n% meshgrid 函数将创建两个由 x0*y0 构成的二维网格矩阵。\n% X 表示网格中对应位置的 x0 值\n% Y 表示网格中对应位置的 y0 值\n% - 可以预见到对于同一个 y0 ，x0 值相同。\nZ = sin(X) + cos(Y);\nsurf(X,Y,Z);\n```\n![6.png](https://upload-images.jianshu.io/upload_images/8078350-665be90818752b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n其他 surf 类型曲面图函数\n\n- surfc 函数：在 surf 函数的基础上，在底部绘制等高线图。\n- surfl 函数：在 surf 函数的基础上，用光线为三维图渲染。\n\n#### mesh 函数\n\nsurf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；函数仅对于三维网格进行渲染，每个区域的颜色与高度成比例。\n\n```matlab\n[X,Y] = meshgrid(-8:.5:8);\nR = sqrt(X.^2 + Y.^2) + eps;\nZ = sin(R)./R;\nfigure(1);\nmesh(Z);\n```\n![7.png](https://upload-images.jianshu.io/upload_images/8078350-04ccb7ddf56e5af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其他 mesh 类型曲面图函数\n\n- meshc函数：在 mesh 函数的基础上，在底部绘制等高线图。\n- meshz 函数：在 mesh 函数的基础上，每个网格高度以柱状反映。\n\n### 统计绘图\n\n####  bar 函数\n\nbar 函数顾名思义是绘制条形图的函数。\n\n由于统计图表有着多种形式的表现需求，这里使用子窗口绘图来实现。\n\n```matlab\nx = 190:1:200;\ny = [75 91 105 123.5 131 150 179 203 226 249 281.5];\nz = [2 2 3; 2 5 6; 2 8 9; 2 11 12];\nfigure(1);\nsubplot(2,3,1);\nbar(y);\nsubplot(2,3,2);\nbar(y,'r')\nsubplot(2,3,3);\nbar(x,y);\nsubplot(2,3,4);\nbar(y,0.4);\nsubplot(2,3,5);\nbar(z);\nsubplot(2,3,6);\nbar(z,'stacked')\n```\n![8.png](https://upload-images.jianshu.io/upload_images/8078350-e5ae2f4e8eb59f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n其他 bar 类型函数：\n\n- bar3 函数：绘制三维条形图\n- barh 函数：绘制水平条形图\n- bar3h 函数：绘制三维水平条形图\n\n####  histogram 函数\n\nhistogram 函数的功能是根据传入的数据绘制统计直方图。\n\n```matlab\nx = randn(10000,1);\n% 10000 个高斯分布随机数\nnbins = 25; \n% 直方图分布区间数量\nfigure(1);\nsubplot(2,1,1);\nh = histogram(x);\nsubplot(2,1,2);\nh = histogram(x,nbins);\n```\n![9.png](https://upload-images.jianshu.io/upload_images/8078350-4d96bbabaa0c2ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n其他 histogram 函数：\n\n- histogram2 函数：绘制二元统计直方图；\n- pareto 函数：绘制帕累托图\n- polarhistogram 函数：在极坐标系上绘制根据角度绘制分布图\n\n####  pie 函数\n\npie 函数的功能是根据传入的比例序列绘制饼状图。\n\n> 特别地：如果 pie(x) 中，\n>\n> - sum(x) < 1，仅绘制部分饼状图。\n> - sum(x) > 1，先做归一化后绘制饼状图。\n\n```matlab\nfigure(1);\nX = [1 3 0.5 2.5 2];\nexplode = [0 1 0 1 0];\nlabels = {'A','B','C','D','E'};\nsubplot(2,2,1);\npie(X);\n% 归一化计算比例\nsubplot(2,2,2);\npie(X,explode);\n% explode 选中的块会突出显示\nsubplot(2,2,3);\npie(X,labels);\n% 以标签代替百分数\nsubplot(2,2,4);\nx1 = [0.19 0.22 0.41];\npie(x1);\n% 不足 100% 则绘制部分饼状图\n```\n![10.png](https://upload-images.jianshu.io/upload_images/8078350-9b9861192e89d43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其他 pie 类型函数：\n\n- pie3 函数：绘制三维饼状图；\n\n#### 其他可视化绘图\n\n> 这部分内容极少使用，不需要在意。\n\nheatmap 函数：根据数据集绘制热图；\n\nwordcloud 函数：使用文本数据创建词云图；\n\ngeobubble 函数：以可视方式呈现特定地理位置的数据值\n\n### 小结\n\n本节中提到除了线图以外的另外四种常见绘图：离散绘图、极坐标绘图、曲面绘图和统计绘图。\n\n值得一提的是，对于极坐标绘图的函数方法，官方已经给出更佳的更新，但旧版本中无法应用，这里给出的为新版本的方案。\n\n\n\n\n\n\n\n\n","source":"_posts/MATLAB-绘图（二）.md","raw":"---\ntitle: MATLAB 绘图（二）\ndate: 2018-04-13 05:00:02\ntags: MATLAB\n---\n\n### 概述\n\n本次的内容涉及到除了线图以外的绘图，包括离散绘图、极坐标绘图、曲面绘图和统计绘图。\n\n- 离散绘图：茎干图、阶梯图和散点图\n- 极坐标绘图：polar前缀\n- 曲面绘图：surf 曲面图和 mesh 网格图\n- 统计绘图：条形图、统计直方图和饼状图\n\n\n\n<!--more-->\n\n### 子窗口\n\nsubplot 函数指的是将当前图窗划分为 `m`×`n` 网格，并在编号 `p` 指定的位置创建坐标区。\n\n编号规则为：从第一行自左向右递增。\n\n```matlab\n% subplot(m,n,p);\n% 将绘图窗口分为 m 行 n 列的矩形区域\n% 并在编号第 p 的区域中绘图\nfigure();\n% 2*2 分割的第一块区域也就是左上角\nsubplot(2,2,1); \nx = linspace(-3.8,3.8);\ny_cos = cos(x);\nplot(x,y_cos);\ntitle('Subplot 1: Cosine')\n% 2*2 分割的第二块区域也就是右上角\nsubplot(2,2,2);\ny_poly = 1 - x.^2./2 + x.^4./24;\nplot(x,y_poly,'g');\ntitle('Subplot 2: Polynomial')\n% 2*2 分割的第三、四块区域也就是下方\nsubplot(2,2,[3,4]);\n% 也可以写作 subplot(2,1,2); 指的是同一区域。\nplot(x,y_cos,'b',x,y_poly,'g');\ntitle('Subplot 3 and 4: Both')\n```\n![1.png](https://upload-images.jianshu.io/upload_images/8078350-b2e3a5c17fe98d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 离散绘图\n\n#### 茎干图（stem）\n\nstem 函数的功能是描述离散数据中的冲激函数，以绘图高度反映一维离散序列中脉冲的强度。\n\n数据值对应每一个脉冲的强度。\n\n```matlab\nfigure(1)\nX = linspace(0,2*pi,50)';\nY = cos(X);\nsubplot(2,1,1);\nstem(X);\nsubplot(2,1,2);\nstem(X,Y); \n```\n![2.png](https://upload-images.jianshu.io/upload_images/8078350-3db50d1307370792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n#### 阶梯图（stairs）\n\nstairs 函数的功能是描述离散数据中的阶跃函数，以绘图高度反映一维阶跃信号中的实时强度。\n\n数据值为每一个时间周期的高度。\n\n```matlab\nX = linspace(0,4*pi,40);\nY = sin(X);\nfigure(1);\nsubplot(2,1,1);\nstairs(Y);\nsubplot(2,1,2);\nstairs(X,Y);% 这种调用方式应当保证 X 有序\n```\n![3.png](https://upload-images.jianshu.io/upload_images/8078350-44b1b44ad66a1c64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n#### 散点图（scatter）\n\nscatter 函数绘制二维平面上的散点图，也就是不绘制曲线的 plot 函数。\n\n输入参数为散点图的横坐标序列和纵坐标序列。\n\n```matlab \nx = linspace(0,3*pi,200);\ny = cos(x) + rand(1,200); \nM_size = linspace(1,100,200);\nfigure(1);\nsubplot(2,1,1);\nscatter(x,y);\nsubplot(2,1,2);\nscatter(x,y,M_size);\n```\n\n![4.png](https://upload-images.jianshu.io/upload_images/8078350-8645080245b3169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 极坐标绘图\n\n> 我们直到直角坐标和极坐标系都是常用的坐标系，并且两种坐标系之间存在一定的转换关系，但是用 plot 函数绘制转换后的极坐标系图形总是不美观。\n\n~~polar 函数是 MATLAB 中用于绘制极坐标图的函数。~~ \n\npolar 函数已经被 MATLAB 官方更替，更推荐使用的是新的函数方法：polarplot （新方法在旧版本的 MATLAB 如 2015b 版本仍不可用）。因此如果你在使用旧版本软件，使用 polar 方法；如果你在使用的版本支持 polarplot 函数，那就使用 polarplot 函数。\n\npolarplot 函数就是极坐标系下的 plot 函数。以 polarplot(theta,rho) 形式调用。\n\n```matlab\ntheta = 0:0.01:2*pi; % 角度\nrho = sin(2*theta).*cos(2*theta); % 幅值\nfigure(1);\npolarplot(theta,rho); \n% 此处有版本兼容问题，旧版本无法使用该函数\n% 旧版本应当使用 polar(theta,rho);\n```\n![5.png](https://upload-images.jianshu.io/upload_images/8078350-eb9086dcb346a0fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n同理，也有 polarscatter 函数。\n\n### 曲面绘图\n\n> 曲线上的点是无限的，于是计算机用散点序列代替直线；曲面上由无数曲线构成，自然类比想到使用网格代替平面。\n\n#### surf 函数\n\nsurf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；此外，函数将对三维曲面进行渲染，每个区域的颜色与高度成比例。\n\n```matlab\nx0 = 1:0.5:10;\ny0 = 1:20;\n[X,Y] = meshgrid(x0,y0);\n% meshgrid 函数将创建两个由 x0*y0 构成的二维网格矩阵。\n% X 表示网格中对应位置的 x0 值\n% Y 表示网格中对应位置的 y0 值\n% - 可以预见到对于同一个 y0 ，x0 值相同。\nZ = sin(X) + cos(Y);\nsurf(X,Y,Z);\n```\n![6.png](https://upload-images.jianshu.io/upload_images/8078350-665be90818752b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n其他 surf 类型曲面图函数\n\n- surfc 函数：在 surf 函数的基础上，在底部绘制等高线图。\n- surfl 函数：在 surf 函数的基础上，用光线为三维图渲染。\n\n#### mesh 函数\n\nsurf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；函数仅对于三维网格进行渲染，每个区域的颜色与高度成比例。\n\n```matlab\n[X,Y] = meshgrid(-8:.5:8);\nR = sqrt(X.^2 + Y.^2) + eps;\nZ = sin(R)./R;\nfigure(1);\nmesh(Z);\n```\n![7.png](https://upload-images.jianshu.io/upload_images/8078350-04ccb7ddf56e5af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其他 mesh 类型曲面图函数\n\n- meshc函数：在 mesh 函数的基础上，在底部绘制等高线图。\n- meshz 函数：在 mesh 函数的基础上，每个网格高度以柱状反映。\n\n### 统计绘图\n\n####  bar 函数\n\nbar 函数顾名思义是绘制条形图的函数。\n\n由于统计图表有着多种形式的表现需求，这里使用子窗口绘图来实现。\n\n```matlab\nx = 190:1:200;\ny = [75 91 105 123.5 131 150 179 203 226 249 281.5];\nz = [2 2 3; 2 5 6; 2 8 9; 2 11 12];\nfigure(1);\nsubplot(2,3,1);\nbar(y);\nsubplot(2,3,2);\nbar(y,'r')\nsubplot(2,3,3);\nbar(x,y);\nsubplot(2,3,4);\nbar(y,0.4);\nsubplot(2,3,5);\nbar(z);\nsubplot(2,3,6);\nbar(z,'stacked')\n```\n![8.png](https://upload-images.jianshu.io/upload_images/8078350-e5ae2f4e8eb59f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n其他 bar 类型函数：\n\n- bar3 函数：绘制三维条形图\n- barh 函数：绘制水平条形图\n- bar3h 函数：绘制三维水平条形图\n\n####  histogram 函数\n\nhistogram 函数的功能是根据传入的数据绘制统计直方图。\n\n```matlab\nx = randn(10000,1);\n% 10000 个高斯分布随机数\nnbins = 25; \n% 直方图分布区间数量\nfigure(1);\nsubplot(2,1,1);\nh = histogram(x);\nsubplot(2,1,2);\nh = histogram(x,nbins);\n```\n![9.png](https://upload-images.jianshu.io/upload_images/8078350-4d96bbabaa0c2ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n其他 histogram 函数：\n\n- histogram2 函数：绘制二元统计直方图；\n- pareto 函数：绘制帕累托图\n- polarhistogram 函数：在极坐标系上绘制根据角度绘制分布图\n\n####  pie 函数\n\npie 函数的功能是根据传入的比例序列绘制饼状图。\n\n> 特别地：如果 pie(x) 中，\n>\n> - sum(x) < 1，仅绘制部分饼状图。\n> - sum(x) > 1，先做归一化后绘制饼状图。\n\n```matlab\nfigure(1);\nX = [1 3 0.5 2.5 2];\nexplode = [0 1 0 1 0];\nlabels = {'A','B','C','D','E'};\nsubplot(2,2,1);\npie(X);\n% 归一化计算比例\nsubplot(2,2,2);\npie(X,explode);\n% explode 选中的块会突出显示\nsubplot(2,2,3);\npie(X,labels);\n% 以标签代替百分数\nsubplot(2,2,4);\nx1 = [0.19 0.22 0.41];\npie(x1);\n% 不足 100% 则绘制部分饼状图\n```\n![10.png](https://upload-images.jianshu.io/upload_images/8078350-9b9861192e89d43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其他 pie 类型函数：\n\n- pie3 函数：绘制三维饼状图；\n\n#### 其他可视化绘图\n\n> 这部分内容极少使用，不需要在意。\n\nheatmap 函数：根据数据集绘制热图；\n\nwordcloud 函数：使用文本数据创建词云图；\n\ngeobubble 函数：以可视方式呈现特定地理位置的数据值\n\n### 小结\n\n本节中提到除了线图以外的另外四种常见绘图：离散绘图、极坐标绘图、曲面绘图和统计绘图。\n\n值得一提的是，对于极坐标绘图的函数方法，官方已经给出更佳的更新，但旧版本中无法应用，这里给出的为新版本的方案。\n\n\n\n\n\n\n\n\n","slug":"MATLAB-绘图（二）","published":1,"updated":"2020-03-15T21:05:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wj000o29fy8y92kmf0","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本次的内容涉及到除了线图以外的绘图，包括离散绘图、极坐标绘图、曲面绘图和统计绘图。</p>\n<ul>\n<li>离散绘图：茎干图、阶梯图和散点图</li>\n<li>极坐标绘图：polar前缀</li>\n<li>曲面绘图：surf 曲面图和 mesh 网格图</li>\n<li>统计绘图：条形图、统计直方图和饼状图</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"子窗口\"><a href=\"#子窗口\" class=\"headerlink\" title=\"子窗口\"></a>子窗口</h3><p>subplot 函数指的是将当前图窗划分为 <code>m</code>×<code>n</code> 网格，并在编号 <code>p</code> 指定的位置创建坐标区。</p>\n<p>编号规则为：从第一行自左向右递增。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% subplot(m,n,p);</span></span><br><span class=\"line\"><span class=\"comment\">% 将绘图窗口分为 m 行 n 列的矩形区域</span></span><br><span class=\"line\"><span class=\"comment\">% 并在编号第 p 的区域中绘图</span></span><br><span class=\"line\">figure();</span><br><span class=\"line\"><span class=\"comment\">% 2*2 分割的第一块区域也就是左上角</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>); </span><br><span class=\"line\">x = <span class=\"built_in\">linspace</span>(<span class=\"number\">-3.8</span>,<span class=\"number\">3.8</span>);</span><br><span class=\"line\">y_cos = <span class=\"built_in\">cos</span>(x);</span><br><span class=\"line\">plot(x,y_cos);</span><br><span class=\"line\">title(<span class=\"string\">'Subplot 1: Cosine'</span>)</span><br><span class=\"line\"><span class=\"comment\">% 2*2 分割的第二块区域也就是右上角</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">y_poly = <span class=\"number\">1</span> - x.^<span class=\"number\">2.</span>/<span class=\"number\">2</span> + x.^<span class=\"number\">4.</span>/<span class=\"number\">24</span>;</span><br><span class=\"line\">plot(x,y_poly,<span class=\"string\">'g'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'Subplot 2: Polynomial'</span>)</span><br><span class=\"line\"><span class=\"comment\">% 2*2 分割的第三、四块区域也就是下方</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"comment\">% 也可以写作 subplot(2,1,2); 指的是同一区域。</span></span><br><span class=\"line\">plot(x,y_cos,<span class=\"string\">'b'</span>,x,y_poly,<span class=\"string\">'g'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'Subplot 3 and 4: Both'</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-b2e3a5c17fe98d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.png\"></p>\n<h3 id=\"离散绘图\"><a href=\"#离散绘图\" class=\"headerlink\" title=\"离散绘图\"></a>离散绘图</h3><h4 id=\"茎干图（stem）\"><a href=\"#茎干图（stem）\" class=\"headerlink\" title=\"茎干图（stem）\"></a>茎干图（stem）</h4><p>stem 函数的功能是描述离散数据中的冲激函数，以绘图高度反映一维离散序列中脉冲的强度。</p>\n<p>数据值对应每一个脉冲的强度。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">figure(<span class=\"number\">1</span>)</span><br><span class=\"line\">X = <span class=\"built_in\">linspace</span>(<span class=\"number\">0</span>,<span class=\"number\">2</span>*<span class=\"built_in\">pi</span>,<span class=\"number\">50</span>)';</span><br><span class=\"line\">Y = <span class=\"built_in\">cos</span>(X);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">stem(X);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">stem(X,Y);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-3db50d1307370792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.png\"></p>\n<h4 id=\"阶梯图（stairs）\"><a href=\"#阶梯图（stairs）\" class=\"headerlink\" title=\"阶梯图（stairs）\"></a>阶梯图（stairs）</h4><p>stairs 函数的功能是描述离散数据中的阶跃函数，以绘图高度反映一维阶跃信号中的实时强度。</p>\n<p>数据值为每一个时间周期的高度。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = <span class=\"built_in\">linspace</span>(<span class=\"number\">0</span>,<span class=\"number\">4</span>*<span class=\"built_in\">pi</span>,<span class=\"number\">40</span>);</span><br><span class=\"line\">Y = <span class=\"built_in\">sin</span>(X);</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">stairs(Y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">stairs(X,Y);<span class=\"comment\">% 这种调用方式应当保证 X 有序</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-44b1b44ad66a1c64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.png\"></p>\n<h4 id=\"散点图（scatter）\"><a href=\"#散点图（scatter）\" class=\"headerlink\" title=\"散点图（scatter）\"></a>散点图（scatter）</h4><p>scatter 函数绘制二维平面上的散点图，也就是不绘制曲线的 plot 函数。</p>\n<p>输入参数为散点图的横坐标序列和纵坐标序列。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"built_in\">linspace</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>*<span class=\"built_in\">pi</span>,<span class=\"number\">200</span>);</span><br><span class=\"line\">y = <span class=\"built_in\">cos</span>(x) + <span class=\"built_in\">rand</span>(<span class=\"number\">1</span>,<span class=\"number\">200</span>); </span><br><span class=\"line\">M_size = <span class=\"built_in\">linspace</span>(<span class=\"number\">1</span>,<span class=\"number\">100</span>,<span class=\"number\">200</span>);</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">scatter(x,y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">scatter(x,y,M_size);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-8645080245b3169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"4.png\"></p>\n<h3 id=\"极坐标绘图\"><a href=\"#极坐标绘图\" class=\"headerlink\" title=\"极坐标绘图\"></a>极坐标绘图</h3><blockquote>\n<p>我们直到直角坐标和极坐标系都是常用的坐标系，并且两种坐标系之间存在一定的转换关系，但是用 plot 函数绘制转换后的极坐标系图形总是不美观。</p>\n</blockquote>\n<p><del>polar 函数是 MATLAB 中用于绘制极坐标图的函数。</del> </p>\n<p>polar 函数已经被 MATLAB 官方更替，更推荐使用的是新的函数方法：polarplot （新方法在旧版本的 MATLAB 如 2015b 版本仍不可用）。因此如果你在使用旧版本软件，使用 polar 方法；如果你在使用的版本支持 polarplot 函数，那就使用 polarplot 函数。</p>\n<p>polarplot 函数就是极坐标系下的 plot 函数。以 polarplot(theta,rho) 形式调用。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theta = <span class=\"number\">0</span>:<span class=\"number\">0.01</span>:<span class=\"number\">2</span>*<span class=\"built_in\">pi</span>; <span class=\"comment\">% 角度</span></span><br><span class=\"line\">rho = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*theta).*<span class=\"built_in\">cos</span>(<span class=\"number\">2</span>*theta); <span class=\"comment\">% 幅值</span></span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">polarplot(theta,rho); </span><br><span class=\"line\"><span class=\"comment\">% 此处有版本兼容问题，旧版本无法使用该函数</span></span><br><span class=\"line\"><span class=\"comment\">% 旧版本应当使用 polar(theta,rho);</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-eb9086dcb346a0fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"5.png\"></p>\n<p>同理，也有 polarscatter 函数。</p>\n<h3 id=\"曲面绘图\"><a href=\"#曲面绘图\" class=\"headerlink\" title=\"曲面绘图\"></a>曲面绘图</h3><blockquote>\n<p>曲线上的点是无限的，于是计算机用散点序列代替直线；曲面上由无数曲线构成，自然类比想到使用网格代替平面。</p>\n</blockquote>\n<h4 id=\"surf-函数\"><a href=\"#surf-函数\" class=\"headerlink\" title=\"surf 函数\"></a>surf 函数</h4><p>surf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；此外，函数将对三维曲面进行渲染，每个区域的颜色与高度成比例。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x0 = <span class=\"number\">1</span>:<span class=\"number\">0.5</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y0 = <span class=\"number\">1</span>:<span class=\"number\">20</span>;</span><br><span class=\"line\">[X,Y] = <span class=\"built_in\">meshgrid</span>(x0,y0);</span><br><span class=\"line\"><span class=\"comment\">% meshgrid 函数将创建两个由 x0*y0 构成的二维网格矩阵。</span></span><br><span class=\"line\"><span class=\"comment\">% X 表示网格中对应位置的 x0 值</span></span><br><span class=\"line\"><span class=\"comment\">% Y 表示网格中对应位置的 y0 值</span></span><br><span class=\"line\"><span class=\"comment\">% - 可以预见到对于同一个 y0 ，x0 值相同。</span></span><br><span class=\"line\">Z = <span class=\"built_in\">sin</span>(X) + <span class=\"built_in\">cos</span>(Y);</span><br><span class=\"line\">surf(X,Y,Z);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-665be90818752b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6.png\"></p>\n<p>其他 surf 类型曲面图函数</p>\n<ul>\n<li>surfc 函数：在 surf 函数的基础上，在底部绘制等高线图。</li>\n<li>surfl 函数：在 surf 函数的基础上，用光线为三维图渲染。</li>\n</ul>\n<h4 id=\"mesh-函数\"><a href=\"#mesh-函数\" class=\"headerlink\" title=\"mesh 函数\"></a>mesh 函数</h4><p>surf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；函数仅对于三维网格进行渲染，每个区域的颜色与高度成比例。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[X,Y] = <span class=\"built_in\">meshgrid</span>(<span class=\"number\">-8</span>:<span class=\"number\">.5</span>:<span class=\"number\">8</span>);</span><br><span class=\"line\">R = <span class=\"built_in\">sqrt</span>(X.^<span class=\"number\">2</span> + Y.^<span class=\"number\">2</span>) + <span class=\"built_in\">eps</span>;</span><br><span class=\"line\">Z = <span class=\"built_in\">sin</span>(R)./R;</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">mesh(Z);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-04ccb7ddf56e5af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"7.png\"></p>\n<p>其他 mesh 类型曲面图函数</p>\n<ul>\n<li>meshc函数：在 mesh 函数的基础上，在底部绘制等高线图。</li>\n<li>meshz 函数：在 mesh 函数的基础上，每个网格高度以柱状反映。</li>\n</ul>\n<h3 id=\"统计绘图\"><a href=\"#统计绘图\" class=\"headerlink\" title=\"统计绘图\"></a>统计绘图</h3><h4 id=\"bar-函数\"><a href=\"#bar-函数\" class=\"headerlink\" title=\"bar 函数\"></a>bar 函数</h4><p>bar 函数顾名思义是绘制条形图的函数。</p>\n<p>由于统计图表有着多种形式的表现需求，这里使用子窗口绘图来实现。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">190</span>:<span class=\"number\">1</span>:<span class=\"number\">200</span>;</span><br><span class=\"line\">y = [<span class=\"number\">75</span> <span class=\"number\">91</span> <span class=\"number\">105</span> <span class=\"number\">123.5</span> <span class=\"number\">131</span> <span class=\"number\">150</span> <span class=\"number\">179</span> <span class=\"number\">203</span> <span class=\"number\">226</span> <span class=\"number\">249</span> <span class=\"number\">281.5</span>];</span><br><span class=\"line\">z = [<span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">3</span>; <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"number\">6</span>; <span class=\"number\">2</span> <span class=\"number\">8</span> <span class=\"number\">9</span>; <span class=\"number\">2</span> <span class=\"number\">11</span> <span class=\"number\">12</span>];</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">bar(y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">bar(y,<span class=\"string\">'r'</span>)</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">bar(x,y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">bar(y,<span class=\"number\">0.4</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">bar(z);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">bar(z,<span class=\"string\">'stacked'</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-e5ae2f4e8eb59f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"8.png\"></p>\n<p>其他 bar 类型函数：</p>\n<ul>\n<li>bar3 函数：绘制三维条形图</li>\n<li>barh 函数：绘制水平条形图</li>\n<li>bar3h 函数：绘制三维水平条形图</li>\n</ul>\n<h4 id=\"histogram-函数\"><a href=\"#histogram-函数\" class=\"headerlink\" title=\"histogram 函数\"></a>histogram 函数</h4><p>histogram 函数的功能是根据传入的数据绘制统计直方图。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"built_in\">randn</span>(<span class=\"number\">10000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">% 10000 个高斯分布随机数</span></span><br><span class=\"line\">nbins = <span class=\"number\">25</span>; </span><br><span class=\"line\"><span class=\"comment\">% 直方图分布区间数量</span></span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">h = histogram(x);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">h = histogram(x,nbins);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-4d96bbabaa0c2ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"9.png\"></p>\n<p>其他 histogram 函数：</p>\n<ul>\n<li>histogram2 函数：绘制二元统计直方图；</li>\n<li>pareto 函数：绘制帕累托图</li>\n<li>polarhistogram 函数：在极坐标系上绘制根据角度绘制分布图</li>\n</ul>\n<h4 id=\"pie-函数\"><a href=\"#pie-函数\" class=\"headerlink\" title=\"pie 函数\"></a>pie 函数</h4><p>pie 函数的功能是根据传入的比例序列绘制饼状图。</p>\n<blockquote>\n<p>特别地：如果 pie(x) 中，</p>\n<ul>\n<li>sum(x) &lt; 1，仅绘制部分饼状图。</li>\n<li>sum(x) &gt; 1，先做归一化后绘制饼状图。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">X = [<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">0.5</span> <span class=\"number\">2.5</span> <span class=\"number\">2</span>];</span><br><span class=\"line\">explode = [<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span>];</span><br><span class=\"line\">labels = &#123;<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>&#125;;</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">pie(X);</span><br><span class=\"line\"><span class=\"comment\">% 归一化计算比例</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">pie(X,explode);</span><br><span class=\"line\"><span class=\"comment\">% explode 选中的块会突出显示</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">pie(X,labels);</span><br><span class=\"line\"><span class=\"comment\">% 以标签代替百分数</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">x1 = [<span class=\"number\">0.19</span> <span class=\"number\">0.22</span> <span class=\"number\">0.41</span>];</span><br><span class=\"line\">pie(x1);</span><br><span class=\"line\"><span class=\"comment\">% 不足 100% 则绘制部分饼状图</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-9b9861192e89d43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"10.png\"></p>\n<p>其他 pie 类型函数：</p>\n<ul>\n<li>pie3 函数：绘制三维饼状图；</li>\n</ul>\n<h4 id=\"其他可视化绘图\"><a href=\"#其他可视化绘图\" class=\"headerlink\" title=\"其他可视化绘图\"></a>其他可视化绘图</h4><blockquote>\n<p>这部分内容极少使用，不需要在意。</p>\n</blockquote>\n<p>heatmap 函数：根据数据集绘制热图；</p>\n<p>wordcloud 函数：使用文本数据创建词云图；</p>\n<p>geobubble 函数：以可视方式呈现特定地理位置的数据值</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本节中提到除了线图以外的另外四种常见绘图：离散绘图、极坐标绘图、曲面绘图和统计绘图。</p>\n<p>值得一提的是，对于极坐标绘图的函数方法，官方已经给出更佳的更新，但旧版本中无法应用，这里给出的为新版本的方案。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本次的内容涉及到除了线图以外的绘图，包括离散绘图、极坐标绘图、曲面绘图和统计绘图。</p>\n<ul>\n<li>离散绘图：茎干图、阶梯图和散点图</li>\n<li>极坐标绘图：polar前缀</li>\n<li>曲面绘图：surf 曲面图和 mesh 网格图</li>\n<li>统计绘图：条形图、统计直方图和饼状图</li>\n</ul>","more":"<h3 id=\"子窗口\"><a href=\"#子窗口\" class=\"headerlink\" title=\"子窗口\"></a>子窗口</h3><p>subplot 函数指的是将当前图窗划分为 <code>m</code>×<code>n</code> 网格，并在编号 <code>p</code> 指定的位置创建坐标区。</p>\n<p>编号规则为：从第一行自左向右递增。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% subplot(m,n,p);</span></span><br><span class=\"line\"><span class=\"comment\">% 将绘图窗口分为 m 行 n 列的矩形区域</span></span><br><span class=\"line\"><span class=\"comment\">% 并在编号第 p 的区域中绘图</span></span><br><span class=\"line\">figure();</span><br><span class=\"line\"><span class=\"comment\">% 2*2 分割的第一块区域也就是左上角</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>); </span><br><span class=\"line\">x = <span class=\"built_in\">linspace</span>(<span class=\"number\">-3.8</span>,<span class=\"number\">3.8</span>);</span><br><span class=\"line\">y_cos = <span class=\"built_in\">cos</span>(x);</span><br><span class=\"line\">plot(x,y_cos);</span><br><span class=\"line\">title(<span class=\"string\">'Subplot 1: Cosine'</span>)</span><br><span class=\"line\"><span class=\"comment\">% 2*2 分割的第二块区域也就是右上角</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">y_poly = <span class=\"number\">1</span> - x.^<span class=\"number\">2.</span>/<span class=\"number\">2</span> + x.^<span class=\"number\">4.</span>/<span class=\"number\">24</span>;</span><br><span class=\"line\">plot(x,y_poly,<span class=\"string\">'g'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'Subplot 2: Polynomial'</span>)</span><br><span class=\"line\"><span class=\"comment\">% 2*2 分割的第三、四块区域也就是下方</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"comment\">% 也可以写作 subplot(2,1,2); 指的是同一区域。</span></span><br><span class=\"line\">plot(x,y_cos,<span class=\"string\">'b'</span>,x,y_poly,<span class=\"string\">'g'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'Subplot 3 and 4: Both'</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-b2e3a5c17fe98d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.png\"></p>\n<h3 id=\"离散绘图\"><a href=\"#离散绘图\" class=\"headerlink\" title=\"离散绘图\"></a>离散绘图</h3><h4 id=\"茎干图（stem）\"><a href=\"#茎干图（stem）\" class=\"headerlink\" title=\"茎干图（stem）\"></a>茎干图（stem）</h4><p>stem 函数的功能是描述离散数据中的冲激函数，以绘图高度反映一维离散序列中脉冲的强度。</p>\n<p>数据值对应每一个脉冲的强度。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">figure(<span class=\"number\">1</span>)</span><br><span class=\"line\">X = <span class=\"built_in\">linspace</span>(<span class=\"number\">0</span>,<span class=\"number\">2</span>*<span class=\"built_in\">pi</span>,<span class=\"number\">50</span>)';</span><br><span class=\"line\">Y = <span class=\"built_in\">cos</span>(X);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">stem(X);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">stem(X,Y);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-3db50d1307370792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.png\"></p>\n<h4 id=\"阶梯图（stairs）\"><a href=\"#阶梯图（stairs）\" class=\"headerlink\" title=\"阶梯图（stairs）\"></a>阶梯图（stairs）</h4><p>stairs 函数的功能是描述离散数据中的阶跃函数，以绘图高度反映一维阶跃信号中的实时强度。</p>\n<p>数据值为每一个时间周期的高度。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = <span class=\"built_in\">linspace</span>(<span class=\"number\">0</span>,<span class=\"number\">4</span>*<span class=\"built_in\">pi</span>,<span class=\"number\">40</span>);</span><br><span class=\"line\">Y = <span class=\"built_in\">sin</span>(X);</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">stairs(Y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">stairs(X,Y);<span class=\"comment\">% 这种调用方式应当保证 X 有序</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-44b1b44ad66a1c64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.png\"></p>\n<h4 id=\"散点图（scatter）\"><a href=\"#散点图（scatter）\" class=\"headerlink\" title=\"散点图（scatter）\"></a>散点图（scatter）</h4><p>scatter 函数绘制二维平面上的散点图，也就是不绘制曲线的 plot 函数。</p>\n<p>输入参数为散点图的横坐标序列和纵坐标序列。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"built_in\">linspace</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>*<span class=\"built_in\">pi</span>,<span class=\"number\">200</span>);</span><br><span class=\"line\">y = <span class=\"built_in\">cos</span>(x) + <span class=\"built_in\">rand</span>(<span class=\"number\">1</span>,<span class=\"number\">200</span>); </span><br><span class=\"line\">M_size = <span class=\"built_in\">linspace</span>(<span class=\"number\">1</span>,<span class=\"number\">100</span>,<span class=\"number\">200</span>);</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">scatter(x,y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">scatter(x,y,M_size);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-8645080245b3169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"4.png\"></p>\n<h3 id=\"极坐标绘图\"><a href=\"#极坐标绘图\" class=\"headerlink\" title=\"极坐标绘图\"></a>极坐标绘图</h3><blockquote>\n<p>我们直到直角坐标和极坐标系都是常用的坐标系，并且两种坐标系之间存在一定的转换关系，但是用 plot 函数绘制转换后的极坐标系图形总是不美观。</p>\n</blockquote>\n<p><del>polar 函数是 MATLAB 中用于绘制极坐标图的函数。</del> </p>\n<p>polar 函数已经被 MATLAB 官方更替，更推荐使用的是新的函数方法：polarplot （新方法在旧版本的 MATLAB 如 2015b 版本仍不可用）。因此如果你在使用旧版本软件，使用 polar 方法；如果你在使用的版本支持 polarplot 函数，那就使用 polarplot 函数。</p>\n<p>polarplot 函数就是极坐标系下的 plot 函数。以 polarplot(theta,rho) 形式调用。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theta = <span class=\"number\">0</span>:<span class=\"number\">0.01</span>:<span class=\"number\">2</span>*<span class=\"built_in\">pi</span>; <span class=\"comment\">% 角度</span></span><br><span class=\"line\">rho = <span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*theta).*<span class=\"built_in\">cos</span>(<span class=\"number\">2</span>*theta); <span class=\"comment\">% 幅值</span></span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">polarplot(theta,rho); </span><br><span class=\"line\"><span class=\"comment\">% 此处有版本兼容问题，旧版本无法使用该函数</span></span><br><span class=\"line\"><span class=\"comment\">% 旧版本应当使用 polar(theta,rho);</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-eb9086dcb346a0fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"5.png\"></p>\n<p>同理，也有 polarscatter 函数。</p>\n<h3 id=\"曲面绘图\"><a href=\"#曲面绘图\" class=\"headerlink\" title=\"曲面绘图\"></a>曲面绘图</h3><blockquote>\n<p>曲线上的点是无限的，于是计算机用散点序列代替直线；曲面上由无数曲线构成，自然类比想到使用网格代替平面。</p>\n</blockquote>\n<h4 id=\"surf-函数\"><a href=\"#surf-函数\" class=\"headerlink\" title=\"surf 函数\"></a>surf 函数</h4><p>surf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；此外，函数将对三维曲面进行渲染，每个区域的颜色与高度成比例。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x0 = <span class=\"number\">1</span>:<span class=\"number\">0.5</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">y0 = <span class=\"number\">1</span>:<span class=\"number\">20</span>;</span><br><span class=\"line\">[X,Y] = <span class=\"built_in\">meshgrid</span>(x0,y0);</span><br><span class=\"line\"><span class=\"comment\">% meshgrid 函数将创建两个由 x0*y0 构成的二维网格矩阵。</span></span><br><span class=\"line\"><span class=\"comment\">% X 表示网格中对应位置的 x0 值</span></span><br><span class=\"line\"><span class=\"comment\">% Y 表示网格中对应位置的 y0 值</span></span><br><span class=\"line\"><span class=\"comment\">% - 可以预见到对于同一个 y0 ，x0 值相同。</span></span><br><span class=\"line\">Z = <span class=\"built_in\">sin</span>(X) + <span class=\"built_in\">cos</span>(Y);</span><br><span class=\"line\">surf(X,Y,Z);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-665be90818752b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6.png\"></p>\n<p>其他 surf 类型曲面图函数</p>\n<ul>\n<li>surfc 函数：在 surf 函数的基础上，在底部绘制等高线图。</li>\n<li>surfl 函数：在 surf 函数的基础上，用光线为三维图渲染。</li>\n</ul>\n<h4 id=\"mesh-函数\"><a href=\"#mesh-函数\" class=\"headerlink\" title=\"mesh 函数\"></a>mesh 函数</h4><p>surf 函数将创建一个三维曲面图。该函数将矩阵 Z 中的值绘制为由 X 和 Y 定义的 x-y 平面中的网格上方的高度；函数仅对于三维网格进行渲染，每个区域的颜色与高度成比例。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[X,Y] = <span class=\"built_in\">meshgrid</span>(<span class=\"number\">-8</span>:<span class=\"number\">.5</span>:<span class=\"number\">8</span>);</span><br><span class=\"line\">R = <span class=\"built_in\">sqrt</span>(X.^<span class=\"number\">2</span> + Y.^<span class=\"number\">2</span>) + <span class=\"built_in\">eps</span>;</span><br><span class=\"line\">Z = <span class=\"built_in\">sin</span>(R)./R;</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">mesh(Z);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-04ccb7ddf56e5af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"7.png\"></p>\n<p>其他 mesh 类型曲面图函数</p>\n<ul>\n<li>meshc函数：在 mesh 函数的基础上，在底部绘制等高线图。</li>\n<li>meshz 函数：在 mesh 函数的基础上，每个网格高度以柱状反映。</li>\n</ul>\n<h3 id=\"统计绘图\"><a href=\"#统计绘图\" class=\"headerlink\" title=\"统计绘图\"></a>统计绘图</h3><h4 id=\"bar-函数\"><a href=\"#bar-函数\" class=\"headerlink\" title=\"bar 函数\"></a>bar 函数</h4><p>bar 函数顾名思义是绘制条形图的函数。</p>\n<p>由于统计图表有着多种形式的表现需求，这里使用子窗口绘图来实现。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">190</span>:<span class=\"number\">1</span>:<span class=\"number\">200</span>;</span><br><span class=\"line\">y = [<span class=\"number\">75</span> <span class=\"number\">91</span> <span class=\"number\">105</span> <span class=\"number\">123.5</span> <span class=\"number\">131</span> <span class=\"number\">150</span> <span class=\"number\">179</span> <span class=\"number\">203</span> <span class=\"number\">226</span> <span class=\"number\">249</span> <span class=\"number\">281.5</span>];</span><br><span class=\"line\">z = [<span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">3</span>; <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"number\">6</span>; <span class=\"number\">2</span> <span class=\"number\">8</span> <span class=\"number\">9</span>; <span class=\"number\">2</span> <span class=\"number\">11</span> <span class=\"number\">12</span>];</span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">bar(y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">bar(y,<span class=\"string\">'r'</span>)</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">bar(x,y);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">bar(y,<span class=\"number\">0.4</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">bar(z);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">bar(z,<span class=\"string\">'stacked'</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-e5ae2f4e8eb59f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"8.png\"></p>\n<p>其他 bar 类型函数：</p>\n<ul>\n<li>bar3 函数：绘制三维条形图</li>\n<li>barh 函数：绘制水平条形图</li>\n<li>bar3h 函数：绘制三维水平条形图</li>\n</ul>\n<h4 id=\"histogram-函数\"><a href=\"#histogram-函数\" class=\"headerlink\" title=\"histogram 函数\"></a>histogram 函数</h4><p>histogram 函数的功能是根据传入的数据绘制统计直方图。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"built_in\">randn</span>(<span class=\"number\">10000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">% 10000 个高斯分布随机数</span></span><br><span class=\"line\">nbins = <span class=\"number\">25</span>; </span><br><span class=\"line\"><span class=\"comment\">% 直方图分布区间数量</span></span><br><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">h = histogram(x);</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">h = histogram(x,nbins);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-4d96bbabaa0c2ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"9.png\"></p>\n<p>其他 histogram 函数：</p>\n<ul>\n<li>histogram2 函数：绘制二元统计直方图；</li>\n<li>pareto 函数：绘制帕累托图</li>\n<li>polarhistogram 函数：在极坐标系上绘制根据角度绘制分布图</li>\n</ul>\n<h4 id=\"pie-函数\"><a href=\"#pie-函数\" class=\"headerlink\" title=\"pie 函数\"></a>pie 函数</h4><p>pie 函数的功能是根据传入的比例序列绘制饼状图。</p>\n<blockquote>\n<p>特别地：如果 pie(x) 中，</p>\n<ul>\n<li>sum(x) &lt; 1，仅绘制部分饼状图。</li>\n<li>sum(x) &gt; 1，先做归一化后绘制饼状图。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">figure(<span class=\"number\">1</span>);</span><br><span class=\"line\">X = [<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">0.5</span> <span class=\"number\">2.5</span> <span class=\"number\">2</span>];</span><br><span class=\"line\">explode = [<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span>];</span><br><span class=\"line\">labels = &#123;<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>&#125;;</span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">pie(X);</span><br><span class=\"line\"><span class=\"comment\">% 归一化计算比例</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">pie(X,explode);</span><br><span class=\"line\"><span class=\"comment\">% explode 选中的块会突出显示</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">pie(X,labels);</span><br><span class=\"line\"><span class=\"comment\">% 以标签代替百分数</span></span><br><span class=\"line\">subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\">x1 = [<span class=\"number\">0.19</span> <span class=\"number\">0.22</span> <span class=\"number\">0.41</span>];</span><br><span class=\"line\">pie(x1);</span><br><span class=\"line\"><span class=\"comment\">% 不足 100% 则绘制部分饼状图</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8078350-9b9861192e89d43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"10.png\"></p>\n<p>其他 pie 类型函数：</p>\n<ul>\n<li>pie3 函数：绘制三维饼状图；</li>\n</ul>\n<h4 id=\"其他可视化绘图\"><a href=\"#其他可视化绘图\" class=\"headerlink\" title=\"其他可视化绘图\"></a>其他可视化绘图</h4><blockquote>\n<p>这部分内容极少使用，不需要在意。</p>\n</blockquote>\n<p>heatmap 函数：根据数据集绘制热图；</p>\n<p>wordcloud 函数：使用文本数据创建词云图；</p>\n<p>geobubble 函数：以可视方式呈现特定地理位置的数据值</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>本节中提到除了线图以外的另外四种常见绘图：离散绘图、极坐标绘图、曲面绘图和统计绘图。</p>\n<p>值得一提的是，对于极坐标绘图的函数方法，官方已经给出更佳的更新，但旧版本中无法应用，这里给出的为新版本的方案。</p>"},{"title":"MATLAB 语法","date":"2018-03-05T19:46:31.000Z","_content":"\n### **概述**  \n\n上次内容，我们介绍了 MATLAB 中逻辑类型（logical）的变量，这种变量只有两种值： true 和 false。本次介绍的内容是 MATLAB 的一些语法结构包括我们最常用的条件结构和循环结构。条件结构是根据程序的执行结果选择应当执行的命令。循环结构是根据程序重复执行一系列语句的结构。两种结构都是程序结构的基础内容。从这一章开始，所有问题都可以得到理论上的解决了。\n\n<!--more-->\n\n### **变量名**\n\n我们之前介绍过变量在使用的时候，可以直接使用诸如 “ a = 1 ” 的方式直接赋值，也特地提到过一些特殊的参数值（如 pi, inf, NaN, i, j）不应当作为变量名使用。那么使用变量名到底有哪些应该注意的点：\n\nA. 严格规定的变量名的格式：（一定不能做的事，做了会报错的情况）  \n1.MATLAB 变量名必须以**字母**开头  \n2.可以使用的字符为**字母，下划线和数字**\n3.长度不能过大，**31个字符**是最大长度。\n4.字符是**区分大小写**的。\n5.不能使用系统预留的关键字（可以使用 iskeyword 命令查看关键字列表）。\n\nB. 理想的变量名格式：（推荐做的事）  \n1.MATLAB 变量名最好是有意义容易理解的名称如： success_rate  \n2.尽管不能在变量名中使用空格，可以用下划线代替空格连接单词来表达变量意义。\n3.没有特殊需要时，尽量使用小写字母（ A 和 a 是不同的变量）\n4.不要重复使用已经使用过的变量名，尽管你之后不再需要使用这个变量。\n\n### **条件结构**\n\n条件结构的特点是程序会根据不同条件选择不同的执行命令。MATLAB 中条件结构有两种： if 语句和 switch 语句，其中 if 语句是我们最常见的一种用法。\n\n#### if 语句\n\nif 语句是根据一个逻辑值加以判断一个语句是否运行的语句，能对逻辑值进行判断，并在该逻辑值为 true 时执行对应的语句。（在上一次内容中我们讲到，一个逻辑值可以是一个数，一个逻辑命题甚至一串复合的逻辑表达式，在这里也适用）。\nif 语句的标准格式就是：if + 空格 + 逻辑条件 开头，end 结尾，中间行 true 条件下执行的一段代码。\n``` \nif 逻辑条件\n    true 条件下的代码段;\nend\n```\nif 语句还可以加入两个关键字： **else** 和 **elseif** 。\n\nelse 就是补充 if 判断为 false 的情况。\n``` \nif 逻辑条件\n    true 条件下的代码段;\nelse\n    false 条件下的代码段；\nend\n```\n\nelseif 是针对嵌套使用 if 语句使用的，在分支较多时优化结构\n``` \nif 逻辑条件 1 \n    条件 1 为 true 代码段;\nelseif 逻辑条件 2\n    条件 1 为 false 且条件 2 为 true 代码段;\n    ...\nelseif 逻辑条件k  \n    先前所有条件为 false ，条件 k 为 true 代码段；\nend\n```\n#### if 语句实例\n```\n% if 语句\n\n% 样例 1\ndisp('样例 1 ')\n% if 语句仅在逻辑值为 true 是执行对应的命令\na = 1;\nb = 2;\nif b > a\n    disp('statement 1');\nend\nif b > a\n    disp('statement 2');\nend\n\n% 样例 2\ndisp('样例 2 ')\n% if 语句可以使用 else 作为判断条件的补集\n% 也就是说，若为 false 则运行。\na = 3;\nb = 2;\nif b > a\n    disp('statement 3');\nelse\n    disp('statement 4');\nend\n\n% 样例 3\ndisp('样例 3 ')\n% if 语句可以嵌套使用，在 if 语句中使用 if 语句\na = 3;\nif a < 2\n    disp('statement 5');\nelse % 此处可以不必换行\n    if a < 5\n        disp('statement 6');\n    else\n        disp('statement 7');\n    end\nend\n\n% 样例 4\ndisp('样例 4 ')\n% 观察到样例 3 在区间数量多的时候要嵌套很多次\n% 因此可以使用另一个关键字 elseif 简化。\n% 以下代码与样例 3 是等价的\na = 3;\nif a < 2\n    disp('statement 5');\nelseif a < 5\n    disp('statement 6');\nelse\n    disp('statement 7');\nend\n\n% 样例5\ndisp('样例 5 ')\n% elseif 连接的分支条件关系越来越宽松，可以从排分数实例来看\nscore = 67;\nif score == 100\n    disp('满分');\nelseif score > 90\n    disp('优秀');\nelseif score > 80\n    disp('良好');\nelseif score > 70\n    disp('中');\nelseif score > 60\n    disp('及格');\nelse\n    disp('不及格');\nend\n% 每一级条件都是下一级条件的子集，条件越来越宽松。\n```\n#### 测试结果\n```\n样例 1 \nstatement 1\nstatement 2\n样例 2 \nstatement 4\n样例 3 \nstatement 6\n样例 4 \nstatement 6\n样例 5 \n及格\n```\n#### if 语句注意的问题\n1.首先是判断条件：判断条件如果是等式，请务必记得等式是用 **'=='** 连接的。\n2.使用嵌套 if 语句时，会形成 else if 应当与 elseif 区分开。\n3.使用嵌套 if 语句时，判断条件之间的相互关系很复杂，应当仔细区分开。\n4.如果你觉得2，3很麻烦，请无脑使用 elseif\n5.用 elseif 连接的各个分支条件都是**越来越宽松**，对于多分支条件结构能很好简化。\n\n#### switch 语句\n\nswitch 语句需要提供一个变量，针对这个变量可能的值进行选择分支的语句。也就是查这个变量是什么可能值，如果找到了这个值则运行对应命令。特别的，switch 语句只能对**离散值**生效(case 数量有限)，并且每一个 case 都必须不同（否则只执行第一个 case ，并且会给出警告），在给出的下列案例中，尽管用 if 语句理论上也可以实现同等效果，但是 switch 语句的可读性更好。\n\n#### switch 语句实例\n```\n% switch 语句\n\n% 计算机会这样操作：\n% 1.开始查询以下的 case 是否有刚好等于 str 的值\n% 2.若有刚好等于 str 的值，则执行对应命令\n% 3.若没有，则执行 otherwise 对应命令\n% 4.若连 otherwise 也没有，则 switch 语句结束，不做任何事。\n\nstr = '周三';\nswitch str\n    case '周一'\n        disp('工作日 1');\n    case '周二'\n        disp('工作日 2');\n    case '周三'\n        disp('工作日 3');\n    case '周四'\n        disp('工作日 4');\n    case '周五'\n        disp('工作日 5');\n    otherwise\n        disp('休息');\nend\n```\n#### 测试结果\n```\n工作日 3\n```\n\n### **循环结构**\n\n循环结构也分为两种：for 循环和 while 循环。循环结构的目的显而易见：重复多次地执行同一段代码。\nfor   循环用于**按次数循环**，循环次数为指定的向量长度。\nwhile 循环用于**按条件循环**，只要逻辑变量为 true 则重复循环。\n\n#### for 循环\n\nfor 循环用于**特定的次数**的循环，最大特点是只要达到次数就会停止。\nfor 使用的格式为：for + 空格 + 索引向量 开头，end 结尾，中间为应循环的一段代码。\n```\nfor 索引 = 索引向量\n    循环的代码段\nend\n```\n#### for 循环样例\n```\n% 样例 1\ndisp('样例 1 ')\n% 这个样例说明循环次数取决于你指定向量的长度\na = 0;\n% \nfor index_1 = 2:10\n    a = a + 1;\nend\ndisp(a);\n\n% 样例 2 \ndisp('样例 2 ')\n% 循环中使用索引（index_2）时\n% 每次index_2的值为指定的索引向量对应当前循环次数的值。\nb = 0;\n% \nfor index_2 = 2:10\n    b = b + index_2;\nend\ndisp(b);\n\n% 样例 3\ndisp('样例 3 ')\n% 循环也可以嵌套，但需要使用不同的循环索引\nc = zeros(5,5);\nfor index_3 = 1:5\n   for index_4 = 1:5\n        c(index_3,index_4) = sqrt(index_3^2 + index_4^2);\n   end\nend\ndisp(c);\n```\n#### 测试结果\n```\n样例 1 \n     9\n\n样例 2 \n    54\n\n样例 3 \n    1.4142    2.2361    3.1623    4.1231    5.0990\n    2.2361    2.8284    3.6056    4.4721    5.3852\n    3.1623    3.6056    4.2426    5.0000    5.8310\n    4.1231    4.4721    5.0000    5.6569    6.4031\n    5.0990    5.3852    5.8310    6.4031    7.0711\n```\n#### **while 循环**\n\nwhile 循环用于**特定条件下**的循环，最大特点是只要出现一次 false 就会停止。\nwhile 循环使用的格式为：while + 空格 + 逻辑条件 开头，end 结尾，中间行为循环的代码。\n```\nwhile 逻辑条件\n    循环的代码段\nend\n```\n#### while 循环样例\n```\n% 样例 1\ndisp('样例 1 ')\n% 求解 1+2+3+...+k>100的最小整数解  \nk = 0;\nsum = 0;\nwhile sum <= 100\n    sum = sum + k;\n    k = k + 1;\nend\ndisp(k);\n\n% 样例 2\ndisp('样例 2 ')\n% 用泰勒级数逼近自然底数exp(1)，将相对误差控制在10^-4内\nk = 0;\nsum = 0; \nwhile abs((sum-exp(1))/exp(1)) > 1e-4\n    sum = sum + 1/factorial(k);    \n    k = k + 1;\nend\ndisp(sum);\n\n\n% 样例 3\ndisp('样例 3 ')\n% 最简单的死循环: 判断条件永远成立。\n% 可以用 Ctrl + C 强制中断运行。\nwhile 1\n    ;\nend\n```\n#### 测试结果\n```\n样例 1 \n    15\n\n样例 2 \n    2.7181\n```\n\n#### 循环的补充\n\n关于循环还用到另外两个关键字： **continue** 和 **break** 。\n\n这两个关键字作用很像但有很大区别：\n\n**continue** ：放弃当前**这一次循环**，开始下一次循环（循环次数 +1）\n\n**break** ：放弃当前**这一层循环**，循环直接终止。\n\n下面来看看这两个关键字的应用：\n#### continue, break\n```\n% 用循环观察输出\n% 当 index == 3 时，执行 continue ,跳过了 3 而到 4；\n% 当 index == 5 时，执行 break ,循环直接终止，5 6 7都没有执行；\nfor index = 1 : 7\n    if index == 3 \n        continue;\n    end\n    if index == 5\n        break;\n    end\n    disp(index);\nend\n```\n#### 测试输出\n```\n     1\n\n     2\n\n     4\n```\n\n#### 循环应该注意的问题\n\n1.每一个 for 循环理论上都可以使用 while 循环实现（在 while 循环添加索引，以索引作为判断条件），实际上这样处理是没有什么意义的，反而会使代码更加晦涩，我们只需要根据需要使用对应的方法即可。\n2.for 循环需要使用索引向量，请尽可能保证你每次使用的**循环索引变量名都不同**（嵌套循环中必须不同，否则内层循环无法识别，会出现意想不到的错误）。控制变量名不同的好处在于，容易区分每一步循环的意义，并且容易使用查找替换修改。\n3.使用 while 循环不注意就可能写出死循环，比如判断条件为 A 大于 B ，然而 A-B 却不断增大。\n4.对于复杂的循环结构，可以使用 continue 和 break 实现简化。\n5.对于 MATLAB 而言，很多操作使用循环会大大降低运算速度，比如创建很大的零矩阵500×500×500，使用矩阵操作和内置函数能大大提高效率。\n\n### **小结**\n\n本节过后，理论上很多问题可以用 MATLAB 来解决了。条件和循环结构也会用于许多实际问题，读者在掌握两种结构的时候也应该注意使用者两种结构可能导致的问题。其中一些问题若没有注意到，可能会导致难以发现的异常，会给自己带来不少麻烦。\n\n","source":"_posts/MATLAB-语法.md","raw":"---\ntitle: MATLAB 语法\ndate: 2018-03-06 03:46:31\ntags: MATLAB\n\n---\n\n### **概述**  \n\n上次内容，我们介绍了 MATLAB 中逻辑类型（logical）的变量，这种变量只有两种值： true 和 false。本次介绍的内容是 MATLAB 的一些语法结构包括我们最常用的条件结构和循环结构。条件结构是根据程序的执行结果选择应当执行的命令。循环结构是根据程序重复执行一系列语句的结构。两种结构都是程序结构的基础内容。从这一章开始，所有问题都可以得到理论上的解决了。\n\n<!--more-->\n\n### **变量名**\n\n我们之前介绍过变量在使用的时候，可以直接使用诸如 “ a = 1 ” 的方式直接赋值，也特地提到过一些特殊的参数值（如 pi, inf, NaN, i, j）不应当作为变量名使用。那么使用变量名到底有哪些应该注意的点：\n\nA. 严格规定的变量名的格式：（一定不能做的事，做了会报错的情况）  \n1.MATLAB 变量名必须以**字母**开头  \n2.可以使用的字符为**字母，下划线和数字**\n3.长度不能过大，**31个字符**是最大长度。\n4.字符是**区分大小写**的。\n5.不能使用系统预留的关键字（可以使用 iskeyword 命令查看关键字列表）。\n\nB. 理想的变量名格式：（推荐做的事）  \n1.MATLAB 变量名最好是有意义容易理解的名称如： success_rate  \n2.尽管不能在变量名中使用空格，可以用下划线代替空格连接单词来表达变量意义。\n3.没有特殊需要时，尽量使用小写字母（ A 和 a 是不同的变量）\n4.不要重复使用已经使用过的变量名，尽管你之后不再需要使用这个变量。\n\n### **条件结构**\n\n条件结构的特点是程序会根据不同条件选择不同的执行命令。MATLAB 中条件结构有两种： if 语句和 switch 语句，其中 if 语句是我们最常见的一种用法。\n\n#### if 语句\n\nif 语句是根据一个逻辑值加以判断一个语句是否运行的语句，能对逻辑值进行判断，并在该逻辑值为 true 时执行对应的语句。（在上一次内容中我们讲到，一个逻辑值可以是一个数，一个逻辑命题甚至一串复合的逻辑表达式，在这里也适用）。\nif 语句的标准格式就是：if + 空格 + 逻辑条件 开头，end 结尾，中间行 true 条件下执行的一段代码。\n``` \nif 逻辑条件\n    true 条件下的代码段;\nend\n```\nif 语句还可以加入两个关键字： **else** 和 **elseif** 。\n\nelse 就是补充 if 判断为 false 的情况。\n``` \nif 逻辑条件\n    true 条件下的代码段;\nelse\n    false 条件下的代码段；\nend\n```\n\nelseif 是针对嵌套使用 if 语句使用的，在分支较多时优化结构\n``` \nif 逻辑条件 1 \n    条件 1 为 true 代码段;\nelseif 逻辑条件 2\n    条件 1 为 false 且条件 2 为 true 代码段;\n    ...\nelseif 逻辑条件k  \n    先前所有条件为 false ，条件 k 为 true 代码段；\nend\n```\n#### if 语句实例\n```\n% if 语句\n\n% 样例 1\ndisp('样例 1 ')\n% if 语句仅在逻辑值为 true 是执行对应的命令\na = 1;\nb = 2;\nif b > a\n    disp('statement 1');\nend\nif b > a\n    disp('statement 2');\nend\n\n% 样例 2\ndisp('样例 2 ')\n% if 语句可以使用 else 作为判断条件的补集\n% 也就是说，若为 false 则运行。\na = 3;\nb = 2;\nif b > a\n    disp('statement 3');\nelse\n    disp('statement 4');\nend\n\n% 样例 3\ndisp('样例 3 ')\n% if 语句可以嵌套使用，在 if 语句中使用 if 语句\na = 3;\nif a < 2\n    disp('statement 5');\nelse % 此处可以不必换行\n    if a < 5\n        disp('statement 6');\n    else\n        disp('statement 7');\n    end\nend\n\n% 样例 4\ndisp('样例 4 ')\n% 观察到样例 3 在区间数量多的时候要嵌套很多次\n% 因此可以使用另一个关键字 elseif 简化。\n% 以下代码与样例 3 是等价的\na = 3;\nif a < 2\n    disp('statement 5');\nelseif a < 5\n    disp('statement 6');\nelse\n    disp('statement 7');\nend\n\n% 样例5\ndisp('样例 5 ')\n% elseif 连接的分支条件关系越来越宽松，可以从排分数实例来看\nscore = 67;\nif score == 100\n    disp('满分');\nelseif score > 90\n    disp('优秀');\nelseif score > 80\n    disp('良好');\nelseif score > 70\n    disp('中');\nelseif score > 60\n    disp('及格');\nelse\n    disp('不及格');\nend\n% 每一级条件都是下一级条件的子集，条件越来越宽松。\n```\n#### 测试结果\n```\n样例 1 \nstatement 1\nstatement 2\n样例 2 \nstatement 4\n样例 3 \nstatement 6\n样例 4 \nstatement 6\n样例 5 \n及格\n```\n#### if 语句注意的问题\n1.首先是判断条件：判断条件如果是等式，请务必记得等式是用 **'=='** 连接的。\n2.使用嵌套 if 语句时，会形成 else if 应当与 elseif 区分开。\n3.使用嵌套 if 语句时，判断条件之间的相互关系很复杂，应当仔细区分开。\n4.如果你觉得2，3很麻烦，请无脑使用 elseif\n5.用 elseif 连接的各个分支条件都是**越来越宽松**，对于多分支条件结构能很好简化。\n\n#### switch 语句\n\nswitch 语句需要提供一个变量，针对这个变量可能的值进行选择分支的语句。也就是查这个变量是什么可能值，如果找到了这个值则运行对应命令。特别的，switch 语句只能对**离散值**生效(case 数量有限)，并且每一个 case 都必须不同（否则只执行第一个 case ，并且会给出警告），在给出的下列案例中，尽管用 if 语句理论上也可以实现同等效果，但是 switch 语句的可读性更好。\n\n#### switch 语句实例\n```\n% switch 语句\n\n% 计算机会这样操作：\n% 1.开始查询以下的 case 是否有刚好等于 str 的值\n% 2.若有刚好等于 str 的值，则执行对应命令\n% 3.若没有，则执行 otherwise 对应命令\n% 4.若连 otherwise 也没有，则 switch 语句结束，不做任何事。\n\nstr = '周三';\nswitch str\n    case '周一'\n        disp('工作日 1');\n    case '周二'\n        disp('工作日 2');\n    case '周三'\n        disp('工作日 3');\n    case '周四'\n        disp('工作日 4');\n    case '周五'\n        disp('工作日 5');\n    otherwise\n        disp('休息');\nend\n```\n#### 测试结果\n```\n工作日 3\n```\n\n### **循环结构**\n\n循环结构也分为两种：for 循环和 while 循环。循环结构的目的显而易见：重复多次地执行同一段代码。\nfor   循环用于**按次数循环**，循环次数为指定的向量长度。\nwhile 循环用于**按条件循环**，只要逻辑变量为 true 则重复循环。\n\n#### for 循环\n\nfor 循环用于**特定的次数**的循环，最大特点是只要达到次数就会停止。\nfor 使用的格式为：for + 空格 + 索引向量 开头，end 结尾，中间为应循环的一段代码。\n```\nfor 索引 = 索引向量\n    循环的代码段\nend\n```\n#### for 循环样例\n```\n% 样例 1\ndisp('样例 1 ')\n% 这个样例说明循环次数取决于你指定向量的长度\na = 0;\n% \nfor index_1 = 2:10\n    a = a + 1;\nend\ndisp(a);\n\n% 样例 2 \ndisp('样例 2 ')\n% 循环中使用索引（index_2）时\n% 每次index_2的值为指定的索引向量对应当前循环次数的值。\nb = 0;\n% \nfor index_2 = 2:10\n    b = b + index_2;\nend\ndisp(b);\n\n% 样例 3\ndisp('样例 3 ')\n% 循环也可以嵌套，但需要使用不同的循环索引\nc = zeros(5,5);\nfor index_3 = 1:5\n   for index_4 = 1:5\n        c(index_3,index_4) = sqrt(index_3^2 + index_4^2);\n   end\nend\ndisp(c);\n```\n#### 测试结果\n```\n样例 1 \n     9\n\n样例 2 \n    54\n\n样例 3 \n    1.4142    2.2361    3.1623    4.1231    5.0990\n    2.2361    2.8284    3.6056    4.4721    5.3852\n    3.1623    3.6056    4.2426    5.0000    5.8310\n    4.1231    4.4721    5.0000    5.6569    6.4031\n    5.0990    5.3852    5.8310    6.4031    7.0711\n```\n#### **while 循环**\n\nwhile 循环用于**特定条件下**的循环，最大特点是只要出现一次 false 就会停止。\nwhile 循环使用的格式为：while + 空格 + 逻辑条件 开头，end 结尾，中间行为循环的代码。\n```\nwhile 逻辑条件\n    循环的代码段\nend\n```\n#### while 循环样例\n```\n% 样例 1\ndisp('样例 1 ')\n% 求解 1+2+3+...+k>100的最小整数解  \nk = 0;\nsum = 0;\nwhile sum <= 100\n    sum = sum + k;\n    k = k + 1;\nend\ndisp(k);\n\n% 样例 2\ndisp('样例 2 ')\n% 用泰勒级数逼近自然底数exp(1)，将相对误差控制在10^-4内\nk = 0;\nsum = 0; \nwhile abs((sum-exp(1))/exp(1)) > 1e-4\n    sum = sum + 1/factorial(k);    \n    k = k + 1;\nend\ndisp(sum);\n\n\n% 样例 3\ndisp('样例 3 ')\n% 最简单的死循环: 判断条件永远成立。\n% 可以用 Ctrl + C 强制中断运行。\nwhile 1\n    ;\nend\n```\n#### 测试结果\n```\n样例 1 \n    15\n\n样例 2 \n    2.7181\n```\n\n#### 循环的补充\n\n关于循环还用到另外两个关键字： **continue** 和 **break** 。\n\n这两个关键字作用很像但有很大区别：\n\n**continue** ：放弃当前**这一次循环**，开始下一次循环（循环次数 +1）\n\n**break** ：放弃当前**这一层循环**，循环直接终止。\n\n下面来看看这两个关键字的应用：\n#### continue, break\n```\n% 用循环观察输出\n% 当 index == 3 时，执行 continue ,跳过了 3 而到 4；\n% 当 index == 5 时，执行 break ,循环直接终止，5 6 7都没有执行；\nfor index = 1 : 7\n    if index == 3 \n        continue;\n    end\n    if index == 5\n        break;\n    end\n    disp(index);\nend\n```\n#### 测试输出\n```\n     1\n\n     2\n\n     4\n```\n\n#### 循环应该注意的问题\n\n1.每一个 for 循环理论上都可以使用 while 循环实现（在 while 循环添加索引，以索引作为判断条件），实际上这样处理是没有什么意义的，反而会使代码更加晦涩，我们只需要根据需要使用对应的方法即可。\n2.for 循环需要使用索引向量，请尽可能保证你每次使用的**循环索引变量名都不同**（嵌套循环中必须不同，否则内层循环无法识别，会出现意想不到的错误）。控制变量名不同的好处在于，容易区分每一步循环的意义，并且容易使用查找替换修改。\n3.使用 while 循环不注意就可能写出死循环，比如判断条件为 A 大于 B ，然而 A-B 却不断增大。\n4.对于复杂的循环结构，可以使用 continue 和 break 实现简化。\n5.对于 MATLAB 而言，很多操作使用循环会大大降低运算速度，比如创建很大的零矩阵500×500×500，使用矩阵操作和内置函数能大大提高效率。\n\n### **小结**\n\n本节过后，理论上很多问题可以用 MATLAB 来解决了。条件和循环结构也会用于许多实际问题，读者在掌握两种结构的时候也应该注意使用者两种结构可能导致的问题。其中一些问题若没有注意到，可能会导致难以发现的异常，会给自己带来不少麻烦。\n\n","slug":"MATLAB-语法","published":1,"updated":"2020-03-15T21:05:07.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wk000p29fyvb56uer4","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>上次内容，我们介绍了 MATLAB 中逻辑类型（logical）的变量，这种变量只有两种值： true 和 false。本次介绍的内容是 MATLAB 的一些语法结构包括我们最常用的条件结构和循环结构。条件结构是根据程序的执行结果选择应当执行的命令。循环结构是根据程序重复执行一系列语句的结构。两种结构都是程序结构的基础内容。从这一章开始，所有问题都可以得到理论上的解决了。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a><strong>变量名</strong></h3><p>我们之前介绍过变量在使用的时候，可以直接使用诸如 “ a = 1 ” 的方式直接赋值，也特地提到过一些特殊的参数值（如 pi, inf, NaN, i, j）不应当作为变量名使用。那么使用变量名到底有哪些应该注意的点：</p>\n<p>A. 严格规定的变量名的格式：（一定不能做的事，做了会报错的情况）<br>1.MATLAB 变量名必须以<strong>字母</strong>开头<br>2.可以使用的字符为<strong>字母，下划线和数字</strong><br>3.长度不能过大，<strong>31个字符</strong>是最大长度。<br>4.字符是<strong>区分大小写</strong>的。<br>5.不能使用系统预留的关键字（可以使用 iskeyword 命令查看关键字列表）。</p>\n<p>B. 理想的变量名格式：（推荐做的事）<br>1.MATLAB 变量名最好是有意义容易理解的名称如： success_rate<br>2.尽管不能在变量名中使用空格，可以用下划线代替空格连接单词来表达变量意义。<br>3.没有特殊需要时，尽量使用小写字母（ A 和 a 是不同的变量）<br>4.不要重复使用已经使用过的变量名，尽管你之后不再需要使用这个变量。</p>\n<h3 id=\"条件结构\"><a href=\"#条件结构\" class=\"headerlink\" title=\"条件结构\"></a><strong>条件结构</strong></h3><p>条件结构的特点是程序会根据不同条件选择不同的执行命令。MATLAB 中条件结构有两种： if 语句和 switch 语句，其中 if 语句是我们最常见的一种用法。</p>\n<h4 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h4><p>if 语句是根据一个逻辑值加以判断一个语句是否运行的语句，能对逻辑值进行判断，并在该逻辑值为 true 时执行对应的语句。（在上一次内容中我们讲到，一个逻辑值可以是一个数，一个逻辑命题甚至一串复合的逻辑表达式，在这里也适用）。<br>if 语句的标准格式就是：if + 空格 + 逻辑条件 开头，end 结尾，中间行 true 条件下执行的一段代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 逻辑条件</span><br><span class=\"line\">    true 条件下的代码段;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>if 语句还可以加入两个关键字： <strong>else</strong> 和 <strong>elseif</strong> 。</p>\n<p>else 就是补充 if 判断为 false 的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 逻辑条件</span><br><span class=\"line\">    true 条件下的代码段;</span><br><span class=\"line\">else</span><br><span class=\"line\">    false 条件下的代码段；</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>elseif 是针对嵌套使用 if 语句使用的，在分支较多时优化结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 逻辑条件 1 </span><br><span class=\"line\">    条件 1 为 true 代码段;</span><br><span class=\"line\">elseif 逻辑条件 2</span><br><span class=\"line\">    条件 1 为 false 且条件 2 为 true 代码段;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">elseif 逻辑条件k  </span><br><span class=\"line\">    先前所有条件为 false ，条件 k 为 true 代码段；</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"if-语句实例\"><a href=\"#if-语句实例\" class=\"headerlink\" title=\"if 语句实例\"></a>if 语句实例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% if 语句</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 1</span><br><span class=\"line\">disp(&apos;样例 1 &apos;)</span><br><span class=\"line\">% if 语句仅在逻辑值为 true 是执行对应的命令</span><br><span class=\"line\">a = 1;</span><br><span class=\"line\">b = 2;</span><br><span class=\"line\">if b &gt; a</span><br><span class=\"line\">    disp(&apos;statement 1&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\">if b &gt; a</span><br><span class=\"line\">    disp(&apos;statement 2&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 2</span><br><span class=\"line\">disp(&apos;样例 2 &apos;)</span><br><span class=\"line\">% if 语句可以使用 else 作为判断条件的补集</span><br><span class=\"line\">% 也就是说，若为 false 则运行。</span><br><span class=\"line\">a = 3;</span><br><span class=\"line\">b = 2;</span><br><span class=\"line\">if b &gt; a</span><br><span class=\"line\">    disp(&apos;statement 3&apos;);</span><br><span class=\"line\">else</span><br><span class=\"line\">    disp(&apos;statement 4&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 3</span><br><span class=\"line\">disp(&apos;样例 3 &apos;)</span><br><span class=\"line\">% if 语句可以嵌套使用，在 if 语句中使用 if 语句</span><br><span class=\"line\">a = 3;</span><br><span class=\"line\">if a &lt; 2</span><br><span class=\"line\">    disp(&apos;statement 5&apos;);</span><br><span class=\"line\">else % 此处可以不必换行</span><br><span class=\"line\">    if a &lt; 5</span><br><span class=\"line\">        disp(&apos;statement 6&apos;);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        disp(&apos;statement 7&apos;);</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 4</span><br><span class=\"line\">disp(&apos;样例 4 &apos;)</span><br><span class=\"line\">% 观察到样例 3 在区间数量多的时候要嵌套很多次</span><br><span class=\"line\">% 因此可以使用另一个关键字 elseif 简化。</span><br><span class=\"line\">% 以下代码与样例 3 是等价的</span><br><span class=\"line\">a = 3;</span><br><span class=\"line\">if a &lt; 2</span><br><span class=\"line\">    disp(&apos;statement 5&apos;);</span><br><span class=\"line\">elseif a &lt; 5</span><br><span class=\"line\">    disp(&apos;statement 6&apos;);</span><br><span class=\"line\">else</span><br><span class=\"line\">    disp(&apos;statement 7&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例5</span><br><span class=\"line\">disp(&apos;样例 5 &apos;)</span><br><span class=\"line\">% elseif 连接的分支条件关系越来越宽松，可以从排分数实例来看</span><br><span class=\"line\">score = 67;</span><br><span class=\"line\">if score == 100</span><br><span class=\"line\">    disp(&apos;满分&apos;);</span><br><span class=\"line\">elseif score &gt; 90</span><br><span class=\"line\">    disp(&apos;优秀&apos;);</span><br><span class=\"line\">elseif score &gt; 80</span><br><span class=\"line\">    disp(&apos;良好&apos;);</span><br><span class=\"line\">elseif score &gt; 70</span><br><span class=\"line\">    disp(&apos;中&apos;);</span><br><span class=\"line\">elseif score &gt; 60</span><br><span class=\"line\">    disp(&apos;及格&apos;);</span><br><span class=\"line\">else</span><br><span class=\"line\">    disp(&apos;不及格&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\">% 每一级条件都是下一级条件的子集，条件越来越宽松。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1 </span><br><span class=\"line\">statement 1</span><br><span class=\"line\">statement 2</span><br><span class=\"line\">样例 2 </span><br><span class=\"line\">statement 4</span><br><span class=\"line\">样例 3 </span><br><span class=\"line\">statement 6</span><br><span class=\"line\">样例 4 </span><br><span class=\"line\">statement 6</span><br><span class=\"line\">样例 5 </span><br><span class=\"line\">及格</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"if-语句注意的问题\"><a href=\"#if-语句注意的问题\" class=\"headerlink\" title=\"if 语句注意的问题\"></a>if 语句注意的问题</h4><p>1.首先是判断条件：判断条件如果是等式，请务必记得等式是用 <strong>‘==’</strong> 连接的。<br>2.使用嵌套 if 语句时，会形成 else if 应当与 elseif 区分开。<br>3.使用嵌套 if 语句时，判断条件之间的相互关系很复杂，应当仔细区分开。<br>4.如果你觉得2，3很麻烦，请无脑使用 elseif<br>5.用 elseif 连接的各个分支条件都是<strong>越来越宽松</strong>，对于多分支条件结构能很好简化。</p>\n<h4 id=\"switch-语句\"><a href=\"#switch-语句\" class=\"headerlink\" title=\"switch 语句\"></a>switch 语句</h4><p>switch 语句需要提供一个变量，针对这个变量可能的值进行选择分支的语句。也就是查这个变量是什么可能值，如果找到了这个值则运行对应命令。特别的，switch 语句只能对<strong>离散值</strong>生效(case 数量有限)，并且每一个 case 都必须不同（否则只执行第一个 case ，并且会给出警告），在给出的下列案例中，尽管用 if 语句理论上也可以实现同等效果，但是 switch 语句的可读性更好。</p>\n<h4 id=\"switch-语句实例\"><a href=\"#switch-语句实例\" class=\"headerlink\" title=\"switch 语句实例\"></a>switch 语句实例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% switch 语句</span><br><span class=\"line\"></span><br><span class=\"line\">% 计算机会这样操作：</span><br><span class=\"line\">% 1.开始查询以下的 case 是否有刚好等于 str 的值</span><br><span class=\"line\">% 2.若有刚好等于 str 的值，则执行对应命令</span><br><span class=\"line\">% 3.若没有，则执行 otherwise 对应命令</span><br><span class=\"line\">% 4.若连 otherwise 也没有，则 switch 语句结束，不做任何事。</span><br><span class=\"line\"></span><br><span class=\"line\">str = &apos;周三&apos;;</span><br><span class=\"line\">switch str</span><br><span class=\"line\">    case &apos;周一&apos;</span><br><span class=\"line\">        disp(&apos;工作日 1&apos;);</span><br><span class=\"line\">    case &apos;周二&apos;</span><br><span class=\"line\">        disp(&apos;工作日 2&apos;);</span><br><span class=\"line\">    case &apos;周三&apos;</span><br><span class=\"line\">        disp(&apos;工作日 3&apos;);</span><br><span class=\"line\">    case &apos;周四&apos;</span><br><span class=\"line\">        disp(&apos;工作日 4&apos;);</span><br><span class=\"line\">    case &apos;周五&apos;</span><br><span class=\"line\">        disp(&apos;工作日 5&apos;);</span><br><span class=\"line\">    otherwise</span><br><span class=\"line\">        disp(&apos;休息&apos;);</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果-1\"><a href=\"#测试结果-1\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工作日 3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a><strong>循环结构</strong></h3><p>循环结构也分为两种：for 循环和 while 循环。循环结构的目的显而易见：重复多次地执行同一段代码。<br>for   循环用于<strong>按次数循环</strong>，循环次数为指定的向量长度。<br>while 循环用于<strong>按条件循环</strong>，只要逻辑变量为 true 则重复循环。</p>\n<h4 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h4><p>for 循环用于<strong>特定的次数</strong>的循环，最大特点是只要达到次数就会停止。<br>for 使用的格式为：for + 空格 + 索引向量 开头，end 结尾，中间为应循环的一段代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for 索引 = 索引向量</span><br><span class=\"line\">    循环的代码段</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for-循环样例\"><a href=\"#for-循环样例\" class=\"headerlink\" title=\"for 循环样例\"></a>for 循环样例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 样例 1</span><br><span class=\"line\">disp(&apos;样例 1 &apos;)</span><br><span class=\"line\">% 这个样例说明循环次数取决于你指定向量的长度</span><br><span class=\"line\">a = 0;</span><br><span class=\"line\">% </span><br><span class=\"line\">for index_1 = 2:10</span><br><span class=\"line\">    a = a + 1;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(a);</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 2 </span><br><span class=\"line\">disp(&apos;样例 2 &apos;)</span><br><span class=\"line\">% 循环中使用索引（index_2）时</span><br><span class=\"line\">% 每次index_2的值为指定的索引向量对应当前循环次数的值。</span><br><span class=\"line\">b = 0;</span><br><span class=\"line\">% </span><br><span class=\"line\">for index_2 = 2:10</span><br><span class=\"line\">    b = b + index_2;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(b);</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 3</span><br><span class=\"line\">disp(&apos;样例 3 &apos;)</span><br><span class=\"line\">% 循环也可以嵌套，但需要使用不同的循环索引</span><br><span class=\"line\">c = zeros(5,5);</span><br><span class=\"line\">for index_3 = 1:5</span><br><span class=\"line\">   for index_4 = 1:5</span><br><span class=\"line\">        c(index_3,index_4) = sqrt(index_3^2 + index_4^2);</span><br><span class=\"line\">   end</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(c);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果-2\"><a href=\"#测试结果-2\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1 </span><br><span class=\"line\">     9</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2 </span><br><span class=\"line\">    54</span><br><span class=\"line\"></span><br><span class=\"line\">样例 3 </span><br><span class=\"line\">    1.4142    2.2361    3.1623    4.1231    5.0990</span><br><span class=\"line\">    2.2361    2.8284    3.6056    4.4721    5.3852</span><br><span class=\"line\">    3.1623    3.6056    4.2426    5.0000    5.8310</span><br><span class=\"line\">    4.1231    4.4721    5.0000    5.6569    6.4031</span><br><span class=\"line\">    5.0990    5.3852    5.8310    6.4031    7.0711</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a><strong>while 循环</strong></h4><p>while 循环用于<strong>特定条件下</strong>的循环，最大特点是只要出现一次 false 就会停止。<br>while 循环使用的格式为：while + 空格 + 逻辑条件 开头，end 结尾，中间行为循环的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while 逻辑条件</span><br><span class=\"line\">    循环的代码段</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"while-循环样例\"><a href=\"#while-循环样例\" class=\"headerlink\" title=\"while 循环样例\"></a>while 循环样例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 样例 1</span><br><span class=\"line\">disp(&apos;样例 1 &apos;)</span><br><span class=\"line\">% 求解 1+2+3+...+k&gt;100的最小整数解  </span><br><span class=\"line\">k = 0;</span><br><span class=\"line\">sum = 0;</span><br><span class=\"line\">while sum &lt;= 100</span><br><span class=\"line\">    sum = sum + k;</span><br><span class=\"line\">    k = k + 1;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(k);</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 2</span><br><span class=\"line\">disp(&apos;样例 2 &apos;)</span><br><span class=\"line\">% 用泰勒级数逼近自然底数exp(1)，将相对误差控制在10^-4内</span><br><span class=\"line\">k = 0;</span><br><span class=\"line\">sum = 0; </span><br><span class=\"line\">while abs((sum-exp(1))/exp(1)) &gt; 1e-4</span><br><span class=\"line\">    sum = sum + 1/factorial(k);    </span><br><span class=\"line\">    k = k + 1;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 3</span><br><span class=\"line\">disp(&apos;样例 3 &apos;)</span><br><span class=\"line\">% 最简单的死循环: 判断条件永远成立。</span><br><span class=\"line\">% 可以用 Ctrl + C 强制中断运行。</span><br><span class=\"line\">while 1</span><br><span class=\"line\">    ;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果-3\"><a href=\"#测试结果-3\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1 </span><br><span class=\"line\">    15</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2 </span><br><span class=\"line\">    2.7181</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环的补充\"><a href=\"#循环的补充\" class=\"headerlink\" title=\"循环的补充\"></a>循环的补充</h4><p>关于循环还用到另外两个关键字： <strong>continue</strong> 和 <strong>break</strong> 。</p>\n<p>这两个关键字作用很像但有很大区别：</p>\n<p><strong>continue</strong> ：放弃当前<strong>这一次循环</strong>，开始下一次循环（循环次数 +1）</p>\n<p><strong>break</strong> ：放弃当前<strong>这一层循环</strong>，循环直接终止。</p>\n<p>下面来看看这两个关键字的应用：</p>\n<h4 id=\"continue-break\"><a href=\"#continue-break\" class=\"headerlink\" title=\"continue, break\"></a>continue, break</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 用循环观察输出</span><br><span class=\"line\">% 当 index == 3 时，执行 continue ,跳过了 3 而到 4；</span><br><span class=\"line\">% 当 index == 5 时，执行 break ,循环直接终止，5 6 7都没有执行；</span><br><span class=\"line\">for index = 1 : 7</span><br><span class=\"line\">    if index == 3 </span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    end</span><br><span class=\"line\">    if index == 5</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    end</span><br><span class=\"line\">    disp(index);</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试输出\"><a href=\"#测试输出\" class=\"headerlink\" title=\"测试输出\"></a>测试输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"></span><br><span class=\"line\">2</span><br><span class=\"line\"></span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环应该注意的问题\"><a href=\"#循环应该注意的问题\" class=\"headerlink\" title=\"循环应该注意的问题\"></a>循环应该注意的问题</h4><p>1.每一个 for 循环理论上都可以使用 while 循环实现（在 while 循环添加索引，以索引作为判断条件），实际上这样处理是没有什么意义的，反而会使代码更加晦涩，我们只需要根据需要使用对应的方法即可。<br>2.for 循环需要使用索引向量，请尽可能保证你每次使用的<strong>循环索引变量名都不同</strong>（嵌套循环中必须不同，否则内层循环无法识别，会出现意想不到的错误）。控制变量名不同的好处在于，容易区分每一步循环的意义，并且容易使用查找替换修改。<br>3.使用 while 循环不注意就可能写出死循环，比如判断条件为 A 大于 B ，然而 A-B 却不断增大。<br>4.对于复杂的循环结构，可以使用 continue 和 break 实现简化。<br>5.对于 MATLAB 而言，很多操作使用循环会大大降低运算速度，比如创建很大的零矩阵500×500×500，使用矩阵操作和内置函数能大大提高效率。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>本节过后，理论上很多问题可以用 MATLAB 来解决了。条件和循环结构也会用于许多实际问题，读者在掌握两种结构的时候也应该注意使用者两种结构可能导致的问题。其中一些问题若没有注意到，可能会导致难以发现的异常，会给自己带来不少麻烦。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>上次内容，我们介绍了 MATLAB 中逻辑类型（logical）的变量，这种变量只有两种值： true 和 false。本次介绍的内容是 MATLAB 的一些语法结构包括我们最常用的条件结构和循环结构。条件结构是根据程序的执行结果选择应当执行的命令。循环结构是根据程序重复执行一系列语句的结构。两种结构都是程序结构的基础内容。从这一章开始，所有问题都可以得到理论上的解决了。</p>","more":"<h3 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a><strong>变量名</strong></h3><p>我们之前介绍过变量在使用的时候，可以直接使用诸如 “ a = 1 ” 的方式直接赋值，也特地提到过一些特殊的参数值（如 pi, inf, NaN, i, j）不应当作为变量名使用。那么使用变量名到底有哪些应该注意的点：</p>\n<p>A. 严格规定的变量名的格式：（一定不能做的事，做了会报错的情况）<br>1.MATLAB 变量名必须以<strong>字母</strong>开头<br>2.可以使用的字符为<strong>字母，下划线和数字</strong><br>3.长度不能过大，<strong>31个字符</strong>是最大长度。<br>4.字符是<strong>区分大小写</strong>的。<br>5.不能使用系统预留的关键字（可以使用 iskeyword 命令查看关键字列表）。</p>\n<p>B. 理想的变量名格式：（推荐做的事）<br>1.MATLAB 变量名最好是有意义容易理解的名称如： success_rate<br>2.尽管不能在变量名中使用空格，可以用下划线代替空格连接单词来表达变量意义。<br>3.没有特殊需要时，尽量使用小写字母（ A 和 a 是不同的变量）<br>4.不要重复使用已经使用过的变量名，尽管你之后不再需要使用这个变量。</p>\n<h3 id=\"条件结构\"><a href=\"#条件结构\" class=\"headerlink\" title=\"条件结构\"></a><strong>条件结构</strong></h3><p>条件结构的特点是程序会根据不同条件选择不同的执行命令。MATLAB 中条件结构有两种： if 语句和 switch 语句，其中 if 语句是我们最常见的一种用法。</p>\n<h4 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h4><p>if 语句是根据一个逻辑值加以判断一个语句是否运行的语句，能对逻辑值进行判断，并在该逻辑值为 true 时执行对应的语句。（在上一次内容中我们讲到，一个逻辑值可以是一个数，一个逻辑命题甚至一串复合的逻辑表达式，在这里也适用）。<br>if 语句的标准格式就是：if + 空格 + 逻辑条件 开头，end 结尾，中间行 true 条件下执行的一段代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 逻辑条件</span><br><span class=\"line\">    true 条件下的代码段;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>if 语句还可以加入两个关键字： <strong>else</strong> 和 <strong>elseif</strong> 。</p>\n<p>else 就是补充 if 判断为 false 的情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 逻辑条件</span><br><span class=\"line\">    true 条件下的代码段;</span><br><span class=\"line\">else</span><br><span class=\"line\">    false 条件下的代码段；</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>elseif 是针对嵌套使用 if 语句使用的，在分支较多时优化结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if 逻辑条件 1 </span><br><span class=\"line\">    条件 1 为 true 代码段;</span><br><span class=\"line\">elseif 逻辑条件 2</span><br><span class=\"line\">    条件 1 为 false 且条件 2 为 true 代码段;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">elseif 逻辑条件k  </span><br><span class=\"line\">    先前所有条件为 false ，条件 k 为 true 代码段；</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"if-语句实例\"><a href=\"#if-语句实例\" class=\"headerlink\" title=\"if 语句实例\"></a>if 语句实例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% if 语句</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 1</span><br><span class=\"line\">disp(&apos;样例 1 &apos;)</span><br><span class=\"line\">% if 语句仅在逻辑值为 true 是执行对应的命令</span><br><span class=\"line\">a = 1;</span><br><span class=\"line\">b = 2;</span><br><span class=\"line\">if b &gt; a</span><br><span class=\"line\">    disp(&apos;statement 1&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\">if b &gt; a</span><br><span class=\"line\">    disp(&apos;statement 2&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 2</span><br><span class=\"line\">disp(&apos;样例 2 &apos;)</span><br><span class=\"line\">% if 语句可以使用 else 作为判断条件的补集</span><br><span class=\"line\">% 也就是说，若为 false 则运行。</span><br><span class=\"line\">a = 3;</span><br><span class=\"line\">b = 2;</span><br><span class=\"line\">if b &gt; a</span><br><span class=\"line\">    disp(&apos;statement 3&apos;);</span><br><span class=\"line\">else</span><br><span class=\"line\">    disp(&apos;statement 4&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 3</span><br><span class=\"line\">disp(&apos;样例 3 &apos;)</span><br><span class=\"line\">% if 语句可以嵌套使用，在 if 语句中使用 if 语句</span><br><span class=\"line\">a = 3;</span><br><span class=\"line\">if a &lt; 2</span><br><span class=\"line\">    disp(&apos;statement 5&apos;);</span><br><span class=\"line\">else % 此处可以不必换行</span><br><span class=\"line\">    if a &lt; 5</span><br><span class=\"line\">        disp(&apos;statement 6&apos;);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        disp(&apos;statement 7&apos;);</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 4</span><br><span class=\"line\">disp(&apos;样例 4 &apos;)</span><br><span class=\"line\">% 观察到样例 3 在区间数量多的时候要嵌套很多次</span><br><span class=\"line\">% 因此可以使用另一个关键字 elseif 简化。</span><br><span class=\"line\">% 以下代码与样例 3 是等价的</span><br><span class=\"line\">a = 3;</span><br><span class=\"line\">if a &lt; 2</span><br><span class=\"line\">    disp(&apos;statement 5&apos;);</span><br><span class=\"line\">elseif a &lt; 5</span><br><span class=\"line\">    disp(&apos;statement 6&apos;);</span><br><span class=\"line\">else</span><br><span class=\"line\">    disp(&apos;statement 7&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例5</span><br><span class=\"line\">disp(&apos;样例 5 &apos;)</span><br><span class=\"line\">% elseif 连接的分支条件关系越来越宽松，可以从排分数实例来看</span><br><span class=\"line\">score = 67;</span><br><span class=\"line\">if score == 100</span><br><span class=\"line\">    disp(&apos;满分&apos;);</span><br><span class=\"line\">elseif score &gt; 90</span><br><span class=\"line\">    disp(&apos;优秀&apos;);</span><br><span class=\"line\">elseif score &gt; 80</span><br><span class=\"line\">    disp(&apos;良好&apos;);</span><br><span class=\"line\">elseif score &gt; 70</span><br><span class=\"line\">    disp(&apos;中&apos;);</span><br><span class=\"line\">elseif score &gt; 60</span><br><span class=\"line\">    disp(&apos;及格&apos;);</span><br><span class=\"line\">else</span><br><span class=\"line\">    disp(&apos;不及格&apos;);</span><br><span class=\"line\">end</span><br><span class=\"line\">% 每一级条件都是下一级条件的子集，条件越来越宽松。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1 </span><br><span class=\"line\">statement 1</span><br><span class=\"line\">statement 2</span><br><span class=\"line\">样例 2 </span><br><span class=\"line\">statement 4</span><br><span class=\"line\">样例 3 </span><br><span class=\"line\">statement 6</span><br><span class=\"line\">样例 4 </span><br><span class=\"line\">statement 6</span><br><span class=\"line\">样例 5 </span><br><span class=\"line\">及格</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"if-语句注意的问题\"><a href=\"#if-语句注意的问题\" class=\"headerlink\" title=\"if 语句注意的问题\"></a>if 语句注意的问题</h4><p>1.首先是判断条件：判断条件如果是等式，请务必记得等式是用 <strong>‘==’</strong> 连接的。<br>2.使用嵌套 if 语句时，会形成 else if 应当与 elseif 区分开。<br>3.使用嵌套 if 语句时，判断条件之间的相互关系很复杂，应当仔细区分开。<br>4.如果你觉得2，3很麻烦，请无脑使用 elseif<br>5.用 elseif 连接的各个分支条件都是<strong>越来越宽松</strong>，对于多分支条件结构能很好简化。</p>\n<h4 id=\"switch-语句\"><a href=\"#switch-语句\" class=\"headerlink\" title=\"switch 语句\"></a>switch 语句</h4><p>switch 语句需要提供一个变量，针对这个变量可能的值进行选择分支的语句。也就是查这个变量是什么可能值，如果找到了这个值则运行对应命令。特别的，switch 语句只能对<strong>离散值</strong>生效(case 数量有限)，并且每一个 case 都必须不同（否则只执行第一个 case ，并且会给出警告），在给出的下列案例中，尽管用 if 语句理论上也可以实现同等效果，但是 switch 语句的可读性更好。</p>\n<h4 id=\"switch-语句实例\"><a href=\"#switch-语句实例\" class=\"headerlink\" title=\"switch 语句实例\"></a>switch 语句实例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% switch 语句</span><br><span class=\"line\"></span><br><span class=\"line\">% 计算机会这样操作：</span><br><span class=\"line\">% 1.开始查询以下的 case 是否有刚好等于 str 的值</span><br><span class=\"line\">% 2.若有刚好等于 str 的值，则执行对应命令</span><br><span class=\"line\">% 3.若没有，则执行 otherwise 对应命令</span><br><span class=\"line\">% 4.若连 otherwise 也没有，则 switch 语句结束，不做任何事。</span><br><span class=\"line\"></span><br><span class=\"line\">str = &apos;周三&apos;;</span><br><span class=\"line\">switch str</span><br><span class=\"line\">    case &apos;周一&apos;</span><br><span class=\"line\">        disp(&apos;工作日 1&apos;);</span><br><span class=\"line\">    case &apos;周二&apos;</span><br><span class=\"line\">        disp(&apos;工作日 2&apos;);</span><br><span class=\"line\">    case &apos;周三&apos;</span><br><span class=\"line\">        disp(&apos;工作日 3&apos;);</span><br><span class=\"line\">    case &apos;周四&apos;</span><br><span class=\"line\">        disp(&apos;工作日 4&apos;);</span><br><span class=\"line\">    case &apos;周五&apos;</span><br><span class=\"line\">        disp(&apos;工作日 5&apos;);</span><br><span class=\"line\">    otherwise</span><br><span class=\"line\">        disp(&apos;休息&apos;);</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果-1\"><a href=\"#测试结果-1\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">工作日 3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a><strong>循环结构</strong></h3><p>循环结构也分为两种：for 循环和 while 循环。循环结构的目的显而易见：重复多次地执行同一段代码。<br>for   循环用于<strong>按次数循环</strong>，循环次数为指定的向量长度。<br>while 循环用于<strong>按条件循环</strong>，只要逻辑变量为 true 则重复循环。</p>\n<h4 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h4><p>for 循环用于<strong>特定的次数</strong>的循环，最大特点是只要达到次数就会停止。<br>for 使用的格式为：for + 空格 + 索引向量 开头，end 结尾，中间为应循环的一段代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for 索引 = 索引向量</span><br><span class=\"line\">    循环的代码段</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for-循环样例\"><a href=\"#for-循环样例\" class=\"headerlink\" title=\"for 循环样例\"></a>for 循环样例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 样例 1</span><br><span class=\"line\">disp(&apos;样例 1 &apos;)</span><br><span class=\"line\">% 这个样例说明循环次数取决于你指定向量的长度</span><br><span class=\"line\">a = 0;</span><br><span class=\"line\">% </span><br><span class=\"line\">for index_1 = 2:10</span><br><span class=\"line\">    a = a + 1;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(a);</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 2 </span><br><span class=\"line\">disp(&apos;样例 2 &apos;)</span><br><span class=\"line\">% 循环中使用索引（index_2）时</span><br><span class=\"line\">% 每次index_2的值为指定的索引向量对应当前循环次数的值。</span><br><span class=\"line\">b = 0;</span><br><span class=\"line\">% </span><br><span class=\"line\">for index_2 = 2:10</span><br><span class=\"line\">    b = b + index_2;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(b);</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 3</span><br><span class=\"line\">disp(&apos;样例 3 &apos;)</span><br><span class=\"line\">% 循环也可以嵌套，但需要使用不同的循环索引</span><br><span class=\"line\">c = zeros(5,5);</span><br><span class=\"line\">for index_3 = 1:5</span><br><span class=\"line\">   for index_4 = 1:5</span><br><span class=\"line\">        c(index_3,index_4) = sqrt(index_3^2 + index_4^2);</span><br><span class=\"line\">   end</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(c);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果-2\"><a href=\"#测试结果-2\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1 </span><br><span class=\"line\">     9</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2 </span><br><span class=\"line\">    54</span><br><span class=\"line\"></span><br><span class=\"line\">样例 3 </span><br><span class=\"line\">    1.4142    2.2361    3.1623    4.1231    5.0990</span><br><span class=\"line\">    2.2361    2.8284    3.6056    4.4721    5.3852</span><br><span class=\"line\">    3.1623    3.6056    4.2426    5.0000    5.8310</span><br><span class=\"line\">    4.1231    4.4721    5.0000    5.6569    6.4031</span><br><span class=\"line\">    5.0990    5.3852    5.8310    6.4031    7.0711</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a><strong>while 循环</strong></h4><p>while 循环用于<strong>特定条件下</strong>的循环，最大特点是只要出现一次 false 就会停止。<br>while 循环使用的格式为：while + 空格 + 逻辑条件 开头，end 结尾，中间行为循环的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while 逻辑条件</span><br><span class=\"line\">    循环的代码段</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"while-循环样例\"><a href=\"#while-循环样例\" class=\"headerlink\" title=\"while 循环样例\"></a>while 循环样例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 样例 1</span><br><span class=\"line\">disp(&apos;样例 1 &apos;)</span><br><span class=\"line\">% 求解 1+2+3+...+k&gt;100的最小整数解  </span><br><span class=\"line\">k = 0;</span><br><span class=\"line\">sum = 0;</span><br><span class=\"line\">while sum &lt;= 100</span><br><span class=\"line\">    sum = sum + k;</span><br><span class=\"line\">    k = k + 1;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(k);</span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 2</span><br><span class=\"line\">disp(&apos;样例 2 &apos;)</span><br><span class=\"line\">% 用泰勒级数逼近自然底数exp(1)，将相对误差控制在10^-4内</span><br><span class=\"line\">k = 0;</span><br><span class=\"line\">sum = 0; </span><br><span class=\"line\">while abs((sum-exp(1))/exp(1)) &gt; 1e-4</span><br><span class=\"line\">    sum = sum + 1/factorial(k);    </span><br><span class=\"line\">    k = k + 1;</span><br><span class=\"line\">end</span><br><span class=\"line\">disp(sum);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">% 样例 3</span><br><span class=\"line\">disp(&apos;样例 3 &apos;)</span><br><span class=\"line\">% 最简单的死循环: 判断条件永远成立。</span><br><span class=\"line\">% 可以用 Ctrl + C 强制中断运行。</span><br><span class=\"line\">while 1</span><br><span class=\"line\">    ;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试结果-3\"><a href=\"#测试结果-3\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例 1 </span><br><span class=\"line\">    15</span><br><span class=\"line\"></span><br><span class=\"line\">样例 2 </span><br><span class=\"line\">    2.7181</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环的补充\"><a href=\"#循环的补充\" class=\"headerlink\" title=\"循环的补充\"></a>循环的补充</h4><p>关于循环还用到另外两个关键字： <strong>continue</strong> 和 <strong>break</strong> 。</p>\n<p>这两个关键字作用很像但有很大区别：</p>\n<p><strong>continue</strong> ：放弃当前<strong>这一次循环</strong>，开始下一次循环（循环次数 +1）</p>\n<p><strong>break</strong> ：放弃当前<strong>这一层循环</strong>，循环直接终止。</p>\n<p>下面来看看这两个关键字的应用：</p>\n<h4 id=\"continue-break\"><a href=\"#continue-break\" class=\"headerlink\" title=\"continue, break\"></a>continue, break</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 用循环观察输出</span><br><span class=\"line\">% 当 index == 3 时，执行 continue ,跳过了 3 而到 4；</span><br><span class=\"line\">% 当 index == 5 时，执行 break ,循环直接终止，5 6 7都没有执行；</span><br><span class=\"line\">for index = 1 : 7</span><br><span class=\"line\">    if index == 3 </span><br><span class=\"line\">        continue;</span><br><span class=\"line\">    end</span><br><span class=\"line\">    if index == 5</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    end</span><br><span class=\"line\">    disp(index);</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试输出\"><a href=\"#测试输出\" class=\"headerlink\" title=\"测试输出\"></a>测试输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"></span><br><span class=\"line\">2</span><br><span class=\"line\"></span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环应该注意的问题\"><a href=\"#循环应该注意的问题\" class=\"headerlink\" title=\"循环应该注意的问题\"></a>循环应该注意的问题</h4><p>1.每一个 for 循环理论上都可以使用 while 循环实现（在 while 循环添加索引，以索引作为判断条件），实际上这样处理是没有什么意义的，反而会使代码更加晦涩，我们只需要根据需要使用对应的方法即可。<br>2.for 循环需要使用索引向量，请尽可能保证你每次使用的<strong>循环索引变量名都不同</strong>（嵌套循环中必须不同，否则内层循环无法识别，会出现意想不到的错误）。控制变量名不同的好处在于，容易区分每一步循环的意义，并且容易使用查找替换修改。<br>3.使用 while 循环不注意就可能写出死循环，比如判断条件为 A 大于 B ，然而 A-B 却不断增大。<br>4.对于复杂的循环结构，可以使用 continue 和 break 实现简化。<br>5.对于 MATLAB 而言，很多操作使用循环会大大降低运算速度，比如创建很大的零矩阵500×500×500，使用矩阵操作和内置函数能大大提高效率。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>本节过后，理论上很多问题可以用 MATLAB 来解决了。条件和循环结构也会用于许多实际问题，读者在掌握两种结构的时候也应该注意使用者两种结构可能导致的问题。其中一些问题若没有注意到，可能会导致难以发现的异常，会给自己带来不少麻烦。</p>"},{"title":"MATLAB 逻辑","date":"2018-03-04T19:46:58.000Z","_content":"---\n\n### **概述**\n\n上一节的内容中，我们介绍了索引的使用方法。索引的目的是为了取出矩阵中的一部分元素，因此我们知道通过元素在矩阵中的位置我们可以实现索引。在本节中，我们将介绍 MATLAB 中的逻辑变量以及通过逻辑变量索引的方法。\n\n<!--more-->\n\n> MATLAB 中存在一种 logical（逻辑）类型用于表示逻辑上的真和假。在其他程序语言中，这样的一种类型也叫做 bool 型变量。这一种变量本身只有两种值，分别为 true 和 false。规定 false 对应数值 0，true 对应其他值（特别地，使用时可以用任意非零值代表 true，但存储时会自动转为 1 代表 true，这样的好处是只需要占用一个比特的空间）。\n\n### **逻辑变量** \n\nlogical 变量只存在两种值 true（真）或者 false（假），规定分别用数字 1 和 0 存储。以逻辑值组成的矩阵称为逻辑矩阵。一般有以下几种创建逻辑矩阵的方法，各有用处。  \n\n#### 方法一：直接赋值法\n\n直接用 true，false 直接赋值到一个矩阵，缺点操作复杂，一般不考虑这种方法。\n```\nx = [true false] % 正确实例\nA = [1 0] % 错误实例\nwhos\n```\n输出值\n```\nx =\n     1     0\nA =\n     1     0\n% 尽管两个语句的输出一样\n% 但是通过 whos 命令可以看到变量的类型不一样\n% 可以看到只有用 true，false 直接赋值才能创建逻辑矩阵\n% 一般不考虑这种方法\n  Name      Size            Bytes  Class      Attributes\n\n  A         1x2                16  double               \n  x         1x2                 2  logical \n```\n\n####  方法二：logical 函数法\n\nlogical 函数是将数值或矩阵转换为逻辑值的函数。遵循的转换规则为：非零值为逻辑 1，零值为逻辑 0。这种方法将一个矩阵非零值对应转为逻辑矩阵中的 1。可以用作非零值的逻辑索引。\n\n函数法\n```\n% logical\nA = [1 0 3;0 5 6];\nx1 = logical(1)\nwhos\n% 对于传入的数值或矩阵\n% 非零值为逻辑 1，零值为逻辑 0\nx2 = logical(0)\nx3 = logical(2)\nx4 = logical(A)\n% 生成的逻辑矩阵作为索引，可以取出矩阵中对应位置为 true 的元素\nx5 = A(logical(A))\n```\n命令行输出\n```\n% logical\nx1 =\n     1\n% 观察两个变量的类型（Class）和比特数（Bytes）\n% A 属于 double 类型（占用 48 比特）\n% x1 属于 logical 类型（占用 1 比特）\n  Name      Size            Bytes  Class      Attributes\n  A         2x3                48  double               \n  x1        1x1                 1  logical              \nx2 =\n     0\nx3 =\n     1\nx4 =\n     1     0     1\n     0     1     1  \n% 形如 A(logical(A)) 可以取出 A 中的非零元素\nx5 =\n     1\n     5\n     3\n     6\n```\n\n#### 方法三：借用逻辑表达式（命题）\n\n命题就是判断一个事件的陈述句。对于数值来说一个判断的陈述句通过关系运算符连接。\nMATLAB 的关系运算符共 6 个：等于（==），不等于（~=），大于等于（>=），大于（>），小于等于（<=），小于（<）。\n这种方法创建逻辑矩阵最为常见，能够很高效地创建对应的逻辑矩阵，同时进行逻辑运算并作为索引\n\n逻辑表达式\n```\n% 逻辑表达式\nA = [1 0 3;0 5 6];\nx1 = (3 == 2)\nx2 = (3 ~= 2) \nx3 = (3 >= 2)\nx4 = (3 >  2)\nx5 = (3 <= 2)\nx6 = (3 <  2)\n% 特别地，对矩阵使用关系运算符返回一个相应的逻辑矩阵\nx7 = (A < 4)\n% 返回的矩阵是逻辑矩阵，又可以作为索引，取出矩阵中满足判断条件的元素\nx8 = A(A < 4)\n```\n命令行输出\n```\n% 逻辑表达式\n% 对于仅由数值构成的逻辑表达式，返回该表达式的真假性\nx1 =\n     0\nx2 =\n     1\nx3 =\n     1\nx4 =\n     1\nx5 =\n     0\nx6 =\n     0\n% 对于由矩阵构成的逻辑表达式，返回和该矩阵等大小的逻辑矩阵\n% 逻辑矩阵的值是矩阵相应位置元素的判断情况\nx7 =\n     1     1     1\n     1     0     0\n% 第一行全行，第二行 1 个元素大于 4，满足判断记为 1，其他值记为 0\n% 这里的 A(A < 4) 就对应取出 A 中小于 4 的元素\nx8 =\n     1\n     0\n     0\n     3\n```\n\n逻辑表达式的运算\n\n对于逻辑值之间的运算，可以实现逻辑表达式的复合运算，这时可以实现联合条件的逻辑索引。有四种运算：逻辑与（&，&&），逻辑或（|，||），逻辑异或（xor 函数）和逻辑非（~）。这四种逻辑运算服从以下的真值表。\n\n逻辑真值表\n\nA | B | A&B | A&#124;B | xor(A,B) | ~A\n---|---|---|---|---|---\n0 | 0 | 0 | 0 | 0 | 1\n0 | 1 | 0 | 1 | 1 | 1\n1 | 0 | 0 | 1 | 1 | 0\n1 | 1 | 1 | 1 | 0 | 0\n\n应用实例\n```\nA = [1 0 3;0 5 6];\nx1 = A((A < 4)&(A > 2))\nx2 = A((A < 4)|(A > 2))\nx3 = A(xor((A < 4),(A > 2)))\nx4 = A(~(A < 4))\n% && 和 || 是 & 和 | 的变体\n% 只能用于标量，不能用于矩阵，但速度更快\nx5 = (3 > 4)&&(3 > 2)\nx6 = (3 > 2)||(3 > 4)\n```\n命令行输出\n```\n% & 与\nx1 =\n     3\n% | 或\nx2 =\n     1\n     0\n     0\n     5\n     3\n     6\n% xor 函数 异或\nx3 =\n     1\n     0\n     0\n     5\n     6\n% ~ 取非，取反\nx4 =\n     5\n     6\n% && 适用于标量的与（利用逻辑与的特性加速运算）\n% （如果第一个值为 0，立即判断该值为 0）\nx5 =\n     0\n% || 适用于标量的或（利用逻辑或的特性加速运算）\n% （如果第一个值为 1，立即判断该值为 1）\nx6 =\n     1\n```\n\n### find 函数——逻辑索引的辅助工具\n\nfind 函数是将逻辑矩阵索引直接转换为直接索引（下标位置）的函数。我们有时候作出了判断，但是却需要直接索引的信息，这时可以利用find 函数进行转换；另一个用处是，找到前n个满足条件的索引\n\n```\n% find函数\nA = [2 5 4 0 0 6];\nx1 = A > 2\nx2 = find(A > 2)\nB = [2 5 4;0 0 6];\n% 按列产生线性地址索引\nx3 = find(B > 2)\nx4 = B(find(B > 2))\n% 满足条件的前两个值的索引\nx5 = find(B > 2,2)\n```\n命令行输出\n```\n% find函数\n% 逻辑索引\nx1 =\n     0     1     1     0     0     1\n% 线性地址索引\nx2 =\n     2     3     6\n% 根据这个输出，可以发现，按列产生线性地址索引\nx3 =\n     3\n     5\n     6\n% 因为是线性地址索引，B(find(B > 2)) 依然有效，结果与 B(B > 2) 一样\nx4 =\n     5\n     4\n     6\n% 满足条件的前两个值的索引\nx5 =\n     3\n     5\n```\n\n### **重在应用**\n\n以下是逻辑数组的三种基本应用，根据判断条件进行，逻辑索引查找，替换和删除。\n\n1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。\n```\n% 查找\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\n```\n2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。\n```\n% 替换\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\n```\n3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。\n```\n% 删除(要求在矩阵 A 中改变值)\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\n```\n\n参考思路\n\n1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。\n```\n% 查找\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\nB = A((A>=2)&(A<=6))\n```\n2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。\n```\n% 替换\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\nA((A>=2)&(A<=6)) = 10\n```\n3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。\n```\n% 删除\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\nA=A(~( (A>=2) & (A<=6) ))\n```\n\n### **小结**\n\n本节内容不多，但是逻辑索引比起线性地址的等间距索引索引的产生要更加普遍，所以，希望读者熟练掌握这三种基本应用。\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/MATLAB-逻辑.md","raw":"---\ntitle: MATLAB 逻辑\ndate: 2018-03-05 03:46:58\ntags: MATLAB\n---\n---\n\n### **概述**\n\n上一节的内容中，我们介绍了索引的使用方法。索引的目的是为了取出矩阵中的一部分元素，因此我们知道通过元素在矩阵中的位置我们可以实现索引。在本节中，我们将介绍 MATLAB 中的逻辑变量以及通过逻辑变量索引的方法。\n\n<!--more-->\n\n> MATLAB 中存在一种 logical（逻辑）类型用于表示逻辑上的真和假。在其他程序语言中，这样的一种类型也叫做 bool 型变量。这一种变量本身只有两种值，分别为 true 和 false。规定 false 对应数值 0，true 对应其他值（特别地，使用时可以用任意非零值代表 true，但存储时会自动转为 1 代表 true，这样的好处是只需要占用一个比特的空间）。\n\n### **逻辑变量** \n\nlogical 变量只存在两种值 true（真）或者 false（假），规定分别用数字 1 和 0 存储。以逻辑值组成的矩阵称为逻辑矩阵。一般有以下几种创建逻辑矩阵的方法，各有用处。  \n\n#### 方法一：直接赋值法\n\n直接用 true，false 直接赋值到一个矩阵，缺点操作复杂，一般不考虑这种方法。\n```\nx = [true false] % 正确实例\nA = [1 0] % 错误实例\nwhos\n```\n输出值\n```\nx =\n     1     0\nA =\n     1     0\n% 尽管两个语句的输出一样\n% 但是通过 whos 命令可以看到变量的类型不一样\n% 可以看到只有用 true，false 直接赋值才能创建逻辑矩阵\n% 一般不考虑这种方法\n  Name      Size            Bytes  Class      Attributes\n\n  A         1x2                16  double               \n  x         1x2                 2  logical \n```\n\n####  方法二：logical 函数法\n\nlogical 函数是将数值或矩阵转换为逻辑值的函数。遵循的转换规则为：非零值为逻辑 1，零值为逻辑 0。这种方法将一个矩阵非零值对应转为逻辑矩阵中的 1。可以用作非零值的逻辑索引。\n\n函数法\n```\n% logical\nA = [1 0 3;0 5 6];\nx1 = logical(1)\nwhos\n% 对于传入的数值或矩阵\n% 非零值为逻辑 1，零值为逻辑 0\nx2 = logical(0)\nx3 = logical(2)\nx4 = logical(A)\n% 生成的逻辑矩阵作为索引，可以取出矩阵中对应位置为 true 的元素\nx5 = A(logical(A))\n```\n命令行输出\n```\n% logical\nx1 =\n     1\n% 观察两个变量的类型（Class）和比特数（Bytes）\n% A 属于 double 类型（占用 48 比特）\n% x1 属于 logical 类型（占用 1 比特）\n  Name      Size            Bytes  Class      Attributes\n  A         2x3                48  double               \n  x1        1x1                 1  logical              \nx2 =\n     0\nx3 =\n     1\nx4 =\n     1     0     1\n     0     1     1  \n% 形如 A(logical(A)) 可以取出 A 中的非零元素\nx5 =\n     1\n     5\n     3\n     6\n```\n\n#### 方法三：借用逻辑表达式（命题）\n\n命题就是判断一个事件的陈述句。对于数值来说一个判断的陈述句通过关系运算符连接。\nMATLAB 的关系运算符共 6 个：等于（==），不等于（~=），大于等于（>=），大于（>），小于等于（<=），小于（<）。\n这种方法创建逻辑矩阵最为常见，能够很高效地创建对应的逻辑矩阵，同时进行逻辑运算并作为索引\n\n逻辑表达式\n```\n% 逻辑表达式\nA = [1 0 3;0 5 6];\nx1 = (3 == 2)\nx2 = (3 ~= 2) \nx3 = (3 >= 2)\nx4 = (3 >  2)\nx5 = (3 <= 2)\nx6 = (3 <  2)\n% 特别地，对矩阵使用关系运算符返回一个相应的逻辑矩阵\nx7 = (A < 4)\n% 返回的矩阵是逻辑矩阵，又可以作为索引，取出矩阵中满足判断条件的元素\nx8 = A(A < 4)\n```\n命令行输出\n```\n% 逻辑表达式\n% 对于仅由数值构成的逻辑表达式，返回该表达式的真假性\nx1 =\n     0\nx2 =\n     1\nx3 =\n     1\nx4 =\n     1\nx5 =\n     0\nx6 =\n     0\n% 对于由矩阵构成的逻辑表达式，返回和该矩阵等大小的逻辑矩阵\n% 逻辑矩阵的值是矩阵相应位置元素的判断情况\nx7 =\n     1     1     1\n     1     0     0\n% 第一行全行，第二行 1 个元素大于 4，满足判断记为 1，其他值记为 0\n% 这里的 A(A < 4) 就对应取出 A 中小于 4 的元素\nx8 =\n     1\n     0\n     0\n     3\n```\n\n逻辑表达式的运算\n\n对于逻辑值之间的运算，可以实现逻辑表达式的复合运算，这时可以实现联合条件的逻辑索引。有四种运算：逻辑与（&，&&），逻辑或（|，||），逻辑异或（xor 函数）和逻辑非（~）。这四种逻辑运算服从以下的真值表。\n\n逻辑真值表\n\nA | B | A&B | A&#124;B | xor(A,B) | ~A\n---|---|---|---|---|---\n0 | 0 | 0 | 0 | 0 | 1\n0 | 1 | 0 | 1 | 1 | 1\n1 | 0 | 0 | 1 | 1 | 0\n1 | 1 | 1 | 1 | 0 | 0\n\n应用实例\n```\nA = [1 0 3;0 5 6];\nx1 = A((A < 4)&(A > 2))\nx2 = A((A < 4)|(A > 2))\nx3 = A(xor((A < 4),(A > 2)))\nx4 = A(~(A < 4))\n% && 和 || 是 & 和 | 的变体\n% 只能用于标量，不能用于矩阵，但速度更快\nx5 = (3 > 4)&&(3 > 2)\nx6 = (3 > 2)||(3 > 4)\n```\n命令行输出\n```\n% & 与\nx1 =\n     3\n% | 或\nx2 =\n     1\n     0\n     0\n     5\n     3\n     6\n% xor 函数 异或\nx3 =\n     1\n     0\n     0\n     5\n     6\n% ~ 取非，取反\nx4 =\n     5\n     6\n% && 适用于标量的与（利用逻辑与的特性加速运算）\n% （如果第一个值为 0，立即判断该值为 0）\nx5 =\n     0\n% || 适用于标量的或（利用逻辑或的特性加速运算）\n% （如果第一个值为 1，立即判断该值为 1）\nx6 =\n     1\n```\n\n### find 函数——逻辑索引的辅助工具\n\nfind 函数是将逻辑矩阵索引直接转换为直接索引（下标位置）的函数。我们有时候作出了判断，但是却需要直接索引的信息，这时可以利用find 函数进行转换；另一个用处是，找到前n个满足条件的索引\n\n```\n% find函数\nA = [2 5 4 0 0 6];\nx1 = A > 2\nx2 = find(A > 2)\nB = [2 5 4;0 0 6];\n% 按列产生线性地址索引\nx3 = find(B > 2)\nx4 = B(find(B > 2))\n% 满足条件的前两个值的索引\nx5 = find(B > 2,2)\n```\n命令行输出\n```\n% find函数\n% 逻辑索引\nx1 =\n     0     1     1     0     0     1\n% 线性地址索引\nx2 =\n     2     3     6\n% 根据这个输出，可以发现，按列产生线性地址索引\nx3 =\n     3\n     5\n     6\n% 因为是线性地址索引，B(find(B > 2)) 依然有效，结果与 B(B > 2) 一样\nx4 =\n     5\n     4\n     6\n% 满足条件的前两个值的索引\nx5 =\n     3\n     5\n```\n\n### **重在应用**\n\n以下是逻辑数组的三种基本应用，根据判断条件进行，逻辑索引查找，替换和删除。\n\n1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。\n```\n% 查找\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\n```\n2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。\n```\n% 替换\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\n```\n3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。\n```\n% 删除(要求在矩阵 A 中改变值)\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\n```\n\n参考思路\n\n1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。\n```\n% 查找\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\nB = A((A>=2)&(A<=6))\n```\n2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。\n```\n% 替换\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\nA((A>=2)&(A<=6)) = 10\n```\n3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。\n```\n% 删除\nA = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];\nA=A(~( (A>=2) & (A<=6) ))\n```\n\n### **小结**\n\n本节内容不多，但是逻辑索引比起线性地址的等间距索引索引的产生要更加普遍，所以，希望读者熟练掌握这三种基本应用。\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"MATLAB-逻辑","published":1,"updated":"2020-03-15T21:05:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wk000q29fy2mqkv6z7","content":"<hr>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>上一节的内容中，我们介绍了索引的使用方法。索引的目的是为了取出矩阵中的一部分元素，因此我们知道通过元素在矩阵中的位置我们可以实现索引。在本节中，我们将介绍 MATLAB 中的逻辑变量以及通过逻辑变量索引的方法。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>MATLAB 中存在一种 logical（逻辑）类型用于表示逻辑上的真和假。在其他程序语言中，这样的一种类型也叫做 bool 型变量。这一种变量本身只有两种值，分别为 true 和 false。规定 false 对应数值 0，true 对应其他值（特别地，使用时可以用任意非零值代表 true，但存储时会自动转为 1 代表 true，这样的好处是只需要占用一个比特的空间）。</p>\n</blockquote>\n<h3 id=\"逻辑变量\"><a href=\"#逻辑变量\" class=\"headerlink\" title=\"逻辑变量\"></a><strong>逻辑变量</strong></h3><p>logical 变量只存在两种值 true（真）或者 false（假），规定分别用数字 1 和 0 存储。以逻辑值组成的矩阵称为逻辑矩阵。一般有以下几种创建逻辑矩阵的方法，各有用处。  </p>\n<h4 id=\"方法一：直接赋值法\"><a href=\"#方法一：直接赋值法\" class=\"headerlink\" title=\"方法一：直接赋值法\"></a>方法一：直接赋值法</h4><p>直接用 true，false 直接赋值到一个矩阵，缺点操作复杂，一般不考虑这种方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = [true false] % 正确实例</span><br><span class=\"line\">A = [1 0] % 错误实例</span><br><span class=\"line\">whos</span><br></pre></td></tr></table></figure>\n\n<p>输出值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x =</span><br><span class=\"line\">     1     0</span><br><span class=\"line\">A =</span><br><span class=\"line\">     1     0</span><br><span class=\"line\">% 尽管两个语句的输出一样</span><br><span class=\"line\">% 但是通过 whos 命令可以看到变量的类型不一样</span><br><span class=\"line\">% 可以看到只有用 true，false 直接赋值才能创建逻辑矩阵</span><br><span class=\"line\">% 一般不考虑这种方法</span><br><span class=\"line\">  Name      Size            Bytes  Class      Attributes</span><br><span class=\"line\"></span><br><span class=\"line\">  A         1x2                16  double               </span><br><span class=\"line\">  x         1x2                 2  logical</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二：logical-函数法\"><a href=\"#方法二：logical-函数法\" class=\"headerlink\" title=\"方法二：logical 函数法\"></a>方法二：logical 函数法</h4><p>logical 函数是将数值或矩阵转换为逻辑值的函数。遵循的转换规则为：非零值为逻辑 1，零值为逻辑 0。这种方法将一个矩阵非零值对应转为逻辑矩阵中的 1。可以用作非零值的逻辑索引。</p>\n<p>函数法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% logical</span><br><span class=\"line\">A = [1 0 3;0 5 6];</span><br><span class=\"line\">x1 = logical(1)</span><br><span class=\"line\">whos</span><br><span class=\"line\">% 对于传入的数值或矩阵</span><br><span class=\"line\">% 非零值为逻辑 1，零值为逻辑 0</span><br><span class=\"line\">x2 = logical(0)</span><br><span class=\"line\">x3 = logical(2)</span><br><span class=\"line\">x4 = logical(A)</span><br><span class=\"line\">% 生成的逻辑矩阵作为索引，可以取出矩阵中对应位置为 true 的元素</span><br><span class=\"line\">x5 = A(logical(A))</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% logical</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">% 观察两个变量的类型（Class）和比特数（Bytes）</span><br><span class=\"line\">% A 属于 double 类型（占用 48 比特）</span><br><span class=\"line\">% x1 属于 logical 类型（占用 1 比特）</span><br><span class=\"line\">  Name      Size            Bytes  Class      Attributes</span><br><span class=\"line\">  A         2x3                48  double               </span><br><span class=\"line\">  x1        1x1                 1  logical              </span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     1     0     1</span><br><span class=\"line\">     0     1     1  </span><br><span class=\"line\">% 形如 A(logical(A)) 可以取出 A 中的非零元素</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     5</span><br><span class=\"line\">     3</span><br><span class=\"line\">     6</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法三：借用逻辑表达式（命题）\"><a href=\"#方法三：借用逻辑表达式（命题）\" class=\"headerlink\" title=\"方法三：借用逻辑表达式（命题）\"></a>方法三：借用逻辑表达式（命题）</h4><p>命题就是判断一个事件的陈述句。对于数值来说一个判断的陈述句通过关系运算符连接。<br>MATLAB 的关系运算符共 6 个：等于（==），不等于（~=），大于等于（&gt;=），大于（&gt;），小于等于（&lt;=），小于（&lt;）。<br>这种方法创建逻辑矩阵最为常见，能够很高效地创建对应的逻辑矩阵，同时进行逻辑运算并作为索引</p>\n<p>逻辑表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 逻辑表达式</span><br><span class=\"line\">A = [1 0 3;0 5 6];</span><br><span class=\"line\">x1 = (3 == 2)</span><br><span class=\"line\">x2 = (3 ~= 2) </span><br><span class=\"line\">x3 = (3 &gt;= 2)</span><br><span class=\"line\">x4 = (3 &gt;  2)</span><br><span class=\"line\">x5 = (3 &lt;= 2)</span><br><span class=\"line\">x6 = (3 &lt;  2)</span><br><span class=\"line\">% 特别地，对矩阵使用关系运算符返回一个相应的逻辑矩阵</span><br><span class=\"line\">x7 = (A &lt; 4)</span><br><span class=\"line\">% 返回的矩阵是逻辑矩阵，又可以作为索引，取出矩阵中满足判断条件的元素</span><br><span class=\"line\">x8 = A(A &lt; 4)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 逻辑表达式</span><br><span class=\"line\">% 对于仅由数值构成的逻辑表达式，返回该表达式的真假性</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">x6 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">% 对于由矩阵构成的逻辑表达式，返回和该矩阵等大小的逻辑矩阵</span><br><span class=\"line\">% 逻辑矩阵的值是矩阵相应位置元素的判断情况</span><br><span class=\"line\">x7 =</span><br><span class=\"line\">     1     1     1</span><br><span class=\"line\">     1     0     0</span><br><span class=\"line\">% 第一行全行，第二行 1 个元素大于 4，满足判断记为 1，其他值记为 0</span><br><span class=\"line\">% 这里的 A(A &lt; 4) 就对应取出 A 中小于 4 的元素</span><br><span class=\"line\">x8 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     0</span><br><span class=\"line\">     0</span><br><span class=\"line\">     3</span><br></pre></td></tr></table></figure>\n\n<p>逻辑表达式的运算</p>\n<p>对于逻辑值之间的运算，可以实现逻辑表达式的复合运算，这时可以实现联合条件的逻辑索引。有四种运算：逻辑与（&amp;，&amp;&amp;），逻辑或（|，||），逻辑异或（xor 函数）和逻辑非（~）。这四种逻辑运算服从以下的真值表。</p>\n<p>逻辑真值表</p>\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n<th>A&amp;B</th>\n<th>A&#124;B</th>\n<th>xor(A,B)</th>\n<th>~A</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>应用实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = [1 0 3;0 5 6];</span><br><span class=\"line\">x1 = A((A &lt; 4)&amp;(A &gt; 2))</span><br><span class=\"line\">x2 = A((A &lt; 4)|(A &gt; 2))</span><br><span class=\"line\">x3 = A(xor((A &lt; 4),(A &gt; 2)))</span><br><span class=\"line\">x4 = A(~(A &lt; 4))</span><br><span class=\"line\">% &amp;&amp; 和 || 是 &amp; 和 | 的变体</span><br><span class=\"line\">% 只能用于标量，不能用于矩阵，但速度更快</span><br><span class=\"line\">x5 = (3 &gt; 4)&amp;&amp;(3 &gt; 2)</span><br><span class=\"line\">x6 = (3 &gt; 2)||(3 &gt; 4)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% &amp; 与</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">% | 或</span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     0</span><br><span class=\"line\">     0</span><br><span class=\"line\">     5</span><br><span class=\"line\">     3</span><br><span class=\"line\">     6</span><br><span class=\"line\">% xor 函数 异或</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     0</span><br><span class=\"line\">     0</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">% ~ 取非，取反</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">% &amp;&amp; 适用于标量的与（利用逻辑与的特性加速运算）</span><br><span class=\"line\">% （如果第一个值为 0，立即判断该值为 0）</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">% || 适用于标量的或（利用逻辑或的特性加速运算）</span><br><span class=\"line\">% （如果第一个值为 1，立即判断该值为 1）</span><br><span class=\"line\">x6 =</span><br><span class=\"line\">     1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"find-函数——逻辑索引的辅助工具\"><a href=\"#find-函数——逻辑索引的辅助工具\" class=\"headerlink\" title=\"find 函数——逻辑索引的辅助工具\"></a>find 函数——逻辑索引的辅助工具</h3><p>find 函数是将逻辑矩阵索引直接转换为直接索引（下标位置）的函数。我们有时候作出了判断，但是却需要直接索引的信息，这时可以利用find 函数进行转换；另一个用处是，找到前n个满足条件的索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% find函数</span><br><span class=\"line\">A = [2 5 4 0 0 6];</span><br><span class=\"line\">x1 = A &gt; 2</span><br><span class=\"line\">x2 = find(A &gt; 2)</span><br><span class=\"line\">B = [2 5 4;0 0 6];</span><br><span class=\"line\">% 按列产生线性地址索引</span><br><span class=\"line\">x3 = find(B &gt; 2)</span><br><span class=\"line\">x4 = B(find(B &gt; 2))</span><br><span class=\"line\">% 满足条件的前两个值的索引</span><br><span class=\"line\">x5 = find(B &gt; 2,2)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% find函数</span><br><span class=\"line\">% 逻辑索引</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     0     1     1     0     0     1</span><br><span class=\"line\">% 线性地址索引</span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     2     3     6</span><br><span class=\"line\">% 根据这个输出，可以发现，按列产生线性地址索引</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">% 因为是线性地址索引，B(find(B &gt; 2)) 依然有效，结果与 B(B &gt; 2) 一样</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     5</span><br><span class=\"line\">     4</span><br><span class=\"line\">     6</span><br><span class=\"line\">% 满足条件的前两个值的索引</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">     5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重在应用\"><a href=\"#重在应用\" class=\"headerlink\" title=\"重在应用\"></a><strong>重在应用</strong></h3><p>以下是逻辑数组的三种基本应用，根据判断条件进行，逻辑索引查找，替换和删除。</p>\n<p>1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 查找</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br></pre></td></tr></table></figure>\n\n<p>2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 替换</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br></pre></td></tr></table></figure>\n\n<p>3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 删除(要求在矩阵 A 中改变值)</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br></pre></td></tr></table></figure>\n\n<p>参考思路</p>\n<p>1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 查找</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br><span class=\"line\">B = A((A&gt;=2)&amp;(A&lt;=6))</span><br></pre></td></tr></table></figure>\n\n<p>2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 替换</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br><span class=\"line\">A((A&gt;=2)&amp;(A&lt;=6)) = 10</span><br></pre></td></tr></table></figure>\n\n<p>3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 删除</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br><span class=\"line\">A=A(~( (A&gt;=2) &amp; (A&lt;=6) ))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>本节内容不多，但是逻辑索引比起线性地址的等间距索引索引的产生要更加普遍，所以，希望读者熟练掌握这三种基本应用。</p>\n","site":{"data":{}},"excerpt":"<hr>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>上一节的内容中，我们介绍了索引的使用方法。索引的目的是为了取出矩阵中的一部分元素，因此我们知道通过元素在矩阵中的位置我们可以实现索引。在本节中，我们将介绍 MATLAB 中的逻辑变量以及通过逻辑变量索引的方法。</p>","more":"<blockquote>\n<p>MATLAB 中存在一种 logical（逻辑）类型用于表示逻辑上的真和假。在其他程序语言中，这样的一种类型也叫做 bool 型变量。这一种变量本身只有两种值，分别为 true 和 false。规定 false 对应数值 0，true 对应其他值（特别地，使用时可以用任意非零值代表 true，但存储时会自动转为 1 代表 true，这样的好处是只需要占用一个比特的空间）。</p>\n</blockquote>\n<h3 id=\"逻辑变量\"><a href=\"#逻辑变量\" class=\"headerlink\" title=\"逻辑变量\"></a><strong>逻辑变量</strong></h3><p>logical 变量只存在两种值 true（真）或者 false（假），规定分别用数字 1 和 0 存储。以逻辑值组成的矩阵称为逻辑矩阵。一般有以下几种创建逻辑矩阵的方法，各有用处。  </p>\n<h4 id=\"方法一：直接赋值法\"><a href=\"#方法一：直接赋值法\" class=\"headerlink\" title=\"方法一：直接赋值法\"></a>方法一：直接赋值法</h4><p>直接用 true，false 直接赋值到一个矩阵，缺点操作复杂，一般不考虑这种方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = [true false] % 正确实例</span><br><span class=\"line\">A = [1 0] % 错误实例</span><br><span class=\"line\">whos</span><br></pre></td></tr></table></figure>\n\n<p>输出值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x =</span><br><span class=\"line\">     1     0</span><br><span class=\"line\">A =</span><br><span class=\"line\">     1     0</span><br><span class=\"line\">% 尽管两个语句的输出一样</span><br><span class=\"line\">% 但是通过 whos 命令可以看到变量的类型不一样</span><br><span class=\"line\">% 可以看到只有用 true，false 直接赋值才能创建逻辑矩阵</span><br><span class=\"line\">% 一般不考虑这种方法</span><br><span class=\"line\">  Name      Size            Bytes  Class      Attributes</span><br><span class=\"line\"></span><br><span class=\"line\">  A         1x2                16  double               </span><br><span class=\"line\">  x         1x2                 2  logical</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二：logical-函数法\"><a href=\"#方法二：logical-函数法\" class=\"headerlink\" title=\"方法二：logical 函数法\"></a>方法二：logical 函数法</h4><p>logical 函数是将数值或矩阵转换为逻辑值的函数。遵循的转换规则为：非零值为逻辑 1，零值为逻辑 0。这种方法将一个矩阵非零值对应转为逻辑矩阵中的 1。可以用作非零值的逻辑索引。</p>\n<p>函数法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% logical</span><br><span class=\"line\">A = [1 0 3;0 5 6];</span><br><span class=\"line\">x1 = logical(1)</span><br><span class=\"line\">whos</span><br><span class=\"line\">% 对于传入的数值或矩阵</span><br><span class=\"line\">% 非零值为逻辑 1，零值为逻辑 0</span><br><span class=\"line\">x2 = logical(0)</span><br><span class=\"line\">x3 = logical(2)</span><br><span class=\"line\">x4 = logical(A)</span><br><span class=\"line\">% 生成的逻辑矩阵作为索引，可以取出矩阵中对应位置为 true 的元素</span><br><span class=\"line\">x5 = A(logical(A))</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% logical</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">% 观察两个变量的类型（Class）和比特数（Bytes）</span><br><span class=\"line\">% A 属于 double 类型（占用 48 比特）</span><br><span class=\"line\">% x1 属于 logical 类型（占用 1 比特）</span><br><span class=\"line\">  Name      Size            Bytes  Class      Attributes</span><br><span class=\"line\">  A         2x3                48  double               </span><br><span class=\"line\">  x1        1x1                 1  logical              </span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     1     0     1</span><br><span class=\"line\">     0     1     1  </span><br><span class=\"line\">% 形如 A(logical(A)) 可以取出 A 中的非零元素</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     5</span><br><span class=\"line\">     3</span><br><span class=\"line\">     6</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法三：借用逻辑表达式（命题）\"><a href=\"#方法三：借用逻辑表达式（命题）\" class=\"headerlink\" title=\"方法三：借用逻辑表达式（命题）\"></a>方法三：借用逻辑表达式（命题）</h4><p>命题就是判断一个事件的陈述句。对于数值来说一个判断的陈述句通过关系运算符连接。<br>MATLAB 的关系运算符共 6 个：等于（==），不等于（~=），大于等于（&gt;=），大于（&gt;），小于等于（&lt;=），小于（&lt;）。<br>这种方法创建逻辑矩阵最为常见，能够很高效地创建对应的逻辑矩阵，同时进行逻辑运算并作为索引</p>\n<p>逻辑表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 逻辑表达式</span><br><span class=\"line\">A = [1 0 3;0 5 6];</span><br><span class=\"line\">x1 = (3 == 2)</span><br><span class=\"line\">x2 = (3 ~= 2) </span><br><span class=\"line\">x3 = (3 &gt;= 2)</span><br><span class=\"line\">x4 = (3 &gt;  2)</span><br><span class=\"line\">x5 = (3 &lt;= 2)</span><br><span class=\"line\">x6 = (3 &lt;  2)</span><br><span class=\"line\">% 特别地，对矩阵使用关系运算符返回一个相应的逻辑矩阵</span><br><span class=\"line\">x7 = (A &lt; 4)</span><br><span class=\"line\">% 返回的矩阵是逻辑矩阵，又可以作为索引，取出矩阵中满足判断条件的元素</span><br><span class=\"line\">x8 = A(A &lt; 4)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 逻辑表达式</span><br><span class=\"line\">% 对于仅由数值构成的逻辑表达式，返回该表达式的真假性</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">x6 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">% 对于由矩阵构成的逻辑表达式，返回和该矩阵等大小的逻辑矩阵</span><br><span class=\"line\">% 逻辑矩阵的值是矩阵相应位置元素的判断情况</span><br><span class=\"line\">x7 =</span><br><span class=\"line\">     1     1     1</span><br><span class=\"line\">     1     0     0</span><br><span class=\"line\">% 第一行全行，第二行 1 个元素大于 4，满足判断记为 1，其他值记为 0</span><br><span class=\"line\">% 这里的 A(A &lt; 4) 就对应取出 A 中小于 4 的元素</span><br><span class=\"line\">x8 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     0</span><br><span class=\"line\">     0</span><br><span class=\"line\">     3</span><br></pre></td></tr></table></figure>\n\n<p>逻辑表达式的运算</p>\n<p>对于逻辑值之间的运算，可以实现逻辑表达式的复合运算，这时可以实现联合条件的逻辑索引。有四种运算：逻辑与（&amp;，&amp;&amp;），逻辑或（|，||），逻辑异或（xor 函数）和逻辑非（~）。这四种逻辑运算服从以下的真值表。</p>\n<p>逻辑真值表</p>\n<table>\n<thead>\n<tr>\n<th>A</th>\n<th>B</th>\n<th>A&amp;B</th>\n<th>A&#124;B</th>\n<th>xor(A,B)</th>\n<th>~A</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<p>应用实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A = [1 0 3;0 5 6];</span><br><span class=\"line\">x1 = A((A &lt; 4)&amp;(A &gt; 2))</span><br><span class=\"line\">x2 = A((A &lt; 4)|(A &gt; 2))</span><br><span class=\"line\">x3 = A(xor((A &lt; 4),(A &gt; 2)))</span><br><span class=\"line\">x4 = A(~(A &lt; 4))</span><br><span class=\"line\">% &amp;&amp; 和 || 是 &amp; 和 | 的变体</span><br><span class=\"line\">% 只能用于标量，不能用于矩阵，但速度更快</span><br><span class=\"line\">x5 = (3 &gt; 4)&amp;&amp;(3 &gt; 2)</span><br><span class=\"line\">x6 = (3 &gt; 2)||(3 &gt; 4)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% &amp; 与</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">% | 或</span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     0</span><br><span class=\"line\">     0</span><br><span class=\"line\">     5</span><br><span class=\"line\">     3</span><br><span class=\"line\">     6</span><br><span class=\"line\">% xor 函数 异或</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     1</span><br><span class=\"line\">     0</span><br><span class=\"line\">     0</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">% ~ 取非，取反</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">% &amp;&amp; 适用于标量的与（利用逻辑与的特性加速运算）</span><br><span class=\"line\">% （如果第一个值为 0，立即判断该值为 0）</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     0</span><br><span class=\"line\">% || 适用于标量的或（利用逻辑或的特性加速运算）</span><br><span class=\"line\">% （如果第一个值为 1，立即判断该值为 1）</span><br><span class=\"line\">x6 =</span><br><span class=\"line\">     1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"find-函数——逻辑索引的辅助工具\"><a href=\"#find-函数——逻辑索引的辅助工具\" class=\"headerlink\" title=\"find 函数——逻辑索引的辅助工具\"></a>find 函数——逻辑索引的辅助工具</h3><p>find 函数是将逻辑矩阵索引直接转换为直接索引（下标位置）的函数。我们有时候作出了判断，但是却需要直接索引的信息，这时可以利用find 函数进行转换；另一个用处是，找到前n个满足条件的索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% find函数</span><br><span class=\"line\">A = [2 5 4 0 0 6];</span><br><span class=\"line\">x1 = A &gt; 2</span><br><span class=\"line\">x2 = find(A &gt; 2)</span><br><span class=\"line\">B = [2 5 4;0 0 6];</span><br><span class=\"line\">% 按列产生线性地址索引</span><br><span class=\"line\">x3 = find(B &gt; 2)</span><br><span class=\"line\">x4 = B(find(B &gt; 2))</span><br><span class=\"line\">% 满足条件的前两个值的索引</span><br><span class=\"line\">x5 = find(B &gt; 2,2)</span><br></pre></td></tr></table></figure>\n\n<p>命令行输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% find函数</span><br><span class=\"line\">% 逻辑索引</span><br><span class=\"line\">x1 =</span><br><span class=\"line\">     0     1     1     0     0     1</span><br><span class=\"line\">% 线性地址索引</span><br><span class=\"line\">x2 =</span><br><span class=\"line\">     2     3     6</span><br><span class=\"line\">% 根据这个输出，可以发现，按列产生线性地址索引</span><br><span class=\"line\">x3 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">% 因为是线性地址索引，B(find(B &gt; 2)) 依然有效，结果与 B(B &gt; 2) 一样</span><br><span class=\"line\">x4 =</span><br><span class=\"line\">     5</span><br><span class=\"line\">     4</span><br><span class=\"line\">     6</span><br><span class=\"line\">% 满足条件的前两个值的索引</span><br><span class=\"line\">x5 =</span><br><span class=\"line\">     3</span><br><span class=\"line\">     5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重在应用\"><a href=\"#重在应用\" class=\"headerlink\" title=\"重在应用\"></a><strong>重在应用</strong></h3><p>以下是逻辑数组的三种基本应用，根据判断条件进行，逻辑索引查找，替换和删除。</p>\n<p>1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 查找</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br></pre></td></tr></table></figure>\n\n<p>2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 替换</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br></pre></td></tr></table></figure>\n\n<p>3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 删除(要求在矩阵 A 中改变值)</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br></pre></td></tr></table></figure>\n\n<p>参考思路</p>\n<p>1.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次找出其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 查找</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br><span class=\"line\">B = A((A&gt;=2)&amp;(A&lt;=6))</span><br></pre></td></tr></table></figure>\n\n<p>2.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，依次将其中在区间 [2,6] 中的数替换为 10。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 替换</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br><span class=\"line\">A((A&gt;=2)&amp;(A&lt;=6)) = 10</span><br></pre></td></tr></table></figure>\n\n<p>3.一组数据 [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3]，删除其中在区间 [2,6] 中的数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% 删除</span><br><span class=\"line\">A = [1 2 4 6 7 8 9 0 4 5 3 2 4 2 2 3 4 2 3];</span><br><span class=\"line\">A=A(~( (A&gt;=2) &amp; (A&lt;=6) ))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a><strong>小结</strong></h3><p>本节内容不多，但是逻辑索引比起线性地址的等间距索引索引的产生要更加普遍，所以，希望读者熟练掌握这三种基本应用。</p>"},{"title":"解决 Fluuter No toolchains found in the NDK toolchains folder for ABI with prefix： mips64el-linux-android 问题","date":"2019-07-28T08:50:35.000Z","_content":"\n### 解决 Flutter No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 问题\n\n\n\n#### 运行 Flutter  项目时常常出现以下问题：\n\n> No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android\n\n```dart\n           Exit code 1 from: C:\\Users\\sawan\\Documents\\test-app\\android\\gradlew.bat app:properties:\n\n           FAILURE: Build failed with an exception.\n\n           * Where:\n           Build file 'C:\\Users\\XXXX\\Documents\\test-app\\android\\build.gradle' line: 24\n\n           * What went wrong:\n           A problem occurred evaluating root project 'android'.\n           > A problem occurred configuring project ':app'.\n              > No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android\n\n           * Try:\n           Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n           * Get more help at https://help.gradle.org\n\n           BUILD FAILED in 0s\n```\n\n<!--more-->\n\n#### **这个问题常见于运行旧有的 Flutter 项目时。这是由于 gradle 版本与当前的 Flutter 版本不匹配导致的。**\n\n需要在项目中的两处位置进行修改：\n\n1. ### `android/gradle/gradle-wrapper.properties`\n\n   ```properties\n   change \n   \n   distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n   \n   to\n   \n   distributionUrl=https\\://services.gradle.org/distributions/gradle-4.10.2-all.zip\n   \n   ```\n\n1. ### `android/build.gradle`\n\n   ```groovy\n   change \n   classpath 'com.android.tools.build:gradle:3.0.1'\n   \n   to\n   classpath 'com.android.tools.build:gradle:3.2.1'\n   ```\n\n   \n\n这个问题出现过几次，偶尔会不知所措，以此为鉴。\n\n\n\n","source":"_posts/flutter-No-NDK-toolchains-Error.md","raw":"---\ntitle: 解决 Fluuter No toolchains found in the NDK toolchains folder for ABI with prefix： mips64el-linux-android 问题\ndate: 2019-07-28 16:50:35\ntags: [flutter,Dart]\n---\n\n### 解决 Flutter No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 问题\n\n\n\n#### 运行 Flutter  项目时常常出现以下问题：\n\n> No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android\n\n```dart\n           Exit code 1 from: C:\\Users\\sawan\\Documents\\test-app\\android\\gradlew.bat app:properties:\n\n           FAILURE: Build failed with an exception.\n\n           * Where:\n           Build file 'C:\\Users\\XXXX\\Documents\\test-app\\android\\build.gradle' line: 24\n\n           * What went wrong:\n           A problem occurred evaluating root project 'android'.\n           > A problem occurred configuring project ':app'.\n              > No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android\n\n           * Try:\n           Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n           * Get more help at https://help.gradle.org\n\n           BUILD FAILED in 0s\n```\n\n<!--more-->\n\n#### **这个问题常见于运行旧有的 Flutter 项目时。这是由于 gradle 版本与当前的 Flutter 版本不匹配导致的。**\n\n需要在项目中的两处位置进行修改：\n\n1. ### `android/gradle/gradle-wrapper.properties`\n\n   ```properties\n   change \n   \n   distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n   \n   to\n   \n   distributionUrl=https\\://services.gradle.org/distributions/gradle-4.10.2-all.zip\n   \n   ```\n\n1. ### `android/build.gradle`\n\n   ```groovy\n   change \n   classpath 'com.android.tools.build:gradle:3.0.1'\n   \n   to\n   classpath 'com.android.tools.build:gradle:3.2.1'\n   ```\n\n   \n\n这个问题出现过几次，偶尔会不知所措，以此为鉴。\n\n\n\n","slug":"flutter-No-NDK-toolchains-Error","published":1,"updated":"2020-03-15T21:05:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wk000r29fyswnqfaxl","content":"<h3 id=\"解决-Flutter-No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android-问题\"><a href=\"#解决-Flutter-No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android-问题\" class=\"headerlink\" title=\"解决 Flutter No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 问题\"></a>解决 Flutter No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 问题</h3><h4 id=\"运行-Flutter-项目时常常出现以下问题：\"><a href=\"#运行-Flutter-项目时常常出现以下问题：\" class=\"headerlink\" title=\"运行 Flutter  项目时常常出现以下问题：\"></a>运行 Flutter  项目时常常出现以下问题：</h4><blockquote>\n<p>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exit code <span class=\"number\">1</span> from: C:\\Users\\sawan\\Documents\\test-app\\android\\gradlew.bat app:properties:</span><br><span class=\"line\"></span><br><span class=\"line\">FAILURE: Build failed <span class=\"keyword\">with</span> an exception.</span><br><span class=\"line\"></span><br><span class=\"line\">* Where:</span><br><span class=\"line\">Build file <span class=\"string\">'C:\\Users\\XXXX\\Documents\\test-app\\android\\build.gradle'</span> line: <span class=\"number\">24</span></span><br><span class=\"line\"></span><br><span class=\"line\">* What went wrong:</span><br><span class=\"line\">A problem occurred evaluating root project <span class=\"string\">'android'</span>.</span><br><span class=\"line\">&gt; A problem occurred configuring project <span class=\"string\">':app'</span>.</span><br><span class=\"line\">   &gt; No toolchains found <span class=\"keyword\">in</span> the NDK toolchains folder <span class=\"keyword\">for</span> ABI <span class=\"keyword\">with</span> prefix: mips64el-linux-android</span><br><span class=\"line\"></span><br><span class=\"line\">* Try:</span><br><span class=\"line\">Run <span class=\"keyword\">with</span> --stacktrace option to <span class=\"keyword\">get</span> the stack trace. Run <span class=\"keyword\">with</span> --info or --debug option to <span class=\"keyword\">get</span> more log output.</span><br><span class=\"line\"></span><br><span class=\"line\">* Get more help at https:<span class=\"comment\">//help.gradle.org</span></span><br><span class=\"line\"></span><br><span class=\"line\">BUILD FAILED <span class=\"keyword\">in</span> <span class=\"number\">0</span>s</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h4 id=\"这个问题常见于运行旧有的-Flutter-项目时。这是由于-gradle-版本与当前的-Flutter-版本不匹配导致的。\"><a href=\"#这个问题常见于运行旧有的-Flutter-项目时。这是由于-gradle-版本与当前的-Flutter-版本不匹配导致的。\" class=\"headerlink\" title=\"这个问题常见于运行旧有的 Flutter 项目时。这是由于 gradle 版本与当前的 Flutter 版本不匹配导致的。\"></a><strong>这个问题常见于运行旧有的 Flutter 项目时。这是由于 gradle 版本与当前的 Flutter 版本不匹配导致的。</strong></h4><p>需要在项目中的两处位置进行修改：</p>\n<ol>\n<li><h3 id=\"android-gradle-gradle-wrapper-properties\"><a href=\"#android-gradle-gradle-wrapper-properties\" class=\"headerlink\" title=\"android/gradle/gradle-wrapper.properties\"></a><code>android/gradle/gradle-wrapper.properties</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change </span><br><span class=\"line\"></span><br><span class=\"line\">distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip</span><br><span class=\"line\"></span><br><span class=\"line\">to</span><br><span class=\"line\"></span><br><span class=\"line\">distributionUrl=https\\://services.gradle.org/distributions/gradle-4.10.2-all.zip</span><br></pre></td></tr></table></figure>\n</li>\n<li><h3 id=\"android-build-gradle\"><a href=\"#android-build-gradle\" class=\"headerlink\" title=\"android/build.gradle\"></a><code>android/build.gradle</code></h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change </span><br><span class=\"line\">classpath <span class=\"string\">'com.android.tools.build:gradle:3.0.1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">to</span><br><span class=\"line\">classpath <span class=\"string\">'com.android.tools.build:gradle:3.2.1'</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<p>这个问题出现过几次，偶尔会不知所措，以此为鉴。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"解决-Flutter-No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android-问题\"><a href=\"#解决-Flutter-No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android-问题\" class=\"headerlink\" title=\"解决 Flutter No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 问题\"></a>解决 Flutter No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android 问题</h3><h4 id=\"运行-Flutter-项目时常常出现以下问题：\"><a href=\"#运行-Flutter-项目时常常出现以下问题：\" class=\"headerlink\" title=\"运行 Flutter  项目时常常出现以下问题：\"></a>运行 Flutter  项目时常常出现以下问题：</h4><blockquote>\n<p>No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exit code <span class=\"number\">1</span> from: C:\\Users\\sawan\\Documents\\test-app\\android\\gradlew.bat app:properties:</span><br><span class=\"line\"></span><br><span class=\"line\">FAILURE: Build failed <span class=\"keyword\">with</span> an exception.</span><br><span class=\"line\"></span><br><span class=\"line\">* Where:</span><br><span class=\"line\">Build file <span class=\"string\">'C:\\Users\\XXXX\\Documents\\test-app\\android\\build.gradle'</span> line: <span class=\"number\">24</span></span><br><span class=\"line\"></span><br><span class=\"line\">* What went wrong:</span><br><span class=\"line\">A problem occurred evaluating root project <span class=\"string\">'android'</span>.</span><br><span class=\"line\">&gt; A problem occurred configuring project <span class=\"string\">':app'</span>.</span><br><span class=\"line\">   &gt; No toolchains found <span class=\"keyword\">in</span> the NDK toolchains folder <span class=\"keyword\">for</span> ABI <span class=\"keyword\">with</span> prefix: mips64el-linux-android</span><br><span class=\"line\"></span><br><span class=\"line\">* Try:</span><br><span class=\"line\">Run <span class=\"keyword\">with</span> --stacktrace option to <span class=\"keyword\">get</span> the stack trace. Run <span class=\"keyword\">with</span> --info or --debug option to <span class=\"keyword\">get</span> more log output.</span><br><span class=\"line\"></span><br><span class=\"line\">* Get more help at https:<span class=\"comment\">//help.gradle.org</span></span><br><span class=\"line\"></span><br><span class=\"line\">BUILD FAILED <span class=\"keyword\">in</span> <span class=\"number\">0</span>s</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"这个问题常见于运行旧有的-Flutter-项目时。这是由于-gradle-版本与当前的-Flutter-版本不匹配导致的。\"><a href=\"#这个问题常见于运行旧有的-Flutter-项目时。这是由于-gradle-版本与当前的-Flutter-版本不匹配导致的。\" class=\"headerlink\" title=\"这个问题常见于运行旧有的 Flutter 项目时。这是由于 gradle 版本与当前的 Flutter 版本不匹配导致的。\"></a><strong>这个问题常见于运行旧有的 Flutter 项目时。这是由于 gradle 版本与当前的 Flutter 版本不匹配导致的。</strong></h4><p>需要在项目中的两处位置进行修改：</p>\n<ol>\n<li><h3 id=\"android-gradle-gradle-wrapper-properties\"><a href=\"#android-gradle-gradle-wrapper-properties\" class=\"headerlink\" title=\"android/gradle/gradle-wrapper.properties\"></a><code>android/gradle/gradle-wrapper.properties</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change </span><br><span class=\"line\"></span><br><span class=\"line\">distributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip</span><br><span class=\"line\"></span><br><span class=\"line\">to</span><br><span class=\"line\"></span><br><span class=\"line\">distributionUrl=https\\://services.gradle.org/distributions/gradle-4.10.2-all.zip</span><br></pre></td></tr></table></figure>\n</li>\n<li><h3 id=\"android-build-gradle\"><a href=\"#android-build-gradle\" class=\"headerlink\" title=\"android/build.gradle\"></a><code>android/build.gradle</code></h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">change </span><br><span class=\"line\">classpath <span class=\"string\">'com.android.tools.build:gradle:3.0.1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">to</span><br><span class=\"line\">classpath <span class=\"string\">'com.android.tools.build:gradle:3.2.1'</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<p>这个问题出现过几次，偶尔会不知所措，以此为鉴。</p>"},{"title":"git 笔记","date":"2019-10-15T13:40:43.000Z","_content":"\n\n\n### git 使用规范\n\n\n<!--more-->\n\n1. ***请务必在提交信息中提供有价值的内容***\n\ngit commit 的提交信息应当传达代码修改的目的。一方面应当传达修改的模块和范围，另一方面也可以简要描述编码思路以通过 Code Review。\n\n```git\ngit commit -m \"[ADD/EDIT/DELETE/REFACTOR/FIX] 2019-10-11 14:40:48 Add kotlin support to this project. / Refactor a algorithm. \"\n\n```\n\n2. 尽可能使用英文来进行你的每一次提交\n\n尽管个人的英文水平不同，但是有一点要注意的是，Github 是一个全球的社区，每个人的代码都有机会被不同语言的使用者看见，做好 in8n 是程序员的本分工作。\n\n\n3. 对于需要修复 bug 的情况，应当把相应的 bugId 进行传递\n\n这将会便于项目对于 bug 的跟踪。特别地一个 bug 被重新打开时，也许就是对指定 bugId 下代码进行重构的时候了。\n\n4. 区分 git pull 跟 git push 的区别。\n\ngit pull 的操作对象是工作区（workspace），会将远程代码的改动直接影响到工作区；\ngit fetch 的操作对象是本地仓库（local repository），只是将远程代码更新到本地仓库；\n\n换言之，使用 git fetch 相比之下要安全得多，尤其团队当中使用使用 Code Review 的时候，定期同步本地仓库而不更改工作区的内容是十分必要的，\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 急救措施，\n\n之前使用 Gerrit 时出现过代码被 Abandoned 之后导致代码无法提交到 Gerrit 服务器的情况。\n\n自救方案：\n\n1. **（非常重要）使用 git stash ，将当前所有代码保存到暂存区。**\n\n2. 确认被 Abandoned 的 Commit 的时间和 commit Id;\n\n3. Checkout 到某一次 commit （在 Abandoned 之前）;\n\n4. git fetch 拉取最新的代码，并且解决 Conflict;\n\n5. git commit -m \"solve Abandoned problem\" && git push  提交并推至 Gerrit ","source":"_posts/git 笔记.md","raw":"---\ntitle: git 笔记\ndate: 2019-10-15 21:40:43\ntags: git\n---\n\n\n\n### git 使用规范\n\n\n<!--more-->\n\n1. ***请务必在提交信息中提供有价值的内容***\n\ngit commit 的提交信息应当传达代码修改的目的。一方面应当传达修改的模块和范围，另一方面也可以简要描述编码思路以通过 Code Review。\n\n```git\ngit commit -m \"[ADD/EDIT/DELETE/REFACTOR/FIX] 2019-10-11 14:40:48 Add kotlin support to this project. / Refactor a algorithm. \"\n\n```\n\n2. 尽可能使用英文来进行你的每一次提交\n\n尽管个人的英文水平不同，但是有一点要注意的是，Github 是一个全球的社区，每个人的代码都有机会被不同语言的使用者看见，做好 in8n 是程序员的本分工作。\n\n\n3. 对于需要修复 bug 的情况，应当把相应的 bugId 进行传递\n\n这将会便于项目对于 bug 的跟踪。特别地一个 bug 被重新打开时，也许就是对指定 bugId 下代码进行重构的时候了。\n\n4. 区分 git pull 跟 git push 的区别。\n\ngit pull 的操作对象是工作区（workspace），会将远程代码的改动直接影响到工作区；\ngit fetch 的操作对象是本地仓库（local repository），只是将远程代码更新到本地仓库；\n\n换言之，使用 git fetch 相比之下要安全得多，尤其团队当中使用使用 Code Review 的时候，定期同步本地仓库而不更改工作区的内容是十分必要的，\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 急救措施，\n\n之前使用 Gerrit 时出现过代码被 Abandoned 之后导致代码无法提交到 Gerrit 服务器的情况。\n\n自救方案：\n\n1. **（非常重要）使用 git stash ，将当前所有代码保存到暂存区。**\n\n2. 确认被 Abandoned 的 Commit 的时间和 commit Id;\n\n3. Checkout 到某一次 commit （在 Abandoned 之前）;\n\n4. git fetch 拉取最新的代码，并且解决 Conflict;\n\n5. git commit -m \"solve Abandoned problem\" && git push  提交并推至 Gerrit ","slug":"git 笔记","published":1,"updated":"2020-03-15T21:05:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wl000s29fyikpeu3nj","content":"<h3 id=\"git-使用规范\"><a href=\"#git-使用规范\" class=\"headerlink\" title=\"git 使用规范\"></a>git 使用规范</h3><a id=\"more\"></a>\n\n<ol>\n<li><strong><em>请务必在提交信息中提供有价值的内容</em></strong></li>\n</ol>\n<p>git commit 的提交信息应当传达代码修改的目的。一方面应当传达修改的模块和范围，另一方面也可以简要描述编码思路以通过 Code Review。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;[ADD/EDIT/DELETE/REFACTOR/FIX] 2019-10-11 14:40:48 Add kotlin support to this project. / Refactor a algorithm. &quot;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>尽可能使用英文来进行你的每一次提交</li>\n</ol>\n<p>尽管个人的英文水平不同，但是有一点要注意的是，Github 是一个全球的社区，每个人的代码都有机会被不同语言的使用者看见，做好 in8n 是程序员的本分工作。</p>\n<ol start=\"3\">\n<li>对于需要修复 bug 的情况，应当把相应的 bugId 进行传递</li>\n</ol>\n<p>这将会便于项目对于 bug 的跟踪。特别地一个 bug 被重新打开时，也许就是对指定 bugId 下代码进行重构的时候了。</p>\n<ol start=\"4\">\n<li>区分 git pull 跟 git push 的区别。</li>\n</ol>\n<p>git pull 的操作对象是工作区（workspace），会将远程代码的改动直接影响到工作区；<br>git fetch 的操作对象是本地仓库（local repository），只是将远程代码更新到本地仓库；</p>\n<p>换言之，使用 git fetch 相比之下要安全得多，尤其团队当中使用使用 Code Review 的时候，定期同步本地仓库而不更改工作区的内容是十分必要的，</p>\n<h3 id=\"急救措施，\"><a href=\"#急救措施，\" class=\"headerlink\" title=\"急救措施，\"></a>急救措施，</h3><p>之前使用 Gerrit 时出现过代码被 Abandoned 之后导致代码无法提交到 Gerrit 服务器的情况。</p>\n<p>自救方案：</p>\n<ol>\n<li><p><strong>（非常重要）使用 git stash ，将当前所有代码保存到暂存区。</strong></p>\n</li>\n<li><p>确认被 Abandoned 的 Commit 的时间和 commit Id;</p>\n</li>\n<li><p>Checkout 到某一次 commit （在 Abandoned 之前）;</p>\n</li>\n<li><p>git fetch 拉取最新的代码，并且解决 Conflict;</p>\n</li>\n<li><p>git commit -m “solve Abandoned problem” &amp;&amp; git push  提交并推至 Gerrit </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"git-使用规范\"><a href=\"#git-使用规范\" class=\"headerlink\" title=\"git 使用规范\"></a>git 使用规范</h3>","more":"<ol>\n<li><strong><em>请务必在提交信息中提供有价值的内容</em></strong></li>\n</ol>\n<p>git commit 的提交信息应当传达代码修改的目的。一方面应当传达修改的模块和范围，另一方面也可以简要描述编码思路以通过 Code Review。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;[ADD/EDIT/DELETE/REFACTOR/FIX] 2019-10-11 14:40:48 Add kotlin support to this project. / Refactor a algorithm. &quot;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>尽可能使用英文来进行你的每一次提交</li>\n</ol>\n<p>尽管个人的英文水平不同，但是有一点要注意的是，Github 是一个全球的社区，每个人的代码都有机会被不同语言的使用者看见，做好 in8n 是程序员的本分工作。</p>\n<ol start=\"3\">\n<li>对于需要修复 bug 的情况，应当把相应的 bugId 进行传递</li>\n</ol>\n<p>这将会便于项目对于 bug 的跟踪。特别地一个 bug 被重新打开时，也许就是对指定 bugId 下代码进行重构的时候了。</p>\n<ol start=\"4\">\n<li>区分 git pull 跟 git push 的区别。</li>\n</ol>\n<p>git pull 的操作对象是工作区（workspace），会将远程代码的改动直接影响到工作区；<br>git fetch 的操作对象是本地仓库（local repository），只是将远程代码更新到本地仓库；</p>\n<p>换言之，使用 git fetch 相比之下要安全得多，尤其团队当中使用使用 Code Review 的时候，定期同步本地仓库而不更改工作区的内容是十分必要的，</p>\n<h3 id=\"急救措施，\"><a href=\"#急救措施，\" class=\"headerlink\" title=\"急救措施，\"></a>急救措施，</h3><p>之前使用 Gerrit 时出现过代码被 Abandoned 之后导致代码无法提交到 Gerrit 服务器的情况。</p>\n<p>自救方案：</p>\n<ol>\n<li><p><strong>（非常重要）使用 git stash ，将当前所有代码保存到暂存区。</strong></p>\n</li>\n<li><p>确认被 Abandoned 的 Commit 的时间和 commit Id;</p>\n</li>\n<li><p>Checkout 到某一次 commit （在 Abandoned 之前）;</p>\n</li>\n<li><p>git fetch 拉取最新的代码，并且解决 Conflict;</p>\n</li>\n<li><p>git commit -m “solve Abandoned problem” &amp;&amp; git push  提交并推至 Gerrit </p>\n</li>\n</ol>"},{"title":"js 重定向问题","date":"2019-10-18T05:42:56.000Z","_content":"\n## 重定向问题 \n\n处理 TWebCollectDetailsAvtivity 跳转 www.shejiben.com 时，会出现重定向的干扰，这里分析一下这个问题。\n\n<!--more-->\n### HTTP 重定向\n\n> 场景：直接在移动 webView 中访问 www.shejiben.com\n\n> 结果：服务器返回 302 状态码，页面定向到 Location 指定链接\n\nHttp 返回的情况\n\n```\nHTTP/1.1 302 Found\nServer: openresty/1.13.6.2\nDate: Fri, 18 Oct 2019 03:33:01 GMT\nContent-Type: text/html; charset=UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\nX-Powered-By: PHP/7.1.7\nLocation: https://m.shejiben.com/?channel=to8to123&appversion=7.12.0&systemversion=28&appid=15&version=2.5&appostype=1&appversioncode=17120&cityName=%E6%B7%B1%E5%9C%B3&first_id=97822deafdae9f38fdd5ed2ab0e135b8&isnew=0&cityid=1130&imei=866370030115364&t8t_device_id=866370030115364&pro_sourceid=104&pro_s_sourceid=101&apkPackageName=com.to8to.housekeeper&deviceModel=BND-AL10-BND-AL10&cityId=1130\nCache-Control: no-cache\n\n0\n\n```\n\n\n\n\n\n### JavaScript 重定向\n\n### window.location.href = ;\n\n通过直接改变页面当中 window.location.href 实现跳转\n\n> 场景通过土巴兔 APP 打开 链接 www.shejiben.com，自动重定向至 m.shejiben.com\n\n```\nHTTP/1.1 200 OK\nServer: openresty/1.13.6.2\nDate: Fri, 18 Oct 2019 03:33:08 GMT\nContent-Type: text/html; charset=UTF-8\nConnection: keep-alive\nX-Powered-By: PHP/7.1.7\nSet-Cookie: to8to_auth=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_la=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_nick=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_uid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_ind=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_styleid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_referer=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_username=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_app_source=1; expires=Fri, 18-Oct-2019 04:03:08 GMT; Max-Age=1800; path=/; domain=shejiben.com\nSet-Cookie: to8to_appversion=7.12.0; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com\nSet-Cookie: to8to_appostype=1; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com\nCache-Control: no-cache,must-revalidate\nPragma: no-cache\nExpires: 0\nContent-Length: 485\n\n<script type=\"text/javascript\">\n    window.location.href='https://m.shejiben.com/?app_source=1&time=1571369588&channel=to8to123&appversion=7.12.0&systemversion=28&appid=15&version=2.5&appostype=1&appversioncode=17120&cityName=%E6%B7%B1%E5%9C%B3&first_id=97822deafdae9f38fdd5ed2ab0e135b8&isnew=0&cityid=1130&imei=866370030115364&t8t_device_id=866370030115364&pro_sourceid=104&pro_s_sourceid=101&apkPackageName=com.to8to.housekeeper&deviceModel=BND-AL10-BND-AL10&cityId=1130';\n</script>\n\n```\n\n\n### window.location.replace = ;\n\n> 使用 window.location.href 是常见的跳转逻辑的实现；这种方式的问题在于，当前页面作为一个中间页面被存在了浏览记录中。由此会导致自动执行 window.location.href 的页面又会重新跳转至目标页面。\n\n","source":"_posts/js 重定向问题.md","raw":"---\ntitle: js 重定向问题\ndate: 2019-10-18 13:42:56\ntags: JavaScript\n---\n\n## 重定向问题 \n\n处理 TWebCollectDetailsAvtivity 跳转 www.shejiben.com 时，会出现重定向的干扰，这里分析一下这个问题。\n\n<!--more-->\n### HTTP 重定向\n\n> 场景：直接在移动 webView 中访问 www.shejiben.com\n\n> 结果：服务器返回 302 状态码，页面定向到 Location 指定链接\n\nHttp 返回的情况\n\n```\nHTTP/1.1 302 Found\nServer: openresty/1.13.6.2\nDate: Fri, 18 Oct 2019 03:33:01 GMT\nContent-Type: text/html; charset=UTF-8\nTransfer-Encoding: chunked\nConnection: keep-alive\nX-Powered-By: PHP/7.1.7\nLocation: https://m.shejiben.com/?channel=to8to123&appversion=7.12.0&systemversion=28&appid=15&version=2.5&appostype=1&appversioncode=17120&cityName=%E6%B7%B1%E5%9C%B3&first_id=97822deafdae9f38fdd5ed2ab0e135b8&isnew=0&cityid=1130&imei=866370030115364&t8t_device_id=866370030115364&pro_sourceid=104&pro_s_sourceid=101&apkPackageName=com.to8to.housekeeper&deviceModel=BND-AL10-BND-AL10&cityId=1130\nCache-Control: no-cache\n\n0\n\n```\n\n\n\n\n\n### JavaScript 重定向\n\n### window.location.href = ;\n\n通过直接改变页面当中 window.location.href 实现跳转\n\n> 场景通过土巴兔 APP 打开 链接 www.shejiben.com，自动重定向至 m.shejiben.com\n\n```\nHTTP/1.1 200 OK\nServer: openresty/1.13.6.2\nDate: Fri, 18 Oct 2019 03:33:08 GMT\nContent-Type: text/html; charset=UTF-8\nConnection: keep-alive\nX-Powered-By: PHP/7.1.7\nSet-Cookie: to8to_auth=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_la=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_nick=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_uid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_ind=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_styleid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_referer=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_username=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com\nSet-Cookie: to8to_app_source=1; expires=Fri, 18-Oct-2019 04:03:08 GMT; Max-Age=1800; path=/; domain=shejiben.com\nSet-Cookie: to8to_appversion=7.12.0; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com\nSet-Cookie: to8to_appostype=1; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com\nCache-Control: no-cache,must-revalidate\nPragma: no-cache\nExpires: 0\nContent-Length: 485\n\n<script type=\"text/javascript\">\n    window.location.href='https://m.shejiben.com/?app_source=1&time=1571369588&channel=to8to123&appversion=7.12.0&systemversion=28&appid=15&version=2.5&appostype=1&appversioncode=17120&cityName=%E6%B7%B1%E5%9C%B3&first_id=97822deafdae9f38fdd5ed2ab0e135b8&isnew=0&cityid=1130&imei=866370030115364&t8t_device_id=866370030115364&pro_sourceid=104&pro_s_sourceid=101&apkPackageName=com.to8to.housekeeper&deviceModel=BND-AL10-BND-AL10&cityId=1130';\n</script>\n\n```\n\n\n### window.location.replace = ;\n\n> 使用 window.location.href 是常见的跳转逻辑的实现；这种方式的问题在于，当前页面作为一个中间页面被存在了浏览记录中。由此会导致自动执行 window.location.href 的页面又会重新跳转至目标页面。\n\n","slug":"js 重定向问题","published":1,"updated":"2020-03-15T21:05:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wl000t29fy8gubjbgr","content":"<h2 id=\"重定向问题\"><a href=\"#重定向问题\" class=\"headerlink\" title=\"重定向问题\"></a>重定向问题</h2><p>处理 TWebCollectDetailsAvtivity 跳转 <a href=\"http://www.shejiben.com\" target=\"_blank\" rel=\"noopener\">www.shejiben.com</a> 时，会出现重定向的干扰，这里分析一下这个问题。</p>\n<a id=\"more\"></a>\n<h3 id=\"HTTP-重定向\"><a href=\"#HTTP-重定向\" class=\"headerlink\" title=\"HTTP 重定向\"></a>HTTP 重定向</h3><blockquote>\n<p>场景：直接在移动 webView 中访问 <a href=\"http://www.shejiben.com\" target=\"_blank\" rel=\"noopener\">www.shejiben.com</a></p>\n</blockquote>\n<blockquote>\n<p>结果：服务器返回 302 状态码，页面定向到 Location 指定链接</p>\n</blockquote>\n<p>Http 返回的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 302 Found</span><br><span class=\"line\">Server: openresty/1.13.6.2</span><br><span class=\"line\">Date: Fri, 18 Oct 2019 03:33:01 GMT</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">X-Powered-By: PHP/7.1.7</span><br><span class=\"line\">Location: https://m.shejiben.com/?channel=to8to123&amp;appversion=7.12.0&amp;systemversion=28&amp;appid=15&amp;version=2.5&amp;appostype=1&amp;appversioncode=17120&amp;cityName=%E6%B7%B1%E5%9C%B3&amp;first_id=97822deafdae9f38fdd5ed2ab0e135b8&amp;isnew=0&amp;cityid=1130&amp;imei=866370030115364&amp;t8t_device_id=866370030115364&amp;pro_sourceid=104&amp;pro_s_sourceid=101&amp;apkPackageName=com.to8to.housekeeper&amp;deviceModel=BND-AL10-BND-AL10&amp;cityId=1130</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript-重定向\"><a href=\"#JavaScript-重定向\" class=\"headerlink\" title=\"JavaScript 重定向\"></a>JavaScript 重定向</h3><h3 id=\"window-location-href\"><a href=\"#window-location-href\" class=\"headerlink\" title=\"window.location.href = ;\"></a>window.location.href = ;</h3><p>通过直接改变页面当中 window.location.href 实现跳转</p>\n<blockquote>\n<p>场景通过土巴兔 APP 打开 链接 <a href=\"http://www.shejiben.com，自动重定向至\" target=\"_blank\" rel=\"noopener\">www.shejiben.com，自动重定向至</a> m.shejiben.com</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Server: openresty/1.13.6.2</span><br><span class=\"line\">Date: Fri, 18 Oct 2019 03:33:08 GMT</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">X-Powered-By: PHP/7.1.7</span><br><span class=\"line\">Set-Cookie: to8to_auth=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_la=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_nick=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_uid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_ind=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_styleid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_referer=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_username=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_app_source=1; expires=Fri, 18-Oct-2019 04:03:08 GMT; Max-Age=1800; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_appversion=7.12.0; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_appostype=1; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com</span><br><span class=\"line\">Cache-Control: no-cache,must-revalidate</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Expires: 0</span><br><span class=\"line\">Content-Length: 485</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    window.location.href=&apos;https://m.shejiben.com/?app_source=1&amp;time=1571369588&amp;channel=to8to123&amp;appversion=7.12.0&amp;systemversion=28&amp;appid=15&amp;version=2.5&amp;appostype=1&amp;appversioncode=17120&amp;cityName=%E6%B7%B1%E5%9C%B3&amp;first_id=97822deafdae9f38fdd5ed2ab0e135b8&amp;isnew=0&amp;cityid=1130&amp;imei=866370030115364&amp;t8t_device_id=866370030115364&amp;pro_sourceid=104&amp;pro_s_sourceid=101&amp;apkPackageName=com.to8to.housekeeper&amp;deviceModel=BND-AL10-BND-AL10&amp;cityId=1130&apos;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"window-location-replace\"><a href=\"#window-location-replace\" class=\"headerlink\" title=\"window.location.replace = ;\"></a>window.location.replace = ;</h3><blockquote>\n<p>使用 window.location.href 是常见的跳转逻辑的实现；这种方式的问题在于，当前页面作为一个中间页面被存在了浏览记录中。由此会导致自动执行 window.location.href 的页面又会重新跳转至目标页面。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"重定向问题\"><a href=\"#重定向问题\" class=\"headerlink\" title=\"重定向问题\"></a>重定向问题</h2><p>处理 TWebCollectDetailsAvtivity 跳转 <a href=\"http://www.shejiben.com\" target=\"_blank\" rel=\"noopener\">www.shejiben.com</a> 时，会出现重定向的干扰，这里分析一下这个问题。</p>","more":"<h3 id=\"HTTP-重定向\"><a href=\"#HTTP-重定向\" class=\"headerlink\" title=\"HTTP 重定向\"></a>HTTP 重定向</h3><blockquote>\n<p>场景：直接在移动 webView 中访问 <a href=\"http://www.shejiben.com\" target=\"_blank\" rel=\"noopener\">www.shejiben.com</a></p>\n</blockquote>\n<blockquote>\n<p>结果：服务器返回 302 状态码，页面定向到 Location 指定链接</p>\n</blockquote>\n<p>Http 返回的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 302 Found</span><br><span class=\"line\">Server: openresty/1.13.6.2</span><br><span class=\"line\">Date: Fri, 18 Oct 2019 03:33:01 GMT</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">X-Powered-By: PHP/7.1.7</span><br><span class=\"line\">Location: https://m.shejiben.com/?channel=to8to123&amp;appversion=7.12.0&amp;systemversion=28&amp;appid=15&amp;version=2.5&amp;appostype=1&amp;appversioncode=17120&amp;cityName=%E6%B7%B1%E5%9C%B3&amp;first_id=97822deafdae9f38fdd5ed2ab0e135b8&amp;isnew=0&amp;cityid=1130&amp;imei=866370030115364&amp;t8t_device_id=866370030115364&amp;pro_sourceid=104&amp;pro_s_sourceid=101&amp;apkPackageName=com.to8to.housekeeper&amp;deviceModel=BND-AL10-BND-AL10&amp;cityId=1130</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\"></span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript-重定向\"><a href=\"#JavaScript-重定向\" class=\"headerlink\" title=\"JavaScript 重定向\"></a>JavaScript 重定向</h3><h3 id=\"window-location-href\"><a href=\"#window-location-href\" class=\"headerlink\" title=\"window.location.href = ;\"></a>window.location.href = ;</h3><p>通过直接改变页面当中 window.location.href 实现跳转</p>\n<blockquote>\n<p>场景通过土巴兔 APP 打开 链接 <a href=\"http://www.shejiben.com，自动重定向至\" target=\"_blank\" rel=\"noopener\">www.shejiben.com，自动重定向至</a> m.shejiben.com</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Server: openresty/1.13.6.2</span><br><span class=\"line\">Date: Fri, 18 Oct 2019 03:33:08 GMT</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">X-Powered-By: PHP/7.1.7</span><br><span class=\"line\">Set-Cookie: to8to_auth=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_la=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_nick=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_uid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_ind=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_styleid=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_referer=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_username=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_to8to_tbdl_login=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_app_source=1; expires=Fri, 18-Oct-2019 04:03:08 GMT; Max-Age=1800; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_appversion=7.12.0; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com</span><br><span class=\"line\">Set-Cookie: to8to_appostype=1; expires=Sat, 19-Oct-2019 03:33:08 GMT; Max-Age=86400; path=/; domain=shejiben.com</span><br><span class=\"line\">Cache-Control: no-cache,must-revalidate</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Expires: 0</span><br><span class=\"line\">Content-Length: 485</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">    window.location.href=&apos;https://m.shejiben.com/?app_source=1&amp;time=1571369588&amp;channel=to8to123&amp;appversion=7.12.0&amp;systemversion=28&amp;appid=15&amp;version=2.5&amp;appostype=1&amp;appversioncode=17120&amp;cityName=%E6%B7%B1%E5%9C%B3&amp;first_id=97822deafdae9f38fdd5ed2ab0e135b8&amp;isnew=0&amp;cityid=1130&amp;imei=866370030115364&amp;t8t_device_id=866370030115364&amp;pro_sourceid=104&amp;pro_s_sourceid=101&amp;apkPackageName=com.to8to.housekeeper&amp;deviceModel=BND-AL10-BND-AL10&amp;cityId=1130&apos;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"window-location-replace\"><a href=\"#window-location-replace\" class=\"headerlink\" title=\"window.location.replace = ;\"></a>window.location.replace = ;</h3><blockquote>\n<p>使用 window.location.href 是常见的跳转逻辑的实现；这种方式的问题在于，当前页面作为一个中间页面被存在了浏览记录中。由此会导致自动执行 window.location.href 的页面又会重新跳转至目标页面。</p>\n</blockquote>"},{"title":"初识 Firebase","date":"2018-10-24T12:53:47.000Z","_content":"\n## 初次使用 Firebase \n\n### Firebase 是什么\n\n> Firebase 是 Google Cloud Platform 为开发者设计，提供各种工具，解决基础架构的问题。Firebase 提供基础性工作和工具，从而允许开发者专注于开发优质应用和扩大用户群。\n\n<!--more-->\n\n早在之前的 Google IO 开发者大会上就了解过 Firebase，但是之前还没有机会使用过 Firebase 这样的服务。\n\n由于本人在学习 Web 应用过程中，希望将编写完成的 Web 应用部署到云服务器上，从而考虑将 Firebase 作为 Web 应用后端。本文将介绍从零部署内容至 Firebase 的过程。\n\n### 开始使用 Firebase\n\n> 前期准备：\n>\n> - 一个 Google 账号\n> - nodejs 环境\n> - npm\n> - 科学的网络环境（ss）\n\n1. 在 cmd 中执行命令安装 Firebase 工具\n\n   ```\n   npm install -g firebase-tools\n   ```\n\n1. 使用 Google 账户登录到 [Firebase 控制台](https://firebase.google.com/console/)\n\n1. 在 Firebase 控制台中创建一个 Firebase 应用\n\n1. 在 cmd 中登录 Firebase\n\n   ```\n   firebase login\n   ```\n\n1. 在目标文件夹中初始化 Firebase 应用\n\n   ```\n   cd $your_object_path\n   firebsaae init \n   :: 此处如果出现 ETIMEDOUT 错误，那么需要手动为 CMD 设置代理\n   :: （见下方故障排除）\n   ```\n\n1. 部署到 Firebase 服务器\n\n   ```\n   firebase deploy\n   ```\n\n1. 应用将部署至 https://YOUR-FIREBASE-APP.firebaseapp.com\n\n### 手动设置代理\n\n鉴于国内的网络环境问题，即使使用了代理，在进入到 login 或者 init 步骤仍然可能出现网络问题，这时需要额外在 cmd 中设置临时代理（该命令仅临时生效）\n\n对于 Windows 系统设置命令行代理服务，在 CMD 中执行以下命令\n\n```\nset HTTP_PROXY=http://127.0.0.1:1080\nset HTTPS_PROXY=http://127.0.0.1:1080\n:: 以上的 http_proxy 不区分大小写\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/初识 Firebase.md","raw":"---\ntitle: 初识 Firebase\ndate: 2018-10-24 20:53:47\ntags: Firebase\n---\n\n## 初次使用 Firebase \n\n### Firebase 是什么\n\n> Firebase 是 Google Cloud Platform 为开发者设计，提供各种工具，解决基础架构的问题。Firebase 提供基础性工作和工具，从而允许开发者专注于开发优质应用和扩大用户群。\n\n<!--more-->\n\n早在之前的 Google IO 开发者大会上就了解过 Firebase，但是之前还没有机会使用过 Firebase 这样的服务。\n\n由于本人在学习 Web 应用过程中，希望将编写完成的 Web 应用部署到云服务器上，从而考虑将 Firebase 作为 Web 应用后端。本文将介绍从零部署内容至 Firebase 的过程。\n\n### 开始使用 Firebase\n\n> 前期准备：\n>\n> - 一个 Google 账号\n> - nodejs 环境\n> - npm\n> - 科学的网络环境（ss）\n\n1. 在 cmd 中执行命令安装 Firebase 工具\n\n   ```\n   npm install -g firebase-tools\n   ```\n\n1. 使用 Google 账户登录到 [Firebase 控制台](https://firebase.google.com/console/)\n\n1. 在 Firebase 控制台中创建一个 Firebase 应用\n\n1. 在 cmd 中登录 Firebase\n\n   ```\n   firebase login\n   ```\n\n1. 在目标文件夹中初始化 Firebase 应用\n\n   ```\n   cd $your_object_path\n   firebsaae init \n   :: 此处如果出现 ETIMEDOUT 错误，那么需要手动为 CMD 设置代理\n   :: （见下方故障排除）\n   ```\n\n1. 部署到 Firebase 服务器\n\n   ```\n   firebase deploy\n   ```\n\n1. 应用将部署至 https://YOUR-FIREBASE-APP.firebaseapp.com\n\n### 手动设置代理\n\n鉴于国内的网络环境问题，即使使用了代理，在进入到 login 或者 init 步骤仍然可能出现网络问题，这时需要额外在 cmd 中设置临时代理（该命令仅临时生效）\n\n对于 Windows 系统设置命令行代理服务，在 CMD 中执行以下命令\n\n```\nset HTTP_PROXY=http://127.0.0.1:1080\nset HTTPS_PROXY=http://127.0.0.1:1080\n:: 以上的 http_proxy 不区分大小写\n```\n\n\n\n\n\n\n\n\n\n","slug":"初识 Firebase","published":1,"updated":"2020-03-15T21:05:07.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7tjf3wm000u29fy041a2xk2","content":"<h2 id=\"初次使用-Firebase\"><a href=\"#初次使用-Firebase\" class=\"headerlink\" title=\"初次使用 Firebase\"></a>初次使用 Firebase</h2><h3 id=\"Firebase-是什么\"><a href=\"#Firebase-是什么\" class=\"headerlink\" title=\"Firebase 是什么\"></a>Firebase 是什么</h3><blockquote>\n<p>Firebase 是 Google Cloud Platform 为开发者设计，提供各种工具，解决基础架构的问题。Firebase 提供基础性工作和工具，从而允许开发者专注于开发优质应用和扩大用户群。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>早在之前的 Google IO 开发者大会上就了解过 Firebase，但是之前还没有机会使用过 Firebase 这样的服务。</p>\n<p>由于本人在学习 Web 应用过程中，希望将编写完成的 Web 应用部署到云服务器上，从而考虑将 Firebase 作为 Web 应用后端。本文将介绍从零部署内容至 Firebase 的过程。</p>\n<h3 id=\"开始使用-Firebase\"><a href=\"#开始使用-Firebase\" class=\"headerlink\" title=\"开始使用 Firebase\"></a>开始使用 Firebase</h3><blockquote>\n<p>前期准备：</p>\n<ul>\n<li>一个 Google 账号</li>\n<li>nodejs 环境</li>\n<li>npm</li>\n<li>科学的网络环境（ss）</li>\n</ul>\n</blockquote>\n<ol>\n<li><p>在 cmd 中执行命令安装 Firebase 工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g firebase-tools</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 Google 账户登录到 <a href=\"https://firebase.google.com/console/\" target=\"_blank\" rel=\"noopener\">Firebase 控制台</a></p>\n</li>\n<li><p>在 Firebase 控制台中创建一个 Firebase 应用</p>\n</li>\n<li><p>在 cmd 中登录 Firebase</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firebase login</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在目标文件夹中初始化 Firebase 应用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd $your_object_path</span><br><span class=\"line\">firebsaae init </span><br><span class=\"line\">:: 此处如果出现 ETIMEDOUT 错误，那么需要手动为 CMD 设置代理</span><br><span class=\"line\">:: （见下方故障排除）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部署到 Firebase 服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firebase deploy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>应用将部署至 <a href=\"https://YOUR-FIREBASE-APP.firebaseapp.com\" target=\"_blank\" rel=\"noopener\">https://YOUR-FIREBASE-APP.firebaseapp.com</a></p>\n</li>\n</ol>\n<h3 id=\"手动设置代理\"><a href=\"#手动设置代理\" class=\"headerlink\" title=\"手动设置代理\"></a>手动设置代理</h3><p>鉴于国内的网络环境问题，即使使用了代理，在进入到 login 或者 init 步骤仍然可能出现网络问题，这时需要额外在 cmd 中设置临时代理（该命令仅临时生效）</p>\n<p>对于 Windows 系统设置命令行代理服务，在 CMD 中执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set HTTP_PROXY=http://127.0.0.1:1080</span><br><span class=\"line\">set HTTPS_PROXY=http://127.0.0.1:1080</span><br><span class=\"line\">:: 以上的 http_proxy 不区分大小写</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"初次使用-Firebase\"><a href=\"#初次使用-Firebase\" class=\"headerlink\" title=\"初次使用 Firebase\"></a>初次使用 Firebase</h2><h3 id=\"Firebase-是什么\"><a href=\"#Firebase-是什么\" class=\"headerlink\" title=\"Firebase 是什么\"></a>Firebase 是什么</h3><blockquote>\n<p>Firebase 是 Google Cloud Platform 为开发者设计，提供各种工具，解决基础架构的问题。Firebase 提供基础性工作和工具，从而允许开发者专注于开发优质应用和扩大用户群。</p>\n</blockquote>","more":"<p>早在之前的 Google IO 开发者大会上就了解过 Firebase，但是之前还没有机会使用过 Firebase 这样的服务。</p>\n<p>由于本人在学习 Web 应用过程中，希望将编写完成的 Web 应用部署到云服务器上，从而考虑将 Firebase 作为 Web 应用后端。本文将介绍从零部署内容至 Firebase 的过程。</p>\n<h3 id=\"开始使用-Firebase\"><a href=\"#开始使用-Firebase\" class=\"headerlink\" title=\"开始使用 Firebase\"></a>开始使用 Firebase</h3><blockquote>\n<p>前期准备：</p>\n<ul>\n<li>一个 Google 账号</li>\n<li>nodejs 环境</li>\n<li>npm</li>\n<li>科学的网络环境（ss）</li>\n</ul>\n</blockquote>\n<ol>\n<li><p>在 cmd 中执行命令安装 Firebase 工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g firebase-tools</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 Google 账户登录到 <a href=\"https://firebase.google.com/console/\" target=\"_blank\" rel=\"noopener\">Firebase 控制台</a></p>\n</li>\n<li><p>在 Firebase 控制台中创建一个 Firebase 应用</p>\n</li>\n<li><p>在 cmd 中登录 Firebase</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firebase login</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在目标文件夹中初始化 Firebase 应用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd $your_object_path</span><br><span class=\"line\">firebsaae init </span><br><span class=\"line\">:: 此处如果出现 ETIMEDOUT 错误，那么需要手动为 CMD 设置代理</span><br><span class=\"line\">:: （见下方故障排除）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>部署到 Firebase 服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firebase deploy</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>应用将部署至 <a href=\"https://YOUR-FIREBASE-APP.firebaseapp.com\" target=\"_blank\" rel=\"noopener\">https://YOUR-FIREBASE-APP.firebaseapp.com</a></p>\n</li>\n</ol>\n<h3 id=\"手动设置代理\"><a href=\"#手动设置代理\" class=\"headerlink\" title=\"手动设置代理\"></a>手动设置代理</h3><p>鉴于国内的网络环境问题，即使使用了代理，在进入到 login 或者 init 步骤仍然可能出现网络问题，这时需要额外在 cmd 中设置临时代理（该命令仅临时生效）</p>\n<p>对于 Windows 系统设置命令行代理服务，在 CMD 中执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set HTTP_PROXY=http://127.0.0.1:1080</span><br><span class=\"line\">set HTTPS_PROXY=http://127.0.0.1:1080</span><br><span class=\"line\">:: 以上的 http_proxy 不区分大小写</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck7tjf3vy000029fy0k3dsl2z","tag_id":"ck7tjf3wv000v29fy32xccfnc","_id":"ck7tjf3xl001s29fy5naacr1t"},{"post_id":"ck7tjf3vy000029fy0k3dsl2z","tag_id":"ck7tjf3x2000w29fya3ermnok","_id":"ck7tjf3xl001t29fy9rz2pkud"},{"post_id":"ck7tjf3w1000129fyhu1xgusn","tag_id":"ck7tjf3x2000x29fyckilnxli","_id":"ck7tjf3xm001u29fydornex38"},{"post_id":"ck7tjf3w2000229fyziwwshds","tag_id":"ck7tjf3x3000y29fyxl64qjx8","_id":"ck7tjf3xm001v29fyr8rkcug9"},{"post_id":"ck7tjf3w3000329fy5q0fxc5s","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm001w29fy3e9ry5n6"},{"post_id":"ck7tjf3w4000429fy9gpbb7zk","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm001x29fy300znqbt"},{"post_id":"ck7tjf3w5000529fy1q62q6c8","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm001y29fytgo9oywd"},{"post_id":"ck7tjf3w5000629fyd5owt4oj","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm001z29fyo3uer39o"},{"post_id":"ck7tjf3w6000729fy5lk1ztp5","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002029fyb3f2ry4t"},{"post_id":"ck7tjf3w7000829fyrvu2zm5k","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002129fysidgp7vf"},{"post_id":"ck7tjf3w8000929fyh5xqvrxm","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002229fysy2vo5qq"},{"post_id":"ck7tjf3wa000a29fy7r116vgo","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002329fyr6tyxh8i"},{"post_id":"ck7tjf3wa000b29fyac7xo072","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002429fym8gj28dd"},{"post_id":"ck7tjf3wb000c29fyqjhdin77","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002529fy9v9rcdg5"},{"post_id":"ck7tjf3wc000d29fygj0xz7cq","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002629fyo35ajn1k"},{"post_id":"ck7tjf3wd000e29fyom8hfrcc","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002729fygtiwc9qz"},{"post_id":"ck7tjf3we000f29fy2bo86lsh","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002829fytfr1s3ub"},{"post_id":"ck7tjf3wf000g29fyzgusjb0p","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xm002929fy7cp5roy4"},{"post_id":"ck7tjf3wf000h29fy31wvct33","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002a29fyk8a2r5qo"},{"post_id":"ck7tjf3wg000i29fypkb6uwq1","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002b29fync5qvpdu"},{"post_id":"ck7tjf3wh000j29fyf3mb9wjc","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002c29fy4c6tbzwy"},{"post_id":"ck7tjf3wh000k29fyxnqlxwsy","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002d29fy01w32b8l"},{"post_id":"ck7tjf3wi000l29fyz1vg2hjr","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002e29fy1l6825lj"},{"post_id":"ck7tjf3wi000m29fyejba5fzh","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002f29fy0itj9o9s"},{"post_id":"ck7tjf3wj000n29fyup7w0gqg","tag_id":"ck7tjf3xb001j29fy5rgaalvt","_id":"ck7tjf3xn002g29fyto07mt75"},{"post_id":"ck7tjf3wj000o29fy8y92kmf0","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002h29fy81dl46fa"},{"post_id":"ck7tjf3wk000p29fyvb56uer4","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002i29fy6e1g15ga"},{"post_id":"ck7tjf3wk000q29fy2mqkv6z7","tag_id":"ck7tjf3x9001d29fy2t60wy0t","_id":"ck7tjf3xn002j29fyvyyoqpjk"},{"post_id":"ck7tjf3wk000r29fyswnqfaxl","tag_id":"ck7tjf3xc001n29fy9j6gh8yp","_id":"ck7tjf3xo002k29fyfnxvr1vo"},{"post_id":"ck7tjf3wk000r29fyswnqfaxl","tag_id":"ck7tjf3x3000z29fyu6qe88hr","_id":"ck7tjf3xo002l29fy6ehssj4q"},{"post_id":"ck7tjf3wl000s29fyikpeu3nj","tag_id":"ck7tjf3xd001p29fye9su23u1","_id":"ck7tjf3xo002m29fy9gk4euec"},{"post_id":"ck7tjf3wl000t29fy8gubjbgr","tag_id":"ck7tjf3xd001q29fybjb7t6bc","_id":"ck7tjf3xo002n29fy9chqkq0z"},{"post_id":"ck7tjf3wm000u29fy041a2xk2","tag_id":"ck7tjf3xd001r29fy97wtd2el","_id":"ck7tjf3xo002o29fyagb4u8z9"}],"Tag":[{"name":"flickr","_id":"ck7tjf3wv000v29fy32xccfnc"},{"name":"api","_id":"ck7tjf3x2000w29fya3ermnok"},{"name":"timeline","_id":"ck7tjf3x2000x29fyckilnxli"},{"name":"dart","_id":"ck7tjf3x3000y29fyxl64qjx8"},{"name":"Dart","_id":"ck7tjf3x3000z29fyu6qe88hr"},{"name":"MATLAB","_id":"ck7tjf3x9001d29fy2t60wy0t"},{"name":"HTTP","_id":"ck7tjf3xb001j29fy5rgaalvt"},{"name":"flutter","_id":"ck7tjf3xc001n29fy9j6gh8yp"},{"name":"git","_id":"ck7tjf3xd001p29fye9su23u1"},{"name":"JavaScript","_id":"ck7tjf3xd001q29fybjb7t6bc"},{"name":"Firebase","_id":"ck7tjf3xd001r29fy97wtd2el"}]}}