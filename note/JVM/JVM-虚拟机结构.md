---
title: Java 虚拟机结构
date: 2020-09-27 16:55:28
tags: [JVM]
---

### Java 虚拟机结构

虚拟机的结构文档只规定了抽象的，不涉及到 Java 虚拟机的具体实现。

实现 Java 虚拟机的条件是具备读取 `class` 文件的能力，而实际上的具体实现都可以由开发者自行实现。

> 值得一提的是：方法区是 JVM 的规范规定的存放类信息和静态变量的区域，在 1.7 之前使用永久代实现，而之后在 1.8 改成使用了元空间。

<!--分割线-->

<!--more-->

> 核心知识点：基本类型、运行时数据区


### `class` 文件的格式

虚拟机执行的代码是直接独立于硬件和操作系统的二进制指令，通常来说直接存储于一个 `class` 文件中。一个 `class` 文件包含了一个类或者接口的所有信息。

class 文件格式的具体标准件参见[TODO](http://TODO)


### 数据类型

如同 Java 语言的声明的一样，Java 虚拟机操作两种数据类型：基本类型和引用类型。可以将这两种数据作为变量，方法的参数或者返回值。

Java虚拟机要求几乎所有的类型检查要在运行前执行完，这部分实现是由编译器实现的。基本类型的值无需在运行时确定类型或者与引用类型区分开。相反的，Java 虚拟机指令集声明了针对不同基本类型的操作指令。例如：`iadd`、`ladd`、`fadd` 和 `dadd` 是 Java 虚拟机中对于 `int`、`long`、`float` 和 `double` 的二元加法指令。

#### 基本类型

Java 虚拟机中支持的类型可以直接分为三类：数值类型（`numeric`）、布尔类型（`boolean`）和返回地址类型（`returnAddress`）。

- 数值类型（`numeric`）
    - 整型数值
        - `byte`    8  位带符号的二进制补码整数，默认值为 0；
        - `short`   16 位带符号的二进制补码整数，默认值为 0；
        - `int`     32 位带符号的二进制补码整数，默认值为 0；
        - `long`    64 位带符号的二进制补码整数，默认值为 0；
        - `char`    16 位无符号的二进制补码整数，用于表示 UTF-16 编码的 Unicode 字符，默认值是空编码（'\u0000'）

    - 浮点数值
        - `float`   定义于单精度浮点数集合（或者是拓展单精度浮点数集合）中的元素，默认值为正零；
        - `double`  定义于双精度浮点数集合（或者是拓展双精度浮点数集合）中的元素，默认值为正零；

- 布尔类型（`boolean`）

    `boolean` 类型的取值只有 `true` 和 `false`，默认值是 `false`；

- 返回地址类型（`returnAddress`）

    `returnAddress` 类型是指向 Java 虚拟机指令的指针。
    > 在基本类型中， `returnAddress` 类型并不对应 Java 中的类型。

#### 整数类型和值

Java 虚拟机中，整型的取值范围为：

- 对于 `byte`  类型，其取值范围为 \[ -2^7 , 2^7-1 \]；
- 对于 `short` 类型，其取值范围为 \[-2^15, 2^16-1 \]；
- 对于 `int`   类型，其取值范围为 \[-2^31, 2^31-1 \]；
- 对于 `long`  类型，其取值范围为 \[-2^63, 2^63-1 \]；
- 对于 `char`  类型，其取值范围为 \[0    , 65535  \]；

#### 浮点型的类型、值域和值

浮点数的类型包括 `float` 和 `double`，与之相关联的是 IEEE-754 标准中声明的使用 32 位 binary32 和 64位的 binary64 浮点数格式的 IEEE-754 值和操作。

> 在 Java SE 15 之后，Java 虚拟使用 2019 版本的 IEEE-754 标准。 对于 Java SE 15 之前的版本，Java 虚拟机使用 1985 的 IEEE-754 标准。在 1985 版本中，binary32 和 binary64 分别被指定为单精度格式和双精度格式。


IEEE-754 标准不仅包含了正号和负号，还包含了正数零和负数零、正无穷和负无穷和非数字值 `Nan` (Not a Number)。`NaN` 表示数学上无意义的数，也是就计算机无效操作的结果（0除以0）

每个对 Java 虚拟机的实现都需要支持两种浮点值的集合（单精度浮点集和双精度浮点集）。此外，一些 Java 虚拟机的实现可以选择性的支持两种拓展指数浮点值集（单精度拓展指数浮点集和双精度拓展指数浮点集）。在某些情况下可以使用这些拓展精度浮点集作为 `float` 和 `double` 的值集。

> [下边的不想翻了](https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-2.html#jvms-2.3.2)

#### 返回地址类型（`returnAddress`）

返回地址类型是 Java 虚拟机中 `jsr`、`ret` 和 `jsr_w` 指令的操作数。该类型的值是指向 Java 虚拟机指令的操作码的指针。与数值基本类型不同，返回地址类型与 Java 语言的类型没有关联性，并且也不会在程序执行阶段被修改。

#### 布尔类型（`boolean`）

尽管 Java 虚拟机定义了布尔类型，但是虚拟机仅提供有限支持，没有专用的虚拟机操作指令，对于 Java 语言中操作的的布尔值编译成 Java 虚拟机的 `int` 的类型。

Java 虚拟机能够直接支持 Java 语言中的 boolean[]。其中的 `newarray` 指令能够创建布尔数组，对于布尔数组的读写都要使用 `byte` 数组的 `baload` 和 `bastore` 指令来实现。

> 在 Oracle 的 Java 虚拟机实现中，Java 语言中的布尔数组会被编译成 Java 虚拟机的 `byte` 数组，这时每个布尔元素都要使用 8 位空间。
>


Java 虚拟机的把布尔数组中的 1 解析为 `true`，把 0 解析为 `false`。如果 Java 语言中的 `boolean` 值经由编译器映射到 Java 虚拟机的 `int` 值，则编译器必须使用相同的编码。

> 注：这里的意思是 Java 虚拟机中对于 `boolean` 的大小并没有显示规定，`boolean` 可以使用 `int` 来表示。具体一个 `boolean` 占用多大的应当看使用场景和虚拟机实现。  
> 总结看来，在一般情况下，`boolean`  数组中 `boolean` 占用一个字节（8位）；在编译单个 `boolean` 值时，占用四个字节（32位）


### 引用类型和值

引用类型有三种：类引用，数组引用和接口引用，这三种引用分别对应了：类实例、数组以及实现接口的类实例或数组。

一个数组由单一维度的同类型组件组成。数组组件类型可以是任意类型也可以是数组。对于任意一个数组，其组件可能是数组，依次递推，其非数组类型的组件类型称为数组的**元素类型**。

Java 虚拟机中规定数组的元素类型必须是原始类型，类类型或者接口类型。

### 运行时数据区

Java 虚拟机的定义了多种程序执行阶段使用的运行时数据区。其中有些区域在虚拟机启动创建和虚拟机退出时销毁（生命周期依赖于虚拟机生命周期）；另外的数据区则是在线程创建时创建并在线程退出时销毁（生命周期依赖于线程生命周期）。

> 本质上就是，运行时数据区为线程共享还是线程私有决定了上面的特性。

#### PC 寄存器（PC Register，也叫做程序计数器）

- 线程私有
- 不会抛出 Error

Java 虚拟机支持多线程执行。每个 Java 虚拟机线程都存在一个独有的 pc （program counter，程序计数器）寄存器。在任意时间，每个 Java 虚拟机线程都在执行单个方法的代码，也就是该线程的当前方法。  
如果当前方法不是本地（native）方法，，那么 PC 寄存器会持有当前执行虚拟机指令的地址。
如果是本地方法，那么 PC 寄存器的值没有定义。Java 虚拟机中的 PC 寄存器有足够的空间用于在特定的平台上持有一个 `returnAddress` 或者本地指针。

PC 只是一个寄存器，因此也不会尝试抛出异常。

#### Java 虚拟机栈（Java Virtual Machine Stacks）

- 线程私有
- 会抛出 `OutOfMemoryError` 和 `StackOverflowError`

每个 Java 虚拟机线程的都有一个私有的 Java 虚拟机栈。该虚拟机栈在线程创建的同时创建。Java 虚拟机栈存放了多个栈帧。Java 虚拟机栈类似于常规语言（如 C 语言）中的栈：具有局部变量和局部结果，工作于方法调用和返回时。因为 Java 虚拟机除了压栈帧和出栈帧操作之外没有其他操作，因此可以在堆中分配栈帧。Java 虚拟机中的栈内存也不需要连续。

> 在 Java 虚拟机的第一版规范中，Java 虚拟机被称为 Java 栈。

规范中允许 Java 虚拟机栈可以具有固定的大小或者也可以根据计算需要动态扩容或减容。如果 Java 虚拟机栈是固定长度的，则在创建虚拟机栈是可以在栈创建时独立选择它们的大小。

Java 虚拟机的实现应当为程序员或使用者提供设置 Java 虚拟机栈长度的初始大小，以及支持动态调整容量时，设置容量最大最小值的能力。

Java 虚拟机栈可能会抛出两种异常：

- **如果线程中的计算需要比允许的 Java 虚拟机栈规定的最大值更大，则 Java 虚拟机将抛出 `StackOverflowError`**；
- **如果 Java 虚拟机栈支持动态扩容时没有足够的内存空间用于扩容，或者如果没有足够的内存来为新线程创建初始化的 Java 虚拟机栈，则 Java 虚拟机将抛出 `OutOfMemoryError`**；

#### 堆（Heap）

- 线程共享
- 抛出 `OutOfMemoryError`

Java 虚拟机存在一个虚拟机线程共享的堆。堆是运行时数据区中为类实例和数组分配内存的内存空间。

- 堆是在虚拟机启动时创建。
- 堆中用于存储对象的空间会被**自动储存管理系统**（也叫做垃圾收集器，GC）回收；
- 对象永远不会被显示释放（C 语言中就有 delete 释放内存，Java 虚拟机不支持显示释放）
- Java 虚拟机本身不设定指定的自动内存管理系统，可以根据实现者的系统要求选择内存管理方案。（虚拟机的不同实现有不同的对象实例收集算法和垃圾收集算法）
- 堆的大小可以使固定的也可以根据计算量进行扩容或减容。
- 堆的内存空间不要求连续。

Java 虚拟机的实现应当为程序员或使用者提供设置 Java 虚拟机堆容量的初始大小，以及支持动态调整容量时，设置堆容量最大最小值的能力。

Java 堆空间会尝试抛出一种异常：

- **当计算需要使用的堆空间多于自动内存存储管理系统可以分配的空间，此时 Java 虚拟机会抛出 `OutOfMemoryError`**



#### 方法区（Method Area）

Java 虚拟机存在一个虚拟机线程共享的方法区。方法区类似于常规语言中已编译代码的存储区域，方法区存储了每一个类的结构信息，例如运行时常亮池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些类、实例、接口初始化的特殊方法。

- 方法区在虚拟机启动时创建。尽管方法区逻辑上属于堆的一部分，但是实现上可以选择不进行垃圾回收或压缩。
    > 逻辑上属于堆，但不受到堆的内存管理，也有"非堆"（Non-Heap）的别名
- 规范中并不规定方法区的具体位置和管理已编译代码的策略。
- 方法区可以是固定大小的，也可以是根据计算需要进行扩容或减容。
- 方法区的内存空间并不要求连续。

Java 虚拟机的实现应当为程序员或使用者提供设置 Java 虚拟机方法区容量的初始大小，以及支持动态调整容量时，设置方法区容量最大最小值的能力。

Java 方法区可能会抛出一种异常
- **如果方法区的内存不足以用于申请分配内存（其实就是类加载的时机），Java 虚拟机抛出 `OutOfMemoryError`**

#### 运行时常量池（Runtime Constant Pool）

运行时常量池是类文件中常量池（Constant Pool）的运行时表示形式，它包括了多种常量：从编译器数值字面量、到运行时才能解析获得的方法或字段引用。运行时常量池类似于常规编程语言中的符号表，尽管它包含的数据范围比典型的符号表还要大。

每个运行时常量池都分配在 Java 虚拟机的方法区中。Java 虚拟机创建类或者接口，会同时构造类和接口的运行时常量池。

运行时常量池会抛出一种异常：
- **创建类或者接口时，如果构造过程运行时常量池需要的内存超出 Java 虚拟机的方法区可用容量，Java 虚拟机抛出一个 `OutOfMemoryError`**。

有关，参见[Todo](http://todo)

#### 本地方法栈（Native Method Stack）

Java 虚拟机的实现可以使用传统的栈结构（俗称 C Stack）来实现本地方法（不适用 Java 便携的方法）的执行流程。如果虚拟机不加载本地方法，并且自身不依赖于传统栈实现，可以不提供本地方法栈的实现；如果提供了实现，通常应该在每个线程创建时提供本地方法栈。

- Java 虚拟机允许本地方法栈为固定大小或者支持动态调整容量。
- 如果采用固定大小的本地方法栈，那么每个本地方法栈的容量应该在栈创建时独立设置。
- Java 虚拟机的实现应当为程序员或使用者提供设置 Java 虚拟机本地方法栈容量的初始大小，以及支持动态调整容量时，设置设置方法区容量最大最小值的能力。

本地方法区会抛出两种异常：
- **如果线程中的计算需要比允许的本地方法栈规定的最大值更大，Java 虚拟机抛出 `StackOverflowError`**。
- **本地方法栈扩容时或者创建新线程创建本地方法栈时出现内存不足，Java 虚拟机抛出 `OutOfMemoryError`**。


### 栈帧（`frame`）

栈帧用于存储数据和部分运行结果，以及处理动态链接、方法的返回值和异常分配。

每当有一个方法被调用时，一个新的栈帧就会被创建；每当一个方法调用结束后，就有一个栈帧销毁（无论是正常结束，还是抛出异常）。栈帧从创建该栈帧的线程对应的虚拟机栈中分配空间。每个栈帧都有一套私有的局部变量表（`local variable`）、操作数栈(`operand stack`)、以及指向当前类和方法的运行时常量池的引用·

> 一个栈帧还允许在实现时携带更多虚拟机实现的相关信息如，程序调试信息。

局部变量表和操作数栈的长度决定于编译时，并保存在 `class` 字节码文件中方法（`method_info`）的 `Code` 属性中（`max_locals` 和 `max_stack`）。因此栈帧的数据结构的大小只取决于 Java 虚拟机的实现。进而，虚拟机的实现可以在方法调用时才为栈帧数据结构分配其需要的内存空间。


> 注：class 字节码文件中使用 method_info 类型的数组 methods 描述类内部的方法，其中 method_info 结构中使用多种属性（Attribute）进行描述，其中里的 Code 型属性包含了虚拟机指令和方法执行的一些辅助信息。

在整个线程的执行过程中，有且只有一个栈顶栈帧才是处于正在执行的状态，这个栈帧称为**当前栈帧（`current frame`）**，其对应的方法为**当前方法（`current method`）**。定义当前方法的类称为**当前类（`current class`）**。对局部变量表和操作数栈的操作通常指当前栈帧的操作。

如果一个栈帧在当前方法调用了其他方法或者执行结束，那么该栈帧就不再是当前栈帧。调用方法时，将创建新的栈帧，该栈帧在程序控制权移交给新方法时成为新的当前栈帧。方法返回时，当前栈帧会回传当前方法的返回值给前一个栈帧，而后虚拟机丢弃当前栈帧，前一个栈帧重新成为当前栈帧。

值得注意的是，栈帧是线程私有的（虚拟机栈是线程私有有），无法被其他线程引用。

#### 局部变量表（`local variable`

每个栈帧内部都包含一个变量的列表，这个列表称为局部变量表。局部变量表的长度在编译期确定，并且通过方法中的 `Code` 属性存储于类或者接口的字节码文件中，提供给栈帧使用。

单个局部变量可以保存的值类型包括: `boolean`、`char`、`short`、`int`、`float`、`reference` 或者 `returnAddress`；一对局部变量则可以保存 `long` 或者 `double` 类型的值。

> 注：在 32 位的计算机中，取数的最小单位是四字节（32位）。在这种情况下，虚拟机为了高效取数通常会用到一种设计的技巧——地址对齐。地址对齐就是把不足 32 位的信息放在每个 32 位信息的低位地址，虚拟机不再关注存储时数据的类型，而是仅在执行指令时区分类型，对高位数值进行掩码操作。
> 值得一提的是，这里多种类型的变量收到地址对齐的影响在操作数栈中占用的空间会与设想不同，比如 `boolean` 类型在这里占用四字节，而使用 `boolean[]` 数组中时每个值只占用一个字节。

局部变量通过索引进行寻址。第一个局部变量的索引值为 0。当且仅当一个整数值在 0 到局部变量表长度减一的区间内才能认为是数组的索引。（`[0, size - 1]`）

`long` 和 `double` 类型的值占用两个连续的局部变量。这样的值只能使用二者之间较小的索引。比如存储在索引 n 位置的 `double` 值实际上占用了 n 和 n+1 两个位置。对于 n+1 的这个位置而言，无法从 n+1 的位置加载局部变量；允许向 n+1 的位置写入新值，但写入后局部变量 n 的内容失效。


### 操作树栈（`operand stack`）

每个栈帧内部都包含一个后进先出（Last In First Out， LIFO）的栈，称为操作数栈。操作数栈的最大深度在编译期确定，并且通过方法的 `Code` 属性保存在字节码文件中，提供给栈帧使用。

如果上下文足够明确，我们通常把当前栈帧的操作数栈简述为操作数栈。

操作数栈在刚栈帧创建时是空的。Java 虚拟机提供了一些用于从局部变量表或实例字段复制常量或变量到操作数栈的指令。其余的 Java 虚拟机指令从操作数栈中取出操作数、操作数并将计算结果重新压入操作数栈。在调用方法时，操作数栈还用于准备提供方法的入参和接收方法返回结果。

例如，`iadd` 字节码指令支持把两个 `int` 型数值相加。这要求执行该指令之前，操作数栈栈顶已经存在两个通过先前的指令放入栈顶的 `int` 型数值。两个 `int` 都会从操作数栈中出栈。两个数相加求和后，两数之和压入操作数栈。子运算在操作数栈中嵌套进行，计算得到结果可以被外围运算使用。（TODO：无法理解这句话）

操作数栈的每个位置可以保存一个 Java 虚拟机支持的数据类型，包括 `long` 和 `double` 类型。

操作数栈中的数必须依据其类型被正确操作。例如，不可以向操作数栈压入两个`int` 型数值的情况下当成 `long`，或者压入两个 `float` 型数据之后使用 `iadd` 指令去操作。小部分的 Java 虚拟机指令（`dup` 指令和 `swap` 指令）不关注操作数值的具体类型，直接把运行时数据区的数据当成纯数值；这些指令定义为不修改和破坏单个独立的值。这些操作数栈操作的限制通过 `class` 文件校验来进行强制保证。

在任一时刻，操作数栈有一个确定的栈深度。对于 `long` 和 `double` 类型占用两个单位深度，其余类型占用一个单位深度。

#### 动态链接（`dynamic linking`）

每个栈帧都有一个栈帧所属方法在运行时常量池的引用，该引用用于支持该方法代码的动态链接。`class` 文件的方法字节码通过动态链接关联到 `class` 文件常量池中的调用的方法和变量。动态链接将这些方法引用转译成具体方法的引用，根据需要将类解析为未定义的符号，并将变量访问转换为变量运行时在存储结构的位置相关的偏移量。

> 注：方法内部的字节码指令的操作数理论上应该加载到操作数栈

这种对方法和变量后期绑定适用于使得使用该方法的其他类难以侵入到内部代码。


#### 方法正常调用完成（Normal Method Invocation Completion）

如果方法调用过程不会直接从虚拟机或者显式通过 `throw` 语句抛出异常，这种情况视为方法调用正常。如果当前方法的调用正常完成，通常会将一个返回值传递给调用者方法。

当前栈帧会用于恢复调用者的状态，包括局部变量和操作数栈，同时适当增加调用线程的程序计数器来跳过方法调用指令。从而将返回值（如果需要）压入该帧的操作数栈后，程序可以在方法调用者的帧中继续进行。

当前栈帧会用于恢复调用者的状态，包括局部变量和操作数栈，同时适当增加调用线程的程序计数器来跳过方法调用指令。

#### 方法调用异常完成（Abrupt Method Invocation Completion）

方法调用**异常完成**是指在方法的执行过程中，方法中的 Java 虚拟机指令导致了 Java 虚拟机的抛出异常并且方法内部无法处理该异常；执行 `athrow` 字节码指令同样可以显式地抛出异常，导致方法异常完成。方法异常调用完成不会像调用者提供返回值。

### 对象的表示 

Java 虚拟机规范并不规定对象的具体内部结构的细节。

> 在 Oracle 的一些 Java 虚拟机实现中，类实例的引用是指向句柄（`handle`）的指针，句柄本身又包含两个指针：一个指针指向一个包含对象的方法清单和类的 `Class` 对象指针的表格，另一个指针指向分配在堆空间的实例数据。


### 浮点数运算（不想写？？那就暂时不写了）

```
// Todo
```


### 特殊方法（Special Methods）

在 Java 虚拟机层面，用 Java 语言编写的每个构造函数以命名为 `<init>` 的**实例初始化方法（instance initialization method）**的形式存在。这个方法名是由编译器提供，由于 `<init>` 这个名称无法作为标志符，因此无法直接被 Java 程序使用。实例初始化方法只能在 Java 虚拟机调用 `invokespecial` 字节码指令时在为初始化的类实例上被调用。实例初始化方法具有对应的 Java 构造方法中的访问权限。


一个类或者接口最多有一个**类初始化方法**或**接口初始化方法**，类或者接口通过调用这个方法进行初始化。类或接口的初始化方法有专有的特殊名称 `<clinit>`，并且是无参无返回值（void）的。

> 注：实例对象初始化和类对象的初始化。

 > `class` 文件中其它命名为 `<clinit>` 没有作用。它们既不会被任何 Java 虚拟机指令调用，也不会被 Java 虚拟机自身调用。

 在版号本大于 51.0 的 `class` 文件中，该方法还必须设置其 `ACC_STATIC` 标志位，以便用作类或接口初始化方法。

 > 这个要求在 Java SE 7 中引入。在版号本低于 50.0 的 `class` 文件中，方法名为 `<clinit>` 的无参无返回值方法被认为是类或接口的初始化方法，无论该方法是否被标记为 `ACC_STATIC`。

`<clinit>` 这个方法名使用编译器提供的。因为 `<clinit>` 不是合法的标识符，无法通过 Java 程序直接使用。类和接口初始化方法通过 Java 虚拟机隐式调用；无法直接通过 Java 虚拟机指令调用，只能在类的初始化阶段间接被调用。

当一个方法满足以下条件时，方法是签名多态的（signature polymorphic），也可以说具有签名多态性。

- 通过 `java.lang.invoke.MethodHandle` 类声明；
- 只有一个 `Object[]` 类型的形参；
- 有一个返回类型为 `Object` 的返回值；
- 具有 `ACC_VARARGS` 和 `ACC_NATIVE` 标记位；

> 在 Java SE 8 中，签名多态方法只有 `java.lang.MethodHandle` 类的 `invoke` 方法和 `invokeExact` 方法。

Java 虚拟机在 `invokevirtual` 指令时，为签名多态方法进行特殊处理，保证方法句柄（method handle）的调用。方法句柄是对基础方法、构造函数、字段或者其他低级操作的可执行的强引用，并具有参数和返回值的选择性转换能力。这里的转换能力（transformations）非常广泛，包括转换、插入、删除以及替换等形式的变换。更多信息可以查看 Java SE 平台的 API 文档中的 `java.lang.invoke` 包。

### 异常（Exceptions）

Java 虚拟机中的异常用 `Throwable` 或者其子类的实例来表示。抛出异常会导致程序控制权从异常抛出位置进行即时的、非局部的转移。

> 注：异常的本质就是程序控制权的转移，如果无法控制就崩了。

绝大多数的异常同步出现在当前线程的执行的某个操作过程中。不同的是，异步的异常有可能出现在程序执行的任意位置。Java 虚拟机抛出异常通常基于以下三个原因之一：

- 执行了 `athrow` 指令；
- Java 虚拟机同步检测到非正常的执行条件。这种异常不会在程序执行的任意阶段抛出，而是在字节码指令的异常执行后同步抛出：
    - 以下特殊特定的操作可能会异常异常
        - 当指令表示的操作违背了 Java 语言的语义，如对一个数组进行越界访问。
        - 加载或者链接程序的一部分时出现错误；
    - 程序资源的使用超出了限制，例如使用了过多的内存。
- 异步的异常发生，通常由于：
    - 线程（`Thread`）或线程组（`ThreadGroup`）的 `stop` 方法被调用。
    - Java 虚拟机实现的内部出现异常。
    当某个线程调用了 `stop` 方法被调用，会影响到其他线程或者特定线程组的所有线程。由于异常出现的时机可能是执行的任意位置，（注：由其他线程引发了异常）这种称为异步异常。虚拟机的内部错误也认为是异步异常。

Java 虚拟机允许在异步异常抛出前执行一段有限的操作。这允许代码优化器在遵循 Java 语义的情况下检测并将这些异常抛出到可以处理的位置。

> 一个简单的实现可能会轮询每个控制传输指令的异步异常。由于程序具有有限的大小，因此对检测异步异常的总延迟提供了约束。由于控制传输之间不会发生异步异常，因此代码生成器具有一定的灵活性，可以在控制传输之间重新排序计算，以提高性能。详细参照《Polling Efficiently on Stock Hardware》

Java 虚拟机抛出异常有精确地定义：当控制权发生转移时，在抛出异常的位置之前的字节码指令的执行效果都可以被观察到。抛出异常的位置之后的所有指令都不应当产生执行的效果。如果虚拟机执行的是优化后的代码，有一些在抛出异常的位置之后的代码可能已经执行了，那这些优化过的代码必须确保其效用对用户程序不可见。

> 注：设想中的虚拟机的指令应当具有指令执行的"原子性"。

Java 虚拟机执行的每个方法都关联了零个或多个异常处理器（`exception handlers`）。异常处理器规定了 Java 虚拟机方法代码实现的偏移范围，能处理的异常类型以及处理异常的代码的位置。如果指令的偏移量，异常匹配到异常处理器。当抛出异常时，Java 虚拟机会在当前方法中搜索匹配的异常处理器。如果能够找到匹配的异常处理器，系统将切换到异常处理代码的分支上执行。

如果当前方法不包含任何异常处理器，当前方法将突然调用完成。方法调用异常完成时，当前方法的操作数栈和局部变量表会被丢弃，当前帧会弹出，恢复到调用该方法的栈帧处。随后，方法调用者的上下文中抛出异常，在方法调用链中持续执行该操作。如果在方法调用链的顶部仍没有找到合适的异常处理器，抛出异常的整个线程都会终止。

方法的异常处理器检索顺序是比较关键的。在同一个 `class` 文件中，每个方法的异常处理器

  
















