---
title: Java 虚拟机结构
date: 2020-09-27 16:55:28
tags: [JVM]
---

### Java 虚拟机结构

虚拟机的结构文档只规定了抽象的，不涉及到 Java 虚拟机的具体实现。

实现 Java 虚拟机的条件是具备读取 `class` 文件的能力，而实际上的具体实现都可以由开发者自行实现。

> 值得一提的是：方法区是 JVM 的规范规定的存放类信息和静态变量的区域，在 1.7 之前使用永久代实现，而之后在 1.8 改成使用了元空间。

<!--分割线-->

<!--more-->

> 核心知识点：基本类型、运行时数据区


### `class` 文件的格式

虚拟机执行的代码是直接独立于硬件和操作系统的二进制指令，通常来说直接存储于一个 `class` 文件中。一个 `class` 文件包含了一个类或者接口的所有信息。

class 文件格式的具体标准件参见[TODO](http://TODO)


### 数据类型

如同 Java 语言的声明的一样，Java 虚拟机操作两种数据类型：基本类型和引用类型。可以将这两种数据作为变量，方法的参数或者返回值。

Java虚拟机要求几乎所有的类型检查要在运行前执行完，这部分实现是由编译器实现的。基本类型的值无需在运行时确定类型或者与引用类型区分开。相反的，Java 虚拟机指令集声明了针对不同基本类型的操作指令。例如：`iadd`、`ladd`、`fadd` 和 `dadd` 是 Java 虚拟机中对于 `int`、`long`、`float` 和 `double` 的二元加法指令。

#### 基本类型

Java 虚拟机中支持的类型可以直接分为三类：数值类型（`numeric`）、布尔类型（`boolean`）和返回地址类型（`returnAddress`）。

- 数值类型（`numeric`）
    - 整型数值
        - `byte`    8  位带符号的二进制补码整数，默认值为 0；
        - `short`   16 位带符号的二进制补码整数，默认值为 0；
        - `int`     32 位带符号的二进制补码整数，默认值为 0；
        - `long`    64 位带符号的二进制补码整数，默认值为 0；
        - `char`    16 位无符号的二进制补码整数，用于表示 UTF-16 编码的 Unicode 字符，默认值是空编码（'\u0000'）

    - 浮点数值
        - `float`   定义于单精度浮点数集合（或者是拓展单精度浮点数集合）中的元素，默认值为正零；
        - `double`  定义于双精度浮点数集合（或者是拓展双精度浮点数集合）中的元素，默认值为正零；

- 布尔类型（`boolean`）

    `boolean` 类型的取值只有 `true` 和 `false`，默认值是 `false`；

- 返回地址类型（`returnAddress`）

    `returnAddress` 类型是指向 Java 虚拟机指令的指针。
    > 在基本类型中， `returnAddress` 类型并不对应 Java 中的类型。

#### 整数类型和值

Java 虚拟机中，整型的取值范围为：

- 对于 `byte`  类型，其取值范围为 [-2^7 , 2^7-1 ]；
- 对于 `short` 类型，其取值范围为 [-2^15, 2^16-1]；
- 对于 `int`   类型，其取值范围为 [-2^31, 2^31-1]；
- 对于 `long`  类型，其取值范围为 [-2^63, 2^63-1]；
- 对于 `char`  类型，其取值范围为 [0    , 65535 ]；

#### 浮点型的类型、值域和值

浮点数的类型包括 `float` 和 `double`，与之相关联的是 IEEE-754 标准中声明的使用 32 位 binary32 和 64位的 binary64 浮点数格式的 IEEE-754 值和操作。

> 在 Java SE 15 之后，Java 虚拟使用 2019 版本的 IEEE-754 标准。 对于 Java SE 15 之前的版本，Java 虚拟机使用 1985 的 IEEE-754 标准。在 1985 版本中，binary32 和 binary64 分别被指定为单精度格式和双精度格式。


IEEE-754 标准不仅包含了正号和负号，还包含了正数零和负数零、正无穷和负无穷和非数字值 `Nan` (Not a Number)。`NaN` 表示数学上无意义的数，也是就计算机无效操作的结果（0除以0）

每个对 Java 虚拟机的实现都需要支持两种浮点值的集合（单精度浮点集和双精度浮点集）。此外，一些 Java 虚拟机的实现可以选择性的支持两种拓展指数浮点值集（单精度拓展指数浮点集和双精度拓展指数浮点集）。在某些情况下可以使用这些拓展精度浮点集作为 `float` 和 `double` 的值集。

> [下边的不想翻了](https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-2.html#jvms-2.3.2)

#### 返回地址类型（`returnAddress`）

返回地址类型是 Java 虚拟机中 `jsr`、`ret` 和 `jsr_w` 指令的操作数。该类型的值是指向 Java 虚拟机指令的操作码的指针。与数值基本类型不同，返回地址类型与 Java 语言的类型没有关联性，并且也不会在程序执行阶段被修改。

#### 布尔类型（`boolean`）

尽管 Java 虚拟机定义了布尔类型，但是虚拟机仅提供有限支持，没有专用的虚拟机操作指令，对于 Java 语言中操作的的布尔值编译成 Java 虚拟机的 `int` 的类型。

Java 虚拟机能够直接支持 Java 语言中的 boolean[]。其中的 `newarray` 指令能够创建布尔数组，对于布尔数组的读写都要使用 `byte` 数组的 `baload` 和 `bastore` 指令来实现。

> 在 Oracle 的 Java 虚拟机实现中，Java 语言中的布尔数组会被编译成 Java 虚拟机的 `byte` 数组，这时每个布尔元素都要使用 8 位空间。
>


Java 虚拟机的把布尔数组中的 1 解析为 `true`，把 0 解析为 `false`。如果 Java 语言中的 `boolean` 值经由编译器映射到 Java 虚拟机的 `int` 值，则编译器必须使用相同的编码。

> 注：这里的意思是 Java 虚拟机中对于 `boolean` 的大小并没有显示规定，`boolean` 可以使用 `int` 来表示。具体一个 `boolean` 占用多大的应当看使用场景和虚拟机实现。  
> 总结看来，在一般情况下，`boolean`  数组中 `boolean` 占用一个字节（8位）；在编译单个 `boolean` 值时，占用四个字节（32位）


### 引用类型和值

引用类型有三种：类引用，数组引用和接口引用，这三种引用分别对应了：类实例、数组以及实现接口的类实例或数组。

一个数组由单一维度的同类型组件组成。数组组件类型可以是任意类型也可以是数组。对于任意一个数组，其组件可能是数组，依次递推，其非数组类型的组件类型称为数组的**元素类型**。

Java 虚拟机中规定数组的元素类型必须是原始类型，类类型或者接口类型。

### 运行时数据区

Java 虚拟机的定义了多种程序执行阶段使用的运行时数据区。其中有些区域在虚拟机启动创建和虚拟机退出时销毁（生命周期依赖于虚拟机生命周期）；另外的数据区则是在线程创建时创建并在线程退出时销毁（生命周期依赖于线程生命周期）。

> 本质上就是，运行时数据区为线程共享还是线程私有决定了上面的特性。

#### PC 寄存器（PC Register，也叫做程序计数器）

- 线程私有
- 不会抛出 Error

Java 虚拟机支持多线程执行。每个 Java 虚拟机线程都存在一个独有的 pc （program counter，程序计数器）寄存器。在任意时间，每个 Java 虚拟机线程都在执行单个方法的代码，也就是该线程的当前方法。  
如果当前方法不是本地（native）方法，，那么 PC 寄存器会持有当前执行虚拟机指令的地址。
如果是本地方法，那么 PC 寄存器的值没有定义。Java 虚拟机中的 PC 寄存器有足够的空间用于在特定的平台上持有一个 `returnAddress` 或者本地指针。

PC 只是一个寄存器，因此也不会尝试抛出异常。

#### Java 虚拟机栈（Java Virtual Machine Stacks）

- 线程私有
- 会抛出 `OutOfMemoryError` 和 `StackOverflowError`

每个 Java 虚拟机线程的都有一个私有的 Java 虚拟机栈。该虚拟机栈在线程创建的同时创建。Java 虚拟机栈存放了多个栈帧。Java 虚拟机栈类似于常规语言（如 C 语言）中的栈：具有局部变量和局部结果，工作于方法调用和返回时。因为 Java 虚拟机除了压栈帧和出栈帧操作之外没有其他操作，因此可以在堆中分配栈帧。Java 虚拟机中的栈内存也不需要连续。

> 在 Java 虚拟机的第一版规范中，Java 虚拟机被称为 Java 栈。

规范中允许 Java 虚拟机栈可以具有固定的大小或者也可以根据计算需要动态扩容或减容。如果 Java 虚拟机栈是固定长度的，则在创建虚拟机栈是可以在栈创建时独立选择它们的大小。

Java 虚拟机的实现可以为程序员或使用者提供控制 Java 虚拟机栈长度的初始大小和扩容或减容时控制最大最小值的能力。

Java 虚拟机栈可能会抛出两种异常：

- **如果线程中的计算需要比允许的 Java 虚拟机栈，则 Java 虚拟机将抛出 `StackOverflowError`**；
- **如果 Java 虚拟机栈支持动态扩容时没有足够的内存空间用于扩容，或者如果没有足够的内存来为新线程创建初始化的 Java 虚拟机栈，则 Java 虚拟机将抛出 `OutOfMemoryError`**；

#### 堆（Heap）

- 线程共享
- 抛出 `OutOfMemoryError`

Java 虚拟机存在一个虚拟机线程共享的堆。堆是运行时数据区中为类实例和数组分配内存的内存空间。

- 堆是在虚拟机启动时创建。
- 堆中用于存储对象的空间会被**自动储存管理系统**（也叫做垃圾收集器，GC）回收；
- 对象永远不会被显示释放（C 语言中就有 delete 释放内存，Java 虚拟机不支持显示释放）
- Java 虚拟机本身不设定指定的自动内存管理系统，可以根据实现者的系统要求选择内存管理方案。（虚拟机的不同实现有不同的对象实例收集算法和垃圾收集算法）
- 堆的大小可以使固定的也可以根据计算量进行扩容或减容。
- 堆的内存空间不要求连续

Java 虚拟机的实现可以为程序员或使用者提供控制 Java 虚拟机堆容量的初始大小和扩容或减容时控制堆容量最大最小值的能力。

Java 堆空间会尝试抛出一种异常：

- **当计算需要使用的堆空间多于自动内存存储管理系统可以分配的空间，此时 Java 虚拟机会抛出 `OutOfMemoryError`**



#### End

> asdh









